<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>HQP的个人博客</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="ayjcsgm.github.io/"/>
  <updated>2019-10-18T08:22:33.196Z</updated>
  <id>ayjcsgm.github.io/</id>
  
  <author>
    <name>Huangqiuping</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Git教程</title>
    <link href="ayjcsgm.github.io/2019/10/18/Git%E6%95%99%E7%A8%8B/"/>
    <id>ayjcsgm.github.io/2019/10/18/Git教程/</id>
    <published>2019-10-18T08:21:05.000Z</published>
    <updated>2019-10-18T08:22:33.196Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://picsum.photos/800/209" alt></p><div id="article_content" class="article_content clearfix">                                    <link rel="stylesheet" href="https://blog.csdn.net/weixin_43664418/article/details/102627420">                                        <link rel="stylesheet" href="https://blog.csdn.net/weixin_43664418/article/details/102627420">                <div class="htmledit_views" id="content_views">                                            <h1><a href="https://blog.csdn.net/weixin_43664418/article/details/102627420" rel="noopener" id="cb_post_title_url" data-token="0deb5f3a1d47256108b5292807fb43e9" target="_blank">Git教程</a></h1><a id="more"></a><p><a name="_labelTop"></a></p><p><strong>阅读目录</strong></p><ul><li><a href="https://blog.csdn.net/weixin_43664418/article/details/102627420" rel="noopener" data-token="f55873a6499c57780bbd0769b0fd4e39" target="_blank">Git是什么</a></li>    <li><a href="https://blog.csdn.net/weixin_43664418/article/details/102627420" rel="noopener" data-token="003fc9e0417c246fd177b00387461e59" target="_blank">SVN与Git的最主要的区别</a></li>    <li><a href="https://blog.csdn.net/weixin_43664418/article/details/102627420" rel="noopener" data-token="edd9f6ad1d578611f6449bbd2595d754" target="_blank">在windows上如何安装Git</a></li>    <li><a href="https://blog.csdn.net/weixin_43664418/article/details/102627420" rel="noopener" data-token="36b53cbebff787ca309b12a573f7c292" target="_blank">如何操作</a></li>    <li><a href="https://blog.csdn.net/weixin_43664418/article/details/102627420" rel="noopener" data-token="5588ef7897290fbbc6ff3159967391e6" target="_blank">&nbsp; 创建版本库</a></li>    <li><a href="https://blog.csdn.net/weixin_43664418/article/details/102627420" rel="noopener" data-token="c64814bdc4a1f2beaf1e97b248365934" target="_blank">&nbsp; &nbsp; &nbsp;把文件添加到版本库中</a></li>    <li><a href="https://blog.csdn.net/weixin_43664418/article/details/102627420" rel="noopener" data-token="eec059421a2b43de188bf72f501ad5c8" target="_blank">版本回退</a></li>    <li><a href="https://blog.csdn.net/weixin_43664418/article/details/102627420" rel="noopener" data-token="62a6b44463de939c0b6fca1ce4524aad" target="_blank">&nbsp;理解工作区与暂存区的区别</a></li>    <li><a href="https://blog.csdn.net/weixin_43664418/article/details/102627420" rel="noopener" data-token="331a7246200d302f9eb0bbe53900af85" target="_blank">Git撤销修改和删除文件操作</a></li>    <li><a href="https://blog.csdn.net/weixin_43664418/article/details/102627420" rel="noopener" data-token="3d0c886f2148dd7df051e34beba4c242" target="_blank">撤销修改</a></li>    <li><a href="https://blog.csdn.net/weixin_43664418/article/details/102627420" rel="noopener" data-token="fb7cb7f1fd2cc2d4ead88a966c7ae1de" target="_blank">删除文件</a></li>    <li><a href="https://blog.csdn.net/weixin_43664418/article/details/102627420" rel="noopener" data-token="de28b942c5bea136f0617a737b81aa90" target="_blank">&nbsp;远程仓库</a></li>    <li><a href="https://blog.csdn.net/weixin_43664418/article/details/102627420" rel="noopener" data-token="7faf4af62f24e20462714289d470853b" target="_blank">如何解决冲突</a></li>    <li><a href="https://blog.csdn.net/weixin_43664418/article/details/102627420" rel="noopener" data-token="d97fda7b8c4393ebb0a80a22221d0292" target="_blank">分支管理策略</a></li>    <li><a href="https://blog.csdn.net/weixin_43664418/article/details/102627420" rel="noopener" data-token="166ded8e6cc5ed715e8ae3c5d79f8e8a" target="_blank">多人协作</a></li>    <li><a href="https://blog.csdn.net/weixin_43664418/article/details/102627420" rel="noopener" data-token="082207916a3e71cfdf491c82aad4a727" target="_blank">抓取分支</a></li>    <li><a href="https://blog.csdn.net/weixin_43664418/article/details/102627420" rel="noopener" data-token="1ac011c203ffbf7f933b9d697822703d" target="_blank">Git基本常用命令如下</a></li><h6 id="Git是什么"><a href="#Git是什么" class="headerlink" title="Git是什么"></a>Git是什么</h6><p>Git是目前世界上最先进的分布式版本控制系统。</p><p><a name="_label1"></a></p><p><strong>SVN与Git的最主要的区别</strong></p><p>SVN是集中式版本控制系统，版本库是集中放在中央服务器的，而干活的时候，用的都是自己的电脑，所以首先要从中央服务器哪里得到最新的版本，然后干活，干完后，需要把自己做完的活推送到中央服务器。集中式版本控制系统是必须联网才能工作，如果在局域网还可以，带宽够大，速度够快，如果在互联网下，如果网速慢的话，就纳闷了。</p><p>&nbsp; &nbsp; &nbsp; Git是分布式版本控制系统，那么它就没有中央服务器的，每个人的电脑就是一个完整的版本库，这样，工作的时候就不需要联网了，因为版本都是在自己的电脑上。既然每个人的电脑都有一个完整的版本库，那多个人如何协作呢？比如说自己在电脑上改了文件A，其他人也在电脑上改了文件A，这时，你们两之间只需把各自的修改推送给对方，就可以互相看到对方的修改了。</p><p><a name="_label2"></a></p><p><strong>在windows上如何安装Git</strong></p><p><strong><img alt class="has" src="https://images2015.cnblogs.com/blog/762349/201610/762349-20161026115656421-1232561908.png"></strong></p><p><strong>&nbsp; &nbsp;<a href="http://pan.baidu.com/s/1bpqprob" rel="noopener" data-token="2c07791d39e2368357b31332f0c46557" target="_blank">http://pan.baidu.com/s/1bpqprob</a>&nbsp;（点此可直接下载安装，建议默认安装，不要改动安装路径）</strong></p><p><strong>需要从网上下载一个，然后进行默认安装即可。安装完成后，在开始菜单里面找到 “Git –&gt; Git Bash”,如下：</strong></p><p><strong><img alt class="has" src="https://images2015.cnblogs.com/blog/762349/201610/762349-20161026115755015-870706331.png"></strong></p><p>会弹出一个类似的命令窗口的东西，就说明Git安装成功。如下：</p><p><img alt class="has" src="https://images2015.cnblogs.com/blog/762349/201610/762349-20161026115900843-708583464.png"></p><p>安装完成后，还需要最后一步设置，在命令行输入如下：</p><p>&nbsp;<img alt class="has" src="https://images2015.cnblogs.com/blog/762349/201610/762349-20161026133415953-510886306.png"></p><p>因为Git是分布式版本控制系统，所以需要填写用户名和邮箱作为一个标识。</p><p><strong>&nbsp; &nbsp;注意：</strong>git config&nbsp; –global 参数，有了这个参数，表示你这台机器上所有的Git仓库都会使用这个配置，当然你也可以对某个仓库指定的不同的用户名和邮箱。</p><p>然后输入</p><p>输入 ssh-keygen ，按三次enter，出现</p><p><img alt class="has" src="https://images2015.cnblogs.com/blog/762349/201703/762349-20170302095211016-803148825.png"></p><p>进入磁盘，找到</p><p></p><p><img alt class="has" src="https://images2015.cnblogs.com/blog/762349/201703/762349-20170302095226032-216100673.png"></p><p>右键记事本打开然后复制里面内容</p><p>进入git进入Setting，新增一个，名称随便起，将刚才复制的粘贴到内容即可</p><p><img alt class="has" src="https://images2015.cnblogs.com/blog/762349/201703/762349-20170302095258110-884907314.png"></p><p></p><p></p><p></p><p><a name="_label3"></a></p><p><strong>如何操作</strong></p><p><a name="_label4"></a></p><p>&nbsp; 创建版本库</p><p>&nbsp; &nbsp; &nbsp;什么是版本库？版本库又名仓库，英文名repository,你可以简单的理解一个目录，这个目录里面的所有文件都可以被Git管理起来，每个文件的修改，删除，Git都能跟踪，以便任何时刻都可以追踪历史，或者在将来某个时刻还可以将文件”还原”。</p><p>&nbsp; &nbsp; 所以创建一个版本库也非常简单，如下我是D盘 –&gt; www下 目录下新建一个testgit版本库。</p><p><img alt class="has" src="https://images2015.cnblogs.com/blog/762349/201610/762349-20161026133459750-1915959821.png"></p><p>pwd 命令是用于显示当前的目录。</p><p>&nbsp; &nbsp; &nbsp; 1. 通过命令 git init 把这个目录变成git可以管理的仓库，如下：</p><p><img alt class="has" src="http://ww1.sinaimg.cn/mw690/6941baebgw1eloyr2rpcnj20en025mx9.jpg"></p><p>&nbsp; &nbsp; &nbsp;这时候你当前testgit目录下会多了一个.git的目录，这个目录是Git来跟踪管理版本的，没事千万不要手动乱改这个目录里面的文件，否则，会把git仓库给破坏了。如下：</p><p>&nbsp; &nbsp;&nbsp;<img alt class="has" src="http://ww4.sinaimg.cn/mw690/6941baebgw1eloyr1x3lzj20h004tgm1.jpg"></p><p><a name="_label5"></a></p><p>&nbsp; &nbsp; &nbsp;把文件添加到版本库中</p><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 首先要明确下，所有的版本控制系统，只能跟踪文本文件的改动，比如txt文件，网页，所有程序的代码等，Git也不列外，版本控制系统可以告诉你每次的改动，但是图片，视频这些二进制文件，虽能也能由版本控制系统管理，但没法跟踪文件的变化，只能把二进制文件每次改动串起来，也就是知道图片从1kb变成2kb，但是到底改了啥，版本控制也不知道。</p><p><strong>&nbsp; &nbsp;&nbsp;下面先看下</strong><strong>demo</strong><strong>如下演示：</strong></p><p>&nbsp; &nbsp; &nbsp;我在版本库testgit目录下新建一个记事本文件 readme.txt 内容如下：11111111</p><p>&nbsp; &nbsp; &nbsp;第一步：使用命令 git add readme.txt添加到暂存区里面去。如下：</p><p>&nbsp; &nbsp;&nbsp;<img alt class="has" src="http://ww3.sinaimg.cn/mw690/6941baebgw1eloyr0wkxbj20ch028dfu.jpg"></p><p>&nbsp; &nbsp;如果和上面一样，没有任何提示，说明已经添加成功了。</p><p>&nbsp; &nbsp;第二步：用命令 git commit告诉Git，把文件提交到仓库。</p><p>&nbsp; &nbsp;<img alt class="has" src="http://ww4.sinaimg.cn/mw690/6941baebgw1eloyqz56axj20dp03djrr.jpg"></p><p>&nbsp;&nbsp;现在我们已经提交了一个readme.txt文件了，我们下面可以通过命令git status来查看是否还有文件未提交，如下：</p><p>&nbsp;</p><p><img alt class="has" src="http://ww3.sinaimg.cn/mw690/6941baebgw1eloyqrg067j20d102zwen.jpg"></p><p>&nbsp;说明没有任何文件未提交，但是我现在继续来改下readme.txt内容，比如我在下面添加一行2222222222内容，继续使用git status来查看下结果，如下：</p><p>&nbsp;<img alt class="has" src="http://ww1.sinaimg.cn/mw690/6941baebgw1eloyqq7ts6j20h504r74x.jpg"></p><p>上面的命令告诉我们 readme.txt文件已被修改，但是未被提交的修改。</p><p>接下来我想看下readme.txt文件到底改了什么内容，如何查看呢？可以使用如下命令：</p><p>git diff readme.txt 如下：</p><p>&nbsp;<img alt class="has" src="http://ww1.sinaimg.cn/mw690/6941baebgw1eloyqnrvxgj20ds05maal.jpg"></p><p>如上可以看到，readme.txt文件内容从一行11111111改成 二行 添加了一行22222222内容。</p><p>知道了对readme.txt文件做了什么修改后，我们可以放心的提交到仓库了，提交修改和提交文件是一样的2步(第一步是git add&nbsp; 第二步是：git commit)。</p><p>如下：</p><p>&nbsp;<img alt class="has" src="http://ww3.sinaimg.cn/mw690/6941baebgw1eloyqmcupsj20h609i402.jpg"></p><p><a name="_label6"></a></p><p>版本回退</p><p>&nbsp; &nbsp; &nbsp;如上，我们已经学会了修改文件，现在我继续对readme.txt文件进行修改，再增加一行</p><p>内容为33333333333333.继续执行命令如下：</p><p>&nbsp; &nbsp;<img alt class="has" src="http://ww1.sinaimg.cn/mw690/6941baebgw1eloyql1473j20cp03vdga.jpg"></p><p>现在我已经对readme.txt文件做了三次修改了，那么我现在想查看下历史记录，如何查呢？我们现在可以使用命令 git log 演示如下所示：</p><p>&nbsp;&nbsp;<img alt class="has" src="http://ww2.sinaimg.cn/mw690/6941baebgw1eloyqd9m1dj20gt08ggn8.jpg"></p><p>&nbsp; &nbsp; git log命令显示从最近到最远的显示日志，我们可以看到最近三次提交，最近的一次是,增加内容为333333.上一次是添加内容222222，第一次默认是 111111.如果嫌上面显示的信息太多的话，我们可以使用命令 git log –pretty=oneline 演示如下：</p><p>&nbsp;&nbsp;<img alt class="has" src="http://ww1.sinaimg.cn/mw690/6941baebgw1eloyqc3ziwj20gs02paai.jpg"></p><p>&nbsp; &nbsp; 现在我想使用版本回退操作，我想把当前的版本回退到上一个版本，要使用什么命令呢？可以使用如下2种命令，第一种是：git reset&nbsp; –hard HEAD^ 那么如果要回退到上上个版本只需把HEAD^ 改成 HEAD^^ 以此类推。那如果要回退到前100个版本的话，使用上面的方法肯定不方便，我们可以使用下面的简便命令操作：git reset&nbsp; –hard HEAD~100 即可。未回退之前的readme.txt内容如下：</p><p>&nbsp;</p><p><img alt class="has" src="http://ww3.sinaimg.cn/mw690/6941baebgw1eloyqavyf7j20ch04laap.jpg"></p><p>如果想回退到上一个版本的命令如下操作：</p><p><img alt class="has" src="http://ww4.sinaimg.cn/mw690/6941baebgw1eloyqa5xjfj20ct02xaad.jpg"></p><p>再来查看下 readme.txt内容如下：通过命令cat readme.txt查看</p><p><img alt class="has" src="http://ww3.sinaimg.cn/mw690/6941baebgw1eloyq9fck2j20c402d74c.jpg"></p><p>可以看到，内容已经回退到上一个版本了。我们可以继续使用git log 来查看下历史记录信息，如下：</p><p><img alt class="has" src="http://ww2.sinaimg.cn/mw690/6941baebgw1eloyq6bhrlj20dc063dgk.jpg"></p><p>我们看到 增加333333 内容我们没有看到了，但是现在我想回退到最新的版本，如：有333333的内容要如何恢复呢？我们可以通过版本号回退，使用命令方法如下：</p><p>git reset&nbsp; –hard 版本号 ，但是现在的问题假如我已经关掉过一次命令行或者333内容的版本号我并不知道呢？要如何知道增加3333内容的版本号呢？可以通过如下命令即可获取到版本号：git reflog&nbsp; 演示如下：</p><p><img alt class="has" src="http://ww4.sinaimg.cn/mw690/6941baebgw1eloyq5dtfrj20e603e0t5.jpg"></p><p>通过上面的显示我们可以知道，增加内容3333的版本号是 6fcfc89.我们现在可以命令</p><p>git reset&nbsp; –hard 6fcfc89来恢复了。演示如下：</p><p><img alt class="has" src="http://ww3.sinaimg.cn/mw690/6941baebgw1eloyq4m3oqj20e104974t.jpg"></p><p>可以看到 目前已经是最新的版本了。</p><p><a name="_label7"></a></p><p>&nbsp;理解工作区与暂存区的区别</p><p><strong>工作区：</strong>就是你在电脑上看到的目录，比如目录下testgit里的文件(.git隐藏目录版本库除外)。或者以后需要再新建的目录文件等等都属于工作区范畴。</p><p><strong>&nbsp; &nbsp; &nbsp; 版本库</strong><strong>(Repository)</strong><strong>：</strong>工作区有一个隐藏目录.git,这个不属于工作区，这是版本库。其中版本库里面存了很多东西，其中最重要的就是stage(暂存区)，还有Git为我们自动创建了第一个分支master,以及指向master的一个指针HEAD。</p><p>我们前面说过使用Git提交文件到版本库有两步：</p><p>&nbsp; 第一步：是使用 git add 把文件添加进去，实际上就是把文件添加到暂存区。</p><p>&nbsp; 第二步：使用git commit提交更改，实际上就是把暂存区的所有内容提交到当前分支上。</p><p>我们继续使用demo来演示下：</p><p>我们在readme.txt再添加一行内容为4444444，接着在目录下新建一个文件为test.txt 内容为test，我们先用命令 git status来查看下状态，如下：</p><p><img alt class="has" src="http://ww1.sinaimg.cn/mw690/6941baebgw1eloyq3ykzsj20hv06pwfi.jpg"></p><p>现在我们先使用git add 命令把2个文件都添加到暂存区中，再使用git status来查看下状态，如下：</p><p><img alt class="has" src="http://ww3.sinaimg.cn/mw690/6941baebgw1eloyq2gn7sj20d206p0t8.jpg"></p><p>接着我们可以使用git commit一次性提交到分支上，如下：</p><p><img alt class="has" src="http://ww2.sinaimg.cn/mw690/6941baebgw1eloyq1gpk0j20h704mdgm.jpg"></p><p><a name="_label8"></a></p><p>Git撤销修改和删除文件操作</p><p><a name="_label9"></a></p><p><strong>撤销修改</strong></p><p>&nbsp;&nbsp;&nbsp; 比如我现在在readme.txt文件里面增加一行 内容为555555555555，我们先通过命令查看如下：</p><p><img alt class="has" src="http://ww3.sinaimg.cn/mw690/6941baebgw1eloyq0rzrcj20ax03vaaa.jpg"></p><p>在我未提交之前，我发现添加5555555555555内容有误，所以我得马上恢复以前的版本，现在我可以有如下几种方法可以做修改：</p><p>第一：如果我知道要删掉那些内容的话，直接手动更改去掉那些需要的文件，然后add添加到暂存区，最后commit掉。</p><p>第二：我可以按以前的方法直接恢复到上一个版本。使用 git reset&nbsp; –hard HEAD^</p><p>但是现在我不想使用上面的2种方法，我想直接想使用撤销命令该如何操作呢？首先在做撤销之前，我们可以先用 git status 查看下当前的状态。如下所示：</p><p>&nbsp;</p><p><img alt class="has" src="http://ww2.sinaimg.cn/mw690/6941baebgw1eloyq034qhj20hs04oaam.jpg"></p><p>可以发现，Git会告诉你，git checkout&nbsp; — file 可以丢弃工作区的修改，如下命令：</p><p>git checkout&nbsp; —&nbsp; readme.txt,如下所示：</p><p><img alt class="has" src="http://ww4.sinaimg.cn/mw690/6941baebgw1eloypz44y5j20eh03w0t4.jpg"></p><p>命令 git checkout –readme.txt 意思就是，把readme.txt文件在工作区做的修改全部撤销，这里有2种情况，如下：</p><ol><li>readme.txt自动修改后，还没有放到暂存区，使用 撤销修改就回到和版本库一模一样的状态。</li>    <li>另外一种是readme.txt已经放入暂存区了，接着又作了修改，撤销修改就回到添加暂存区后的状态。</li></ol><p>对于第二种情况，我想我们继续做demo来看下，假如现在我对readme.txt添加一行 内容为6666666666666，我git add 增加到暂存区后，接着添加内容7777777，我想通过撤销命令让其回到暂存区后的状态。如下所示：</p><p>&nbsp;&nbsp;<img alt class="has" src="http://ww1.sinaimg.cn/mw690/6941baebgw1eloypybh8pj20h40deq52.jpg"></p><p><strong>注意：</strong>命令git checkout — readme.txt 中的 — 很重要，如果没有 — 的话，那么命令变成创建分支了。</p><p><a name="_label10"></a></p><p><strong>删除文件</strong></p><p>&nbsp;假如我现在版本库testgit目录添加一个文件b.txt,然后提交。如下：</p><p>&nbsp;&nbsp;<img alt class="has" src="http://ww4.sinaimg.cn/mw690/6941baebgw1eloypxcttej20hr0awmzc.jpg"></p><p>如上：一般情况下，可以直接在文件目录中把文件删了，或者使用如上rm命令：rm b.txt ，如果我想彻底从版本库中删掉了此文件的话，可以再执行commit命令 提交掉，现在目录是这样的，</p><p>&nbsp;<img alt class="has" src="http://ww4.sinaimg.cn/mw690/6941baebgw1eloypvtweyj20jj05cwf4.jpg"></p><p>只要没有commit之前，如果我想在版本库中恢复此文件如何操作呢？</p><p>可以使用如下命令 git checkout&nbsp; — b.txt，如下所示：</p><p><img alt class="has" src="http://ww4.sinaimg.cn/mw690/6941baebgw1eloyput1l8j20fh06s0tr.jpg"></p><p>再来看看我们testgit目录，添加了3个文件了。如下所示：</p><p><a name="_label11"></a></p><p>&nbsp;远程仓库</p><p>&nbsp;在了解之前，先注册github账号，由于你的本地Git仓库和github仓库之间的传输是通过SSH加密的，所以需要一点设置：</p><p>&nbsp; &nbsp; &nbsp;第一步：创建SSH Key。在用户主目录下，看看有没有.ssh目录，如果有，再看看这个目录下有没有id_rsa和id_rsa.pub这两个文件，如果有的话，直接跳过此如下命令，如果没有的话，打开命令行，输入如下命令：</p><p>ssh-keygen&nbsp; -t rsa –C “youremail@example.com”, 由于我本地此前运行过一次，所以本地有，如下所示：</p><p>&nbsp;<img alt class="has" src="http://ww2.sinaimg.cn/mw690/6941baebgw1eloypq7esij20kx04pt9c.jpg"></p><p>id_rsa是私钥，不能泄露出去，id_rsa.pub是公钥，可以放心地告诉任何人。</p><p>第二步：登录github,打开” settings”中的SSH Keys页面，然后点击“Add SSH Key”,填上任意title，在Key文本框里黏贴id_rsa.pub文件的内容。</p><p><img alt class="has" src="http://ww1.sinaimg.cn/mw690/6941baebgw1eloyppfdu3j20vh0nwdl0.jpg"></p><p>点击 Add Key，你就应该可以看到已经添加的key。</p><p><img alt class="has" src="http://ww1.sinaimg.cn/mw690/6941baebgw1eloypnrj0cj20l60ad75p.jpg"></p><ol><li>如何添加远程库？</li></ol><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;现在的情景是：我们已经在本地创建了一个Git仓库后，又想在github创建一个Git仓库，并且希望这两个仓库进行远程同步，这样github的仓库可以作为备份，又可以其他人通过该仓库来协作。</p><p>&nbsp;&nbsp; 首先，登录github上，然后在右上角找到“create a new repo”创建一个新的仓库。如下：</p><p><img alt class="has" src="http://ww2.sinaimg.cn/mw690/6941baebgw1eloypmocbsj20u40gttbc.jpg"></p><p>在Repository name填入<code>testgit</code>，其他保持默认设置，点击“Create repository”按钮，就成功地创建了一个新的Git仓库：</p><p><img alt class="has" src="http://ww2.sinaimg.cn/mw690/6941baebgw1eloypm6o2gj20si0idwh4.jpg"></p><p>&nbsp; &nbsp; 目前，在GitHub上的这个<code>testgit</code>仓库还是空的，GitHub告诉我们，可以从这个仓库克隆出新的仓库，也可以把一个已有的本地仓库与之关联，然后，把本地仓库的内容推送到GitHub仓库。</p><p>现在，我们根据GitHub的提示，在本地的<code>testgit</code>仓库下运行命令：</p><p>git remote add origin https://github.com/tugenhua0707/testgit.git</p><p>所有的如下：</p><p>&nbsp;&nbsp;<img alt class="has" src="http://ww4.sinaimg.cn/mw690/6941baebgw1eloypk8b34j20hk070764.jpg"></p><p>把本地库的内容推送到远程，使用 git push命令，实际上是把当前分支master推送到远程。</p><p>由于远程库是空的，我们第一次推送master分支时，加上了 –u参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令。推送成功后，可以立刻在github页面中看到远程库的内容已经和本地一模一样了，上面的要输入github的用户名和密码如下所示：</p><p><img alt class="has" src="http://ww2.sinaimg.cn/mw690/6941baebgw1eloypjhn5ij20t40i7mzp.jpg"></p><p>从现在起，只要本地作了提交，就可以通过如下命令：</p><p>git push origin master</p><p>把本地master分支的最新修改推送到github上了，现在你就拥有了真正的分布式版本库了。</p><p>2. 如何从远程库克隆？</p><p>上面我们了解了先有本地库，后有远程库时候，如何关联远程库。</p><p>现在我们想，假如远程库有新的内容了，我想克隆到本地来 如何克隆呢？</p><p>首先，登录github，创建一个新的仓库，名字叫testgit2.如下：</p><p><img alt class="has" src="http://ww4.sinaimg.cn/mw690/6941baebgw1eloyphv15sj20t10gs775.jpg"></p><p>如下，我们看到：</p><p><img alt class="has" src="http://ww2.sinaimg.cn/mw690/6941baebgw1eloypexzvuj20ss0dgabs.jpg"></p><p>现在，远程库已经准备好了，下一步是使用命令git clone克隆一个本地库了。如下所示：</p><p><img alt class="has" src="http://ww4.sinaimg.cn/mw690/6941baebgw1eloypec5t0j20hp03jwf6.jpg"></p><p>接着在我本地目录下 生成testgit2目录了，如下所示：</p><p><img alt class="has" src="http://ww4.sinaimg.cn/mw690/6941baebgw1eloypdbpwnj20jt05hmxr.jpg"></p><p>六：创建与合并分支。</p><p>在 &nbsp;版本回填退里，你已经知道，每次提交，Git都把它们串成一条时间线，这条时间线就是一个分支。截止到目前，只有一条时间线，在Git里，这个分支叫主分支，即master分支。HEAD严格来说不是指向提交，而是指向master，master才是指向提交的，所以，HEAD指向的就是当前分支。</p><p>首先，我们来创建dev分支，然后切换到dev分支上。如下操作：</p><p><img alt class="has" src="http://ww4.sinaimg.cn/mw690/6941baebgw1eloypab36sj20bc04nweu.jpg"></p><p>git checkout 命令加上 –b参数表示创建并切换，相当于如下2条命令</p><p>git branch dev</p><p>git checkout dev</p><p>git branch查看分支，会列出所有的分支，当前分支前面会添加一个星号。然后我们在dev分支上继续做demo，比如我们现在在readme.txt再增加一行 7777777777777</p><p>首先我们先来查看下readme.txt内容，接着添加内容77777777，如下：</p><p><img alt class="has" src="http://ww3.sinaimg.cn/mw690/6941baebgw1eloyp9es90j20at0awjsq.jpg"></p><p>现在dev分支工作已完成，现在我们切换到主分支master上，继续查看readme.txt内容如下：</p><p><img alt class="has" src="http://ww3.sinaimg.cn/mw690/6941baebgw1eloyp8mng3j20hm05qaav.jpg"></p><p>现在我们可以把dev分支上的内容合并到分支master上了，可以在master分支上，使用如下命令 git merge dev 如下所示：</p><p><img alt class="has" src="http://ww1.sinaimg.cn/mw690/6941baebgw1eloyp83uksj20es073gmi.jpg"></p><p>git merge命令用于合并指定分支到当前分支上，合并后，再查看readme.txt内容，可以看到，和dev分支最新提交的是完全一样的。</p><p>注意到上面的<em>Fast-forward</em>信息，Git告诉我们，这次合并是“快进模式”，也就是直接把master指向dev的当前提交，所以合并速度非常快。</p><p>合并完成后，我们可以接着删除dev分支了，操作如下：</p><p>&nbsp;</p><p>总结创建与合并分支命令如下：</p><p>&nbsp;&nbsp; 查看分支：git branch</p><p>&nbsp;&nbsp; 创建分支：git branch name</p><p>&nbsp;&nbsp; 切换分支：git checkout name</p><p>创建+切换分支：git checkout –b name</p><p>合并某分支到当前分支：git merge name</p><p>删除分支：git branch –d name</p><p><a name="_label12"></a></p><p>如何解决冲突</p><p>下面我们还是一步一步来，先新建一个新分支，比如名字叫fenzhi1，在readme.txt添加一行内容8888888，然后提交，如下所示：</p><p><img alt class="has" src="http://ww2.sinaimg.cn/mw690/6941baebgw1eloyp4jq8yj20ft0cu40a.jpg"></p><p>同样，我们现在切换到master分支上来，也在最后一行添加内容，内容为99999999，如下所示：</p><p><img alt class="has" src="http://ww1.sinaimg.cn/mw690/6941baebgw1eloyp3w0l1j20g80dwmz7.jpg"></p><p>现在我们需要在master分支上来合并fenzhi1，如下操作：</p><p><img alt class="has" src="http://ww1.sinaimg.cn/mw690/6941baebgw1eloyp1wo2ij20hm0gddi9.jpg"></p><p>Git用&lt;&lt;&lt;&lt;&lt;&lt;&lt;，=======，&gt;&gt;&gt;&gt;&gt;&gt;&gt;标记出不同分支的内容，其中&lt;&lt;&lt;HEAD是指主分支修改的内容，&gt;&gt;&gt;&gt;&gt;fenzhi1 是指fenzhi1上修改的内容，我们可以修改下如下后保存：</p><p><img alt class="has" src="http://ww2.sinaimg.cn/mw690/6941baebgw1eloyp11x4zj20g107e3zd.jpg"></p><p>如果我想查看分支合并的情况的话，需要使用命令 git log.命令行演示如下：</p><p><img alt class="has" src="http://ww2.sinaimg.cn/mw690/6941baebgw1eloyp0aj6uj20dt0o5gph.jpg"></p><p><a name="_label13"></a></p><p>分支管理策略</p><p>通常合并分支时，git一般使用”Fast forward”模式，在这种模式下，删除分支后，会丢掉分支信息，现在我们来使用带参数 –no-ff来禁用”Fast forward”模式。首先我们来做demo演示下：</p><ol><li>创建一个dev分支。</li>    <li>修改readme.txt内容。</li>    <li>添加到暂存区。</li>    <li>切换回主分支(master)。</li>    <li>合并dev分支，使用命令 git merge –no-ff&nbsp; -m “注释” dev</li>    <li>查看历史记录</li></ol><p>截图如下：</p><p>&nbsp;<img alt class="has" src="http://ww2.sinaimg.cn/mw690/6941baebgw1eloyoz5m31j20gr0lon0y.jpg"></p><p><strong>分支策略：</strong>首先master主分支应该是非常稳定的，也就是用来发布新版本，一般情况下不允许在上面干活，干活一般情况下在新建的dev分支上干活，干完后，比如上要发布，或者说dev分支代码稳定后可以合并到主分支master上来。</p><p>七：bug分支：</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在开发中，会经常碰到bug问题，那么有了bug就需要修复，在Git中，分支是很强大的，每个bug都可以通过一个临时分支来修复，修复完成后，合并分支，然后将临时的分支删除掉。</p><p>比如我在开发中接到一个404 bug时候，我们可以创建一个404分支来修复它，但是，当前的dev分支上的工作还没有提交。比如如下：</p><p>&nbsp;<img alt class="has" src="http://ww2.sinaimg.cn/mw690/6941baebgw1eloyoy0x5yj20he04m74v.jpg"></p><p>&nbsp; &nbsp;并不是我不想提交，而是工作进行到一半时候，我们还无法提交，比如我这个分支bug要2天完成，但是我issue-404 bug需要5个小时内完成。怎么办呢？还好，Git还提供了一个stash功能，可以把当前工作现场 ”隐藏起来”，等以后恢复现场后继续工作。如下：</p><p>&nbsp;&nbsp;<img alt class="has" src="http://ww4.sinaimg.cn/mw690/6941baebgw1eloyoxn4t8j20i3058dgo.jpg"></p><p>&nbsp; &nbsp;所以现在我可以通过创建issue-404分支来修复bug了。</p><p>首先我们要确定在那个分支上修复bug，比如我现在是在主分支master上来修复的，现在我要在master分支上创建一个临时分支，演示如下：</p><p>&nbsp;<img alt class="has" src="http://ww1.sinaimg.cn/mw690/6941baebgw1eloyowmdooj20gp0etq55.jpg"></p><p>修复完成后，切换到master分支上，并完成合并，最后删除issue-404分支。演示如下：</p><p>&nbsp;</p><p>现在，我们回到dev分支上干活了。</p><p><img alt class="has" src="http://ww3.sinaimg.cn/mw690/6941baebgw1eloyou5898j20bq03s0t6.jpg"></p><p>工作区是干净的，那么我们工作现场去哪里呢？我们可以使用命令 git stash list来查看下。如下：</p><p><img alt class="has" src="http://ww2.sinaimg.cn/mw690/6941baebgw1eloyot6ny2j20c202lmxg.jpg"></p><p>工作现场还在，Git把stash内容存在某个地方了，但是需要恢复一下，可以使用如下2个方法：</p><ol><li>git stash apply恢复，恢复后，stash内容并不删除，你需要使用命令git stash drop来删除。</li>    <li>另一种方式是使用git stash pop,恢复的同时把stash内容也删除了。</li></ol><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 演示如下</p><p>&nbsp;<img alt class="has" src="https://images2015.cnblogs.com/blog/762349/201610/762349-20161026134059296-2019917854.png"></p><p><a name="_label14"></a></p><p>多人协作</p><p>当你从远程库克隆时候，实际上Git自动把本地的master分支和远程的master分支对应起来了，并且远程库的默认名称是origin。</p><ol><li>要查看远程库的信息 使用 git remote</li>    <li>要查看远程库的详细信息 使用 git remote –v</li></ol><p>如下演示：</p><p>&nbsp;<img alt class="has" src="http://ww2.sinaimg.cn/mw690/6941baebgw1eloyor8ayjj20h704pt9e.jpg"></p><p><strong>一：推送分支：</strong></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 推送分支就是把该分支上所有本地提交到远程库中，推送时，要指定本地分支，这样，Git就会把该分支推送到远程库对应的远程分支上：</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 使用命令 git push origin master</p><p>比如我现在的github上的readme.txt代码如下：</p><p><img alt class="has" src="http://ww1.sinaimg.cn/mw690/6941baebgw1eloyoolky9j20n00crt9x.jpg"></p><p>本地的readme.txt代码如下：</p><p>&nbsp;<img alt class="has" src="http://ww4.sinaimg.cn/mw690/6941baebgw1eloyoljbdoj20bp05p74u.jpg"></p><p>现在我想把本地更新的readme.txt代码推送到远程库中，使用命令如下：</p><p><img alt class="has" src="http://ww2.sinaimg.cn/mw690/6941baebgw1eloyoklccxj20f105nmy8.jpg"></p><p>我们可以看到如上，推送成功，我们可以继续来截图github上的readme.txt内容 如下：</p><p><img alt class="has" src="http://ww4.sinaimg.cn/mw690/6941baebgw1eloyojp2l7j20mi0dgdh4.jpg"></p><p>可以看到 推送成功了，如果我们现在要推送到其他分支，比如dev分支上，我们还是那个命令 git push origin dev</p><p>那么一般情况下，那些分支要推送呢？</p><ol><li>master分支是主分支，因此要时刻与远程同步。</li>    <li>一些修复bug分支不需要推送到远程去，可以先合并到主分支上，然后把主分支master推送到远程去。</li>    <li>    <p><a name="_label15"></a></p><p>抓取分支</p>    </li>    <li>    <p>多人协作时，大家都会往master分支上推送各自的修改。现在我们可以模拟另外一个同事，可以在另一台电脑上（注意要把SSH key添加到github上）或者同一台电脑上另外一个目录克隆，新建一个目录名字叫testgit2</p><p>但是我首先要把dev分支也要推送到远程去，如下</p><p><img alt class="has" src="http://ww4.sinaimg.cn/mw690/6941baebgw1eloyoilae8j20dz047jrw.jpg"></p><p>接着进入testgit2目录，进行克隆远程的库到本地来，如下：</p><p>&nbsp;<img alt class="has" src="http://ww4.sinaimg.cn/mw690/6941baebgw1eloyofwtkzj20e404qdgn.jpg"></p><p>现在目录下生成有如下所示：</p><p><img alt class="has" src="http://ww4.sinaimg.cn/mw690/6941baebgw1eloyoerppxj20jy07475a.jpg"></p><p>现在我们的小伙伴要在dev分支上做开发，就必须把远程的origin的dev分支到本地来，于是可以使用命令创建本地dev分支：git checkout&nbsp; –b dev origin/dev</p><p>现在小伙伴们就可以在dev分支上做开发了，开发完成后把dev分支推送到远程库时。</p><p>如下：</p><p><img alt class="has" src="http://ww1.sinaimg.cn/mw690/6941baebgw1eloyodj3j4j20gq0katc9.jpg"></p><p>小伙伴们已经向origin/dev分支上推送了提交，而我在我的目录文件下也对同样的文件同个地方作了修改，也试图推送到远程库时，如下：</p><p><img alt class="has" src="http://ww4.sinaimg.cn/mw690/6941baebgw1eloyocm8nlj20hz0l3jvp.jpg"></p><p>由上面可知：推送失败，因为我的小伙伴最新提交的和我试图推送的有冲突，解决的办法也很简单，上面已经提示我们，先用git pull把最新的提交从origin/dev抓下来，然后在本地合并，解决冲突，再推送。</p><p><img alt class="has" src="http://ww2.sinaimg.cn/mw690/6941baebgw1eloyoblpvij20gi07ugmx.jpg"></p><p><em>git pull</em>也失败了，原因是没有指定本地dev分支与远程origin/dev分支的链接，根据提示，设置dev和origin/dev的链接：如下：</p><p><img alt class="has" src="http://ww3.sinaimg.cn/mw690/6941baebgw1eloyoab9gfj20hy05j0tu.jpg"></p><p>这回<em>git pull</em>成功，但是合并有冲突，需要手动解决，解决的方法和分支管理中的 解决冲突完全一样。解决后，提交，再push：</p><p>我们可以先来看看readme.txt内容了。</p><p><img alt class="has" src="http://ww4.sinaimg.cn/mw690/6941baebgw1eloyo7l3o6j20ef07p74y.jpg"></p><p>现在手动已经解决完了，我接在需要再提交，再push到远程库里面去。如下所示：<br><img alt class="has" src="http://ww3.sinaimg.cn/mw690/6941baebgw1eloyo5em1aj20gt0dcwgv.jpg"></p><p>因此：多人协作工作模式一般是这样的：</p><ol><li>首先，可以试图用git push origin branch-name推送自己的修改.</li>        <li>如果推送失败，则因为远程分支比你的本地更新早，需要先用git pull试图合并。</li>        <li>如果合并有冲突，则需要解决冲突，并在本地提交。再用git push origin branch-name推送。</li><p><strong>Git</strong><strong>基本常用命令如下</strong></p><p>&nbsp; &nbsp;mkdir：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; XX (创建一个空目录 XX指目录名)</p><p>&nbsp;&nbsp; pwd：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 显示当前目录的路径。</p><p>&nbsp;&nbsp; git init&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 把当前的目录变成可以管理的git仓库，生成隐藏.git文件。</p><p>&nbsp;&nbsp; git add XX&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 把xx文件添加到暂存区去。</p><p>&nbsp;&nbsp; git commit –m “XX”&nbsp; 提交文件 –m 后面的是注释。</p><p>&nbsp;&nbsp; git status&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 查看仓库状态</p><p>&nbsp;&nbsp; git diff&nbsp; XX&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 查看XX文件修改了那些内容</p><p>&nbsp;&nbsp; git log&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 查看历史记录</p><p>&nbsp;&nbsp; git reset&nbsp; –hard HEAD^ 或者 git reset&nbsp; –hard HEAD~ 回退到上一个版本</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (如果想回退到100个版本，使用git reset –hard HEAD~100 )</p><p>&nbsp;&nbsp; cat XX&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 查看XX文件内容</p><p>&nbsp;&nbsp; git reflog&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 查看历史记录的版本号id</p><p>&nbsp;&nbsp; git checkout — XX&nbsp; 把XX文件在工作区的修改全部撤销。</p><p>&nbsp;&nbsp; git rm XX&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 删除XX文件</p><p>&nbsp;&nbsp; git remote add origin&nbsp;<a href="https://github.com/ev-power/XiaoYong" rel="noopener" data-token="0953ea3b88640558f4d7fa1d99992485" target="_blank">https://github.com/AYJCSGM/-.git</a>&nbsp;关联一个远程库</p><p>&nbsp;&nbsp; git push –u(第一次要用-u 以后不需要) origin master 把当前master分支推送到远程库</p><p>&nbsp; &nbsp;git clone&nbsp;<a href="https://github.com/ev-power/XiaoYong" rel="noopener" data-token="0953ea3b88640558f4d7fa1d99992485" target="_blank">https://github.com/AYJCSGM/-.git</a>&nbsp; 从远程库中克隆</p><p>&nbsp; &nbsp;git checkout –b dev&nbsp; 创建dev分支 并切换到dev分支上</p><p>&nbsp; &nbsp;git branch&nbsp; 查看当前所有的分支</p><p>&nbsp; &nbsp;git checkout master 切换回master分支</p><p>&nbsp; &nbsp;git merge dev&nbsp; &nbsp;&nbsp;在当前的分支上合并dev分支</p><p>&nbsp; &nbsp;git branch –d dev 删除dev分支</p><p>&nbsp; &nbsp;git branch name&nbsp; 创建分支</p><p>&nbsp; &nbsp;git stash 把当前的工作隐藏起来 等以后恢复现场后继续工作</p><p>&nbsp; &nbsp;git stash list 查看所有被隐藏的文件列表</p><p>&nbsp; &nbsp;git stash apply 恢复被隐藏的文件，但是内容不删除</p><p>&nbsp; &nbsp;git stash drop 删除文件</p><p>&nbsp; &nbsp;git stash pop 恢复文件的同时 也删除文件</p><p>&nbsp; &nbsp;git remote 查看远程库的信息</p><p>&nbsp; &nbsp;git remote –v 查看远程库的详细信息</p><p>&nbsp; &nbsp;git push origin master&nbsp; Git会把master分支推送到远程库对应的远程分支上 &nbsp; &nbsp;&nbsp;</p><blockquote><p>参考<a href="http://www.cnblogs.com/tugenhua0707/p/4050072.html" target="_blank" rel="noopener">http://www.cnblogs.com/tugenhua0707/p/4050072.html</a></p></blockquote></ol></li></ol></ul></div></div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://picsum.photos/800/209&quot; alt&gt;&lt;/p&gt;
&lt;div id=&quot;article_content&quot; class=&quot;article_content clearfix&quot;&gt;
                                    &lt;link rel=&quot;stylesheet&quot; href=&quot;https://blog.csdn.net/weixin_43664418/article/details/102627420&quot;&gt;
                                        &lt;link rel=&quot;stylesheet&quot; href=&quot;https://blog.csdn.net/weixin_43664418/article/details/102627420&quot;&gt;
                &lt;div class=&quot;htmledit_views&quot; id=&quot;content_views&quot;&gt;
                                            &lt;h1&gt;&lt;a href=&quot;https://blog.csdn.net/weixin_43664418/article/details/102627420&quot; rel=&quot;noopener&quot; id=&quot;cb_post_title_url&quot; data-token=&quot;0deb5f3a1d47256108b5292807fb43e9&quot; target=&quot;_blank&quot;&gt;Git教程&lt;/a&gt;&lt;/h1&gt;
    
    </summary>
    
    
    
      <category term="Git" scheme="ayjcsgm.github.io/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>面试总结</title>
    <link href="ayjcsgm.github.io/2019/10/18/%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/"/>
    <id>ayjcsgm.github.io/2019/10/18/面试总结/</id>
    <published>2019-10-18T07:35:59.000Z</published>
    <updated>2019-10-18T08:22:26.885Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://picsum.photos/800/208" alt><br>java和其他语言的区别和优势在哪？<br>（内存动态分配和垃圾收集技术）<br>C语言：贴近内存，运行极快，效率极高。但是他要进行指针和内存管理，指针可以直接操作内存，但是却没有做数组越界等检查，容易出错。而且自己申请的空间需要自己去释放。并且这些问题编译期间发现不了，运行时才会暴露。<br>C++：添加了面向对象的功能，兼容了c语言，加入了静态类型的检测，但是太复杂。<br>Java：摆脱了硬件平台的束缚，实现了垮平台。</p><a id="more"></a><p> 提供了一个相对安全的内存管理和访问机制，避免了绝大部分的内存泄漏和指针越界问题。<br> 实现了热点代码的检测和运行时编译及优化。<br> 实现内存动态分配和垃圾收集技术。<br> 内存自动分配和销毁，消除了c中的指针，垃圾自动回收和垮平台。<br>Java是解释型还是编译型语言。（Java属于解释型语言）<br>•    编译型语言：把做好的源程序全部编译成二进制代码的可运行程序。然后，可直接运行这个程序。<br>•    解释型语言：把做好的源程序翻译一句，然后执行一句，直至结束！<br>Jdk和jre的区别<br>Java程序设计语言，java虚拟机，java API类库统称为JDK，jdk是用于支持java程序开发的最小环境<br>Java SE API子集和java虚拟机这两部分统称为JRE，JRE是支持程序运行的标准环境。<br>Thread和runnable的区别,start方法和run方法的区别<br>Thread类实现了Runnable接口，都需要重写里面Run方法<br>实现Runnable接口比继承Thread类所具有的的优势：适合多个相同的程序代码的线程去处理同一个资源；在这就是可以避免Java中的单继承的限制，增加程序的健壮性，代码可以被多个线程共享，代码和数据独立。线程池只能放入实现Runnable 类线程，不能直接放入继承Thread的类<br>通过继承Thread类来创建的线程不共享实例变量，通过实现Runnable接口来创建的线程对象共享线程类的实例变量<br>调用start（）后，线程会被放到等待队列，等待CPU调度，并不一定要马上开始执行，只是将这个线程置于就绪状态。然后通过JVM，线程Thread会调用run（）方法，执行本线程的线程体，所以如果直接调用run，就和一个普通的方法没什么区别，是不会创建新的线程的</p><p>Object自带的两个方法，一个是equals和hashCode，在什么情况下需要重写equals和HashCode方法。<br> Java中的超类Object类中定义的equals()方法是用来比较两个引用所指向的对象的内存地址是否一致，String中重写了equals()方法和hashcode。<br>HashSet存放元素时，根据元素的hashCode值快速找到要存储的位置，如果这个位置有元素，两个对象通过equals()比较，如果返回值为true,则不放入；如果返回值为false,则这个时候会以链表的形式在同一个位置上存放两个元素，这会使得HashSet的性能降低，因为不能快速定位了。还有一种情况就是两个对象的hashCode()返回值不同，但是equals()返回true,这个时候HashSet会把这两个对象都存进去，这就和Set集合不重复的规则相悖了;所以，我们重写了equals()方法时，要按照b,c规则重写hashCode()方法！<br>equals 相等，hashCode 一定要相等。<br>重写了 hashCode 也要重写 equals。<br>hashCode 需要保持一致性，状态改变返回的哈希值仍然要一致。<br>equals 的对称、反射、传递等特性。<br>什么是线程安全，为什么会出现线程安全，如何解决?<br>当多个线程访问一个对象时，如果不用考虑这些线程在运行时环境下的调度和交替执行，也不需要进行额外的同步，或者在调用方进行任何其他的协调操作，调用这个对象的行为都可以获得正确的结果，那这个对象就是线程安全的。<br>线程安全主要讲的基本上就是线程之间对共享的资源（比如变量、文件、数据库之类的）的操作不互相妨碍。有时候多个线程可能同时（只是一个概念，不是绝对的同时）操作一个变量，这样这个变量的值就不能确定了。<br>解决线程安全：<br>不在线程之间共享该状态变量（实例或者静态域的数据）<br>将状态变量修改为不可变的变量<br>在访问状态变量时使用同步<br>什么是死锁，为什么会产生死锁，解决方法是什么？<br>死锁是一种特定的程序状态，在实体之间，由于循环依赖导致彼此一直处于等待之中，没有任何个体可以继续前进。死锁不仅仅是在线程之间会发生，存在资源独占的进程之间同样也可能出现死锁。两个或多个线程之间，由于互相持有对方需要的锁，而永久处于阻塞的状态。<br>定位死锁最常见的方式就是利用jstack等工具获取线程栈，然后定位互相之间的依赖关系，进而找到死锁。如果是比较明显的死锁，往往jstack等就能直接定位，类似 JConsole 甚至可以在图形界面进行有限的死锁检测<br>解决：避免使用多个锁，并且只有需要时才持有锁<br>Java OOM异常，java内存溢出异常有哪些<br>不断的创建对象，达到最大堆的容量限制后就会产生内存溢出异常<br>线程请求的栈深度大于虚拟机所允许的最大深度，抛出stackoverflowError（递归调用）<br>虚拟机在扩展栈时无法申请到足够的内存空间，则抛出OutOfMemoryError异常<br>方法区溢出<br>不健壮代码的特征及解决办法<br>尽早释放无用对象的引用。好的办法是使用临时变量的时候，让引用变量在退出活动域后，自动设置为null，暗示垃圾收集器来收集该对象，防止发生内存泄露。<br>对于仍然有指针指向的实例，jvm就不会回收该资源,因为垃圾回收会将值为null的对象作为垃圾，提高GC回收机制效率；<br>我们的程序里不可避免大量使用字符串处理，避免使用String，应大量使用StringBuffer，每一个String对象都得独立占用内存一块区域；<br>String str = “aaa”;<br>String str2 = “bbb”;<br>String str3 = str + str2;//假如执行此次之后str,str2以后再不被调用,那它就会被放在内存中等待Java的gc去回收,程序内过多的出现这样的情况就会报上面的那个错误,建议在使用字符串时能使用StringBuffer就不要用String,这样可以省不少开销；<br>尽量少用静态变量，因为静态变量是全局的，GC不会回收的；<br>避免集中创建对象尤其是大对象，JVM会突然需要大量内存，这时必然会触发GC优化系统内存环境；例如显示的声明数组空间，而且申请数量还极大。导致该数组分配了很多内存空间，而且该数组不能及时释放<br>不要在经常调用的方法中创建对象，尤其是忌讳在循环中创建对象。可以适当的使用hashtable，vector<br>创建一组对象容器，然后从容器中去取那些对象，而不用每次new之后又丢弃<br>一般都是发生在开启大型文件或跟数据库一次拿了太多的数据，造成 Out Of Memory Error 的状况，这时就大概要计算一下数据量的最大值是多少，并且设定所需最小及最大的内存空间值。<br>组合和聚合的区别，继承的区别<br>组合：体现整体与部分间的关系，但此时整体与部分是不可分的，整体的生命周期结束也就意味着部分的生命周期结束；<br>聚合：整体与部分之间是可分离的，他们可以具有各自的生命周期，部分可以属于多个整体对象，也可以为多个整体对象共享；<br>设计模式中要“少用继承，多用组合”，<br>组合优点：</p><ul><li>不破坏封装，整体类与局部类之间松耦合，彼此相对独立</li><li>具有较好的可扩展性</li><li>支持动态组合。在运行时，整体对象可以选择不同类型的局部对象</li><li>整体类可以对局部类进行包装，封装局部类的接口，提供新的接口<br>缺点：</li><li>整体类不能自动获得和局部类同样的接口</li><li>创建整体类的对象时，需要创建所有局部类的对象<br>继承优点：</li><li>子类能自动继承父类的接口</li><li>创建子类的对象时，无须创建父类的对象<br>缺点：</li><li>破坏封装，子类与父类之间紧密耦合，子类依赖于父类的实现，子类缺乏独立性</li><li>支持扩展，但是往往以增加系统结构的复杂度为代价</li><li>不支持动态继承。在运行时，子类无法选择不同的父类</li><li>子类不能改变父类的接口<br>如何进行拷贝（clone），深拷贝和浅拷贝的区别<br>实现cloneable接口，重写clone方法，调用super.clone（）方法，还可以用序列化实现深拷贝，实现Serializable接口，进行序列化和反序列化。<br>浅拷贝，只是对指针的拷贝，拷贝后两个指针指向同一个内存空间，深拷贝不但对指针进行拷贝，而且对指针指向的内容进行拷贝，经深拷贝后的指针是指向两个不同地址的指针<br> 浅复制仅仅是指向被复制的内存地址，如果原地址中对象被改变了，那么浅复制出来的对象也会相应改变。<br> 深复制—-在计算机中开辟了一块新的内存地址用于存放复制的对象。</li></ul><p>filter和listener的区别。<br>Filter过滤器：拦截资源是按照 filter-mapping 配置节出现的顺序来依次调用 doFilter() 方法的<br>filter使用户可以改变一个request并且修改一个response，filter不是一个Servlet，不能生产一个response，能够在一个request到达Servlet之前预处理request，也可以在离开Servlet时处理response。Filter其实是一个“Servlet chaining”（Servlet链）<br>一个filter包括：<br>1)    在Servlet被调用之前截获，并可以检查Servlet request<br>2)    根据需要修改request头和request数据<br>3)    根据需要修改response头和response数据<br>4)    在Servlet被调用之后截获<br>利用filter进行权限的管理</p><p>Listener监听器：主要完成对java内置对象的状态（创建和销毁）及属性的变化<br>监听ServletContext、HttpSession、ServletRequest<br>1)    对application（application 是 ServletContext 的实例）内置对象，session和request进行监听<br>2)    作用：通过监听用户session，监听用户上线与退出，显示在线用户<br>4、八大基本数据类型有哪些，对应的大小</p><p>5、Jdk7和jdk8的区别<br>JDK7<br>1)    Jdk7中switch操作可以支持String类型（实际上对int类型值进行匹配，通过对case后面的String对象调用hashCode（）方法，得到一个int类型的hash值，然后用这个hash值来唯一标识这个case。当进行匹配时，首先调用这个字符串的hashCode方法，获取一个hash值，用这个hash值来匹配所有的case，若没有匹配成功，则不存在，否则接着调用会接着调用字符串的equals方法进行匹配，所以String变量不能为空）</p><p>2)    可以在catch代码块中捕获多个异常类型</p><p>try {<br>    //可能会抛出Exception1和Exception2异常的代码<br>}catch(Exception1 | Exception2) {<br>    // 处理异常的代码<br>}</p><p>3） 对数值字面量进行了改进（增加了二进制字面量的表示：整数类型可以用二进制来表示；<br>在数字中可以添加分隔符，只能被用于数字中间，编译时这些下划线会被编译器去掉，例如123_12，）<br>   4） 使用泛型的时候增加了类型推断机制<br>        Map&lt;String, String&gt; map = new HashMap&lt;&gt;();<br>   5)  增加了try-with-resource语句：可以保证在该语句执行完之后关闭每个资源<br>   6） 增加了fork/join框架用来增强对处理多核并行计算的支持，他的应用场景为：如果一个应用能被分解成多个子任务，并且组合多个子任务的结果就能获得最终答案。<br>       Fork就是把一个大任务切割成若干个子任务并行执行，join就是合并这些子任务的执行结果，最后得到这个大任务的结果。<br>JDK8<br>1)    增加了lambda表达式的支持。Lambda表达式是一个匿名函数（没有函数名的函数），lambda表达式允许把函数作为一个方法的参数，lambda表示式是通过函数式接口（只有一个方法的普通接口，用@FunctionalInterface）实现的</p><p>2)    接口增加了方法的默认实现和静态方法，jdk1.8通过使用关键字default可以给接口中的方法添加默认方法，此外，接口中还可以定义静态方法。为了接口升级，在原有的设计中，如果想要给接口中添加一个新的方法，会导致所有实现这个接口的类都需要被修改，可以使用默认方法或者静态方法。<br>public interface Inter {<br>    void f();</p><pre><code>default void g() {    System.out.println(&quot;default&quot;);}    static void h() {    System.out.println(&quot;static&quot;);}}</code></pre><p>3)    方法引用，可以直接引用java类或者对象的方法。<br>Arrays.sort(people, Comparator.comparing( Person :: getAge ));<br>4)    引入重复注解机制，相同的注解在同一个地方可以声明多次<br>5)    添加stream类—引入函数式编程</p><p>1、    集合<br>hashMap为什么线程不安全，不安全会发生什么现象，为什么<br>HashMap 在并发环境可能出现无限循环占用 CPU（扩容）、size 不准确等诡异的问题。</p><p>HashMap、TreeMap和HashTable的区别<br>HashMap 是应用更加广泛的哈希表实现，行为上大致上与 HashTable 一致，主要区别在于 HashMap 不是同步的，支持 null 键和值等。通常情况下，HashMap 进行 put 或者 get 操作，可以达到常数时间的性能O（1）, HashMap 在并发环境可能出现无限循环占用 CPU（扩容）、size 不准确等诡异的问题。<br>TreeMap 则是基于红黑树的一种提供顺序访问的 Map，和 HashMap 不同，它的 get、put、remove 之类操作都是 O（log(n)）的时间复杂度，具体顺序可以由指定的 Comparator 来决定，或者根据键的自然顺序来判断<br>Hashtable 是早期 Java 类库提供的一个哈希表实现，本身是同步的，不支持 null 键和值，由于同步导致的性能开销，所以已经很少被推荐使用<br>解决哈希冲突的常用方法有：<br>开放定址法<br>基本思想是：当关键字key的哈希地址p=H（key）出现冲突时，以p为基础，产生另一个哈希地址p1，如果p1仍然冲突，再以p为基础，产生另一个哈希地址p2，…，直到找出一个不冲突的哈希地址pi ，将相应元素存入其中。</p><p>再哈希法<br>这种方法是同时构造多个不同的哈希函数：<br>Hi=RH1（key） （i=1，2，…，k）当哈希地址Hi=RH1（key）发生冲突时，再计算Hi=RH2（key）……，直到冲突不再产生。这种方法不易产生聚集，但增加了计算时间。</p><p>链地址法<br>这种方法的基本思想是将所有哈希地址为i的元素构成一个称为同义词链的单链表，并将单链表的头指针存在哈希表的第i个单元中，因而查找、插入和删除主要在同义词链中进行。链地址法适用于经常进行插入和删除的情况。</p><p>建立公共溢出区<br>这种方法的基本思想是：将哈希表分为基本表和溢出表两部分，凡是和基本表发生冲突的元素，一律填入溢出表。<br>TreeSet和HashSet、TreeMap的区别？<br>TreeMap 则是基于红黑树的一种提供顺序访问的 Map，和 HashMap 不同，它的 get、put、remove 之类操作都是 O（log(n)）的时间复杂度，具体顺序可以由指定的 Comparator 来决定，或者根据键的自然顺序来判断。<br>相同点：<br>单列集合，元素不可重复<br>不同点</p><ol><li>底层存储的数据结构不同<br> HashSet底层用的是HashMap哈希表结构存储，而TreeSet底层用的是TreeMap树结构存储</li><li>存储时保证数据唯一性依据不同<br> HashSet是通过复写hashCode()方法和equals()方法来保证的，而TreeSet通过Compareable接口的compareTo()方法来保证的</li><li>有序性不一样<br>HashSet无序，TreeSet有序</li></ol><p>存储原理：<br>HashSet:底层数据结构是哈希表，本质就是对哈希值的存储，通过判断元素的hashCode方法和equals方法来保证元素的唯一性，当hashCode值不相同，就直接存储了，不用在判断equals了，当hashCode值相同时，会在判断一次euqals方法的返回值是否为true，如果为true则视为用一个元素，不用存储，如果为false，这些相同哈希值不同内容的元素都存放一个桶里（当哈希表中有一个桶结构，每一个桶都有一个哈希值）<br>TreeSet:底层的数据结构是红黑树（一种自平衡的二叉树，自平衡是指如果有空的左/右子树，元素会先入空的左/右子树，而不会一直往一个方向添加元素出现不平衡现象），可以对Set集合中的元素进行排序,这种结构，可以提高排序性能, 根据比较方法的返回值确定的,只要返回的是0.就代表元素重复<br>TreeSet的add(E e)方法，底层是根据实现Comparable的方式来实现的唯一性，通过compare(Object o)的返回值是否为0来判断是否为同一元素。<br>compare() == 0，元素不入集合。<br>compare() &gt; 0 ,元素入右子树。<br>compare() &lt; 0,元素入左子树。<br>而对其数据结构：自平衡二叉树做前（常用）、中、后序遍历即可保证TreeSet的有序性</p><p>集合类：java中的collection中整体的架构是怎样的？<br>集合的长度是可变的，且存储元素类型是可以任意，而数组长度是固定的，且存储元素类型要保持一致。<br>虽然通常概念上我们也会把 Map 作为集合框架的一部分，但是本身并不是真正的集合（Collection）。<br>List，有序集合<br>Set：不允许重复元素的，也就是不存在两个对象 equals 返回 true。适应需要保证元素唯一性的场合。<br>Queue/Deque，则是 Java 提供的标准队列结构的实现，除了集合的基本功能，它还支持类似先入先出（FIFO， First-in-First-Out）或者后入先出（LIFO，Last-In-First-Out）等特定行为。这里不包括 BlockingQueue，因为通常是并发编程场合，所以被放置在并发包里。<br>有序的Map：LinkedHashMap和TreeMap<br>LinkedHashMap 通常提供的是遍历顺序符合插入顺序，它的实现是通过为键值对维护一个双向链表。可实现FIFO和LRU算法，构建一个空间占用敏感的资源池（缓存区），希望可以自动将最不常被访问的对象释放掉，这就可以利用 LinkedHashMap 提供的机制来实现。<br>TreeMap，它的整体顺序是由键的顺序关系决定的，通过 Comparator 或 Comparable（自然顺序）来决定。<br>concurrent类有哪些<br>ConcurentHashMap<br>ArrayBlockingQueue：用数组实现的有界阻塞队列，其内部按先进先出的原则对元素进行排序，其中put方法和take方法为添加和删除的阻塞方法，阻塞队列是通过一个重入锁ReenterLock和两个Condition条件队列实现的<br>LinkedBlockingQueue：一个由链表实现的有界队列阻塞队列，但大小默认值为Integer.MAX_VALUE，阻塞队列是通过两个重入锁ReenterLock和两个Condition条件队列实现的<br>CopyOnWriteArrayList : 使用了一种叫写时复制的方法，当有新元素添加到CopyOnWriteArrayList时，先从原有的数组中拷贝一份出来，然后在新的数组做写操作，写完之后，再将原来的数组引用指向到新数组,整个add操作都是在锁(ReentrantLock)的保护下进行的。 这样做是为了避免在多线程并发add的时候，复制出多个副本出来<br>所有的写操作都是在新数组进行的，这个时候如果有线程并发的写，则通过锁来控制，如果有线程并发的读，则分几种情况：<br>1、如果写操作未完成，那么直接读取原数组的数据；<br>2、如果写操作完成，但是引用还未指向新数组，那么也是读取原数组数据；<br>3、如果写操作完成，并且引用已经指向了新的数组，那么直接从新数组中读取数据。<br>可见，CopyOnWriteArrayList的读操作是可以不用加锁的。</p><p>2、    java虚拟机<br>java的内存体系是如何管理的，java的内存模型是什么。<br>Java内存模型：为了屏蔽掉各种硬件和操作系统的内存访问差异，以实现让java程序在各种平台上都能达到一致的内存访问效果。主要目标是定义程序中各个变量的访问规则，即在虚拟机中将变量存储到内存和从内存中取出变量（包括实例变量、静态字段和构成数组对象的元素，不包括局部变量与方法参数，后者是线程私有的，不会被共享）。<br>划分：java内存模型规定所有的变量都存储在主内存中，每条线程还有自己的工作内存，线程的工作内存中保存了被该线程使用到的变量的主内存副本拷贝。线程对变量的所有操作都必须在工作内存中进行，而不能直接读写主内存中的变量，线程间变量值的传递均需要通过主内存来完成。<br>主内存中主要对应java堆中的对象实例数据部分。<br>工作内存中对应虚拟机栈中的部分区域。</p><p>Java内存模型主要是定义虚拟机中将变量存储到内存和从内存中取出变量这样的底层细节，这里的变量指的是实例字段，静态字段和构成数组对象的元素等全局变量，不包括局部变量和方法参数，因为后者是私有的，不会被共享。（如果局部变量是引用类型，它引用的对象在java堆中可被各个线程共享，但是引用本身在java栈的局部变量表中，他是线程私有的）<br>Java内存模型规定了所有的变量都存储在主内存，每条线程还有自己的工作内存，线程的工作内存中保存了被该线程使用到的变量的主内存副本拷贝，线程对变量的所有操作都必须在主内存中进行，而不能直接读写主内存中的变量，不同的线程之间也无法直接访问对方工作内存中的变量，线程之间变量值的传递均需要通过主内存来完成。<br>主内存主要对应java堆中的对象实例数据部分，而工作内存则对应于虚拟机栈中的部分区域。<br>Jvm启动时将内存分为那几块，分别存放那些东西，有什么区别。Class文件的定义是在哪块区域<br>程序计数器：java多线程是通过线程轮流切换并分配处理器执行时间的方式来实现，为了使线程切换后能恢复到正确的执行位置，每条线程都需要执行一个独立的线程计数器，各个线程的程序计数器之间互不影响，独立存储，是线程私有的内存，如果执行的是native方法，这个计数器值为空<br>Java虚拟机栈：线程私有，他的生命周期与线程相同，每个方法在执行的同时会创建一个<br>本地方法栈帧用于存储局部变量表、操作数栈，动态链接，方法出口等信息。存放了一些局部变量表部分。会抛出StackOverflowError和OOM异常<br>本地方法栈：虚拟机栈为虚拟机执行java方法（字节码）服务，而本地方法栈则为虚拟机使用到的native方法服务。会抛出StackOverflowError和OOM异常<br>Java堆：被所有的线程共享，在虚拟机启动的时候创建，存放对象的实例和数组等，是垃圾收集器管理的主要区域，采用的分代收集，<br>方法区：线程共享，存储被虚拟机加载的类信息、常量、静态变量、即使编译器编译后的代码等数据<br>运行时常量池：属于方法区的一部分，用于存储编译期生成的各种字面量和符号引用，<br>栈和堆的区别，什么是栈帧<br>栈帧：是用于支持虚拟机进行方法调用和方法执行的数据结构，他是虚拟机运行时数据区中的虚拟机栈的栈元素。栈帧储存了方法的局部变量表，操作数栈，动态连接和方法返回地址等信息。每一个方法从调用开始至执行完成的过程，都对应着一个栈帧在虚拟机栈里面从入栈到出栈的过程。<br>物理地址：<br>堆的物理地址分配对对象是不连续的。因此性能慢些。在GC的时候也要考虑到不连续的分配，所以有各种算法。比如，标记-消除，复制，标记-整理，现在基本使用分代（即新生代使用复制算法，老年代使用标记-整理）<br>栈使用的是数据结构中的栈，先进后出的原则，物理地址分配是连续的。所以性能快。<br>内存区别<br>堆因为是物理上不连续的（逻辑上连续），所以分配的内存是在运行期确认的，因此大小不固定。<br>栈分配的内存大小要在编译期就确认，大小是固定的<br>存放的内容<br>堆存放的是对象的实例和数组。因此该区更关注的是数据的存储（根据逃逸分析，并不是所有的实例都分配在了堆上，当确定一个对象不会逃逸出方法之外，那就可以让这个对象在栈上分配，并随着栈帧出栈而销毁，还有同步消除（变量不会逃逸出线程，无法被其他线程访问，就可以消除同步）和标量替换）<br>栈存放：局部变量，操作数栈，动态链接和方法出口。该区更关注的是程序方法的执行。<br>PS：<br> 静态变量，常量，类信息放在方法区（内存共享）<br> 静态的对象还是放在堆。<br>程序的可见度<br>堆对于整个应用程序都是共享、可见的。<br>   栈只对于线程是可见的。所以也是线程私有。他的生命周期和线程相同。<br>Jvm1.7用的什么回收机制<br>G1垃圾收集器，使用标记-整理算法和复制算法结合，分代收集：根据新生代和老年代收集，新生代中选择复制算法，老年代标记-整理算法<br>垃圾回收算法的工作原理。<br>通过引用计数算法和可达性分析判断对象是否存活的<br>用虚拟机栈中引用的对象，方法区中类静态属性引用的对象，方法区中常量引用的对象作为GC Root<br>CMS用的什么回收算法<br>基于标记-清除算法实现，并发收集、低停顿<br>是以获取最短回收停顿时间为目标的收集器。使用标记 - 清除算法，收集过程分为如下四步：<br>(1). 初始标记，标记GCRoots能直接关联到的对象，时间很短。<br>(2). 并发标记，进行GCRoots Tracing（可达性分析）过程，时间很长。<br>(3). 重新标记，修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，时间较长。<br>(4). 并发清除，回收内存空间，时间很长。<br>其中，并发标记与并发清除两个阶段耗时最长，但是可以与用户线程并发执行。</p><p>G1收集器-整体采用标记-整理，局部基于复制算法<br>(1). 并行和并发。使用多个CPU来缩短Stop The World停顿时间，与用户线程并发执行。<br>(2). 分代收集。独立管理整个堆，但是能够采用不同的方式去处理新创建对象和已经存活了一段时间、熬过多次GC的旧对象，以获取更好的收集效果。<br>(3). 空间整合。基于标记 - 整理算法，无内存碎片产生。<br>(4). 可预测的停顿。可预测的停顿时间模型，能让使用者明确指定在一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间不得超过N毫秒。<br>   在G1之前的垃圾收集器，收集的范围都是整个新生代或者老年代，而G1不再是这样。使用G1收集器时，Java堆的内存布局与其他收集器有很大差别，它将整个Java堆划分为多个大小相等的独立区域（Region），虽然还保留有新生代和老年代的概念，但新生代和老年代不再是物理隔离的了，它们都是一部分（可以不连续）Region的集合。</p><p>调用system.gc会触发什么操作？<br>System.gc()用于调用垃圾收集器，在调用时，垃圾收集器将运行以回收未使用的内存空间。它将尝试释放被丢弃对象占用的内存。然而System.gc（）调用附带一个免责声明，无法保证对垃圾收集器的调用, 只是提醒虚拟机：程序员希望进行一次垃圾回收。但是它不能保证垃圾回收一定会进行，而且具体什么时候进行是取决于具体的虚拟机的，不同的虚拟机有不同的对策。<br>垃圾回收的minorGC和fullGC的区别<br>对象在新生代Eden区中分配，当Eden区没有足够的空间进行分配时，虚拟机将发起一次minor GC，指发生在新生代的垃圾收集，新生代使用复制收集算法。<br>Major/Full GC ：老年代的GC，出现了full gc，一般会伴随minor gc，老年代使用标记整理</p><p>类加载机制，谈到双亲委派模型后会问到哪些违反了双亲委派模型？为什么？为什么要双亲委派？好处是什么？<br>类加载机制：虚拟机把描述类的数据从class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的java类型，从类被加载到虚拟机内存开始，到卸载出内存为止。<br>双亲委派模型：启动类加载，扩展类加载器、应用程序类加载器。如果一个类加载器收到了类加载的请求，他首先不会自己加载这个类，而是把这个请求委派给父类加载器去完成，因此所有的类加载请求最终都应该传送到顶层的启动类加载器中，只有当父类反馈自己无法加载请求时，子加载器会尝试自己去加载，若找不到回报ClassNotfoundException.<br>双亲委派模型的好处：java类随着他的类加载器一起具备了一种带有优先级的层次关系。例如Object类，无论哪一个类要加载它，最终都是委派给处于模型最顶端的启动类加载器进行加载，因此Object类在程序的各种类加载器环境真都是一个类。<br>破坏双亲委派模型：重写loadClass()方法，线程上下文加载器（父类加载器可以请求子类加载器去完成类加载工作，例jdbc），代码热替换、模块热部署（自定义的类加载机制实现<br>）<br>Happens-before（先行发生原则）<br>操作A先行发生于操作B，在发生操作B之前，操作A产生的影响能被操作B观察到，用来判断数据是否存在竞争、线程是否安全的依据。<br>垃圾回收机制：<br>•  那些内存需要回收？(对象是否可以被回收的两种经典算法: 引用计数法 和 可达性分析算法)<br>•  什么时候回收？ （堆的新生代、老年代、永久代的垃圾回收时机，MinorGC 和 FullGC）<br>•  如何回收？(三种经典垃圾回收算法(标记清除算法、复制算法、标记整理算法)及分代收集算法 和 七种垃圾收集器)<br>HashMap 的原理？当谈到线程不安全时自然引申出 ConcurrentHashMap ，它的实现原理？<br>Hashmap：底层由数组和链表组成，每个数组里面存的是一个单向链表，不支持并发操作，线程不安全，java8中当链表中的元素超过8个，会自动将链表转换为红黑树，提高效率<br>ConcurrentHashMap：[kənˈkɜːrənt]支持并发操作，线程安全，利用分段锁实现，是一个segment数组，segment通过继承ReentrantLock来进行加锁每次需要加锁锁住的是一个segment，保证了每个segment都是线程安全的，默认数组大小为16（不可扩容），并且之间互不干扰，并发执行<br>3、    数据库<br>InnoDB和MyISAM的区别<br>InnoDB：mysql的默认存储引擎，具有自动崩溃恢复特性，采用MVCC（多版本并发控制）来支持高并发，并且实现四个标准的隔离级别，默认是可重复读，并通过间隙锁策略来防止幻读。InnoDB表示基于聚簇索引建立的，采用的是行级锁，最大程度的支持并发处理。<br>MyISAM：MySQL5.1之前默认的存储引擎，提供了全文检索、压缩等，但MyISAM不支持事务和行级锁，数据库崩溃后无法安全恢复，对于只读的数据，或者表比较小可以继续使用MyISAM；MyISAM对整张表加锁，而不是针对行，读取时会对需要读到的所有表加共享锁，写入时则对表加排它锁。</p><p>压缩：如果表在创建并导入数据之后，以后不会进行修改操作，就可以对表进行压缩，可以极大地减少磁盘空间的占用，因此减少磁盘io，从而 提升查询性能。</p><p>全文检索：一种特殊类型的索引，查找的是文本中的关键词，而不是直接比较索引中的值，类似于搜索引擎做的事情，而不是简单的where匹配。使用一种特殊的B-Tree索引，共有两层，第一层是所有的关键字，然后对于每一个关键字的第二层，包含的是一组相关的“文档指针”。<br>Innodb有哪些索引，具体怎么实现的。<br>前缀索引（blob，text或者很长的varchar类型的列，计算合适的前缀长度的一个方法就是计算完整列的选择性，使得前缀的选择性接近于完整列的选择性，缺点：mysql无法使用前缀索引做order by 和 group by，也无法使用前缀索引做覆盖扫描）<br>多列索引：索引合并，使用表上的多个单列索引来定位指定的行，查询时能够同时使用这两个单列索引进行扫描，并将结果进行合并。<br>聚簇索引<br>覆盖索引：包含所有需要查询的字段的值，<br>哪些场景会让你不会命中索引<br>索引列是表达式的一部分，或者是函数的参数，如果要查询的列不是独立的列，就不会使用索引<br>InnoDB：mysql的默认存储引擎，采用MVCC（多版本并发控制）来支持高并发，并且实现四个标准的隔离级别，默认是可重复读，并通过间隙锁策略来防止幻读。InnoDB表示基于聚簇索引建立的，采用的是行级锁，最大程度的支持并发处理。<br>聚簇索引：是一种数据存储方式，实际上是在同一个结构中保存了B-Tree索引和数据行，聚簇索引的叶子页包含了行的全部数据，节点页只包含索引列，一个表中只能有一个聚簇索引，并且是通过主键聚集数据。<br>B-Tree索引：所有的值都是存储在叶子节点并且按照顺序存储的，并且每一个叶子到根的距离相同，B-Tree索引能够加快访问数据的速度，因为存储引擎不需要进行全表查询来获取需要的数据，而是从索引的根节点开始进行搜索，根节点的槽中存放了指向子节点的指针，存储引擎根据这些指针向下层查找。<br>哈希索引：基于hash表实现，只有精确匹配索引的所有列的查询才有效。对于每一行数据，存储引擎都会对所有的索引列表计算出一个hash码，哈希索引将所有的哈希码存储在索引中，同时在hash表中保存指向每个数据行的指针。<br>分库分表如何设计？垂直拆分、水平拆分？<br> 分表：对于访问极为频繁且数据量巨大的单表来说，我们首先要做的就是减少单表的记录条数，以便减少数据查询所需要的时间，提高数据库的吞吐，这就是所谓的分表！<br>用户id是最常用的分表字段。因为大部分查询都需要带上用户id，这样既不影响查询，又能够使数据较为均衡地</p><p>分库：分表能够解决单表数据量过大带来的查询效率下降的问题，但是，却无法给数据库的并发处理能力带来质的提升。面对高并发的读写访问，当数据库master服务器无法承载写操作压力时，不管如何扩展slave服务器，此时都没有意义了。对数据库进行拆分，从而提高数据库写入能力，这就是所谓的分库!<br>与分表策略相似，分库可以采用通过一个关键字取模的方式，来对数据访问进行路由<br>分库分表：有时数据库可能既面临着高并发访问的压力，又需要面对海量数据的存储问题，这时需要对数据库既采用分表策略，又采用分库策略，以便同时扩展系统的并发处理能力，以及提升单表的查询性能，这就是所谓的分库分表。</p><p>数据库做了分区分表就要保证一致性，采用分布式事务或者最终一致性来处理，服务之间的通信和交互依赖定义的良好接口，通常使用restful样式的aip或者透明的RPC调用框架。</p><p>in 和exist  的区别和好处（如果两个表中一个较小，一个是大表，则子查询表大的用exists，子查询表小的用in）<br>select * from A<br>where id in(select id from B)<br>以上查询使用了in语句,in()只执行一次,它查出B表中的所有id字段并缓存起来.之后,检查A表的id是否与B表中的id相等,如果相等则将A表的记录加入结果集中,直到遍历完A表的所有记录.<br>in()适合B表比A表数据小的情况</p><p>数据库的事务，自动提交和手动提交，mysql是否开启事务，如果手动提交后不关闭会怎样，回滚机制是怎么工作的<br>—&gt; mysql采用默认提交的模式，如果不是显示的开始一个事务，则每个查询都被当做一个事务执行提交操作，在当前链接中，可以通过设置autocommit来启动（1）或者禁用（0）自动提交模式。当设置autocommit=0时，表示所有的查询都是在一个事务中，直到显示的执行commit提交或者rollback回滚，该事务结束后，同时又开始了另一个新的事务。默认采用的隔离级别是可重复读。<br>4、    多线程<br>平时怎么使用多线程？有哪些好处？线程池的几个核心参数的意义？<br>并发访问数据库。提高系统并发量，增加吞吐量。<br>Int corePoolSize：线程池基本大小，如果当线程池的当前大小超过了基本大小时，当前线程将被终止。当工作队列满了的情况下会创建出超过这个数量的线程。<br>Int maximumPoolSize：最大大小，可同时活动的线程数量的上限<br>Long keepAliveTime：存活时间，当某线程的空闲时间超过了存活时间则可回收。<br>TimeUnit unit：　　　　keepAliveTime时间单位<br>BlockingQueue<runnable> workQueue：存储还没来得及执行的任务<br>ThreadFactory threadFactory：线程工厂，线程池创建线程通过线程工厂方法完成<br>RejectedExecutionHandler handler：饱和策略，当工作队列被填满后，通过拒绝执行或抛弃某项任务尝试执行新的任务。<br>如何创建一个线程池，当我创建了一个大小为10的线程池时，当我第11个线程到来时会出现什么情况。如何超过了线程队列的大小会怎样？<br> 放到工作队列中，当工作队列被填满后，通过饱和策略拒绝执行或抛弃某项任务尝试执行新的任务。</runnable></p><p>线程间通信的方式？<br>通过共享变量进行通信<br>通过队列进行通信（消费者生产者模式）<br>Synchronized同步、while轮询、wait/notify机制、管道通信<br>Java线程启动时我想指定内存大小使用什么参数，和方法。<br>通过ProcessBuilder的start方法来创建一个新进程</p><p>Xmx：指定java程序的最大堆内存, 使用java -Xmx5000M -version判断当前系统能分配的最大堆内存<br>Xms：指定最小堆内存, 通常设置成跟最大堆内存一样，如果虚拟机启动时设置使用的内存比较小，这个时候又需要初始化很多对象，虚拟机就必须重复地增加内存。设置一样可以减轻伸缩堆大小带来的压力<br>Xmn：年轻代大小，整个堆大小=年轻代大小 + 年老代大小。所以增大年轻代后，将会减小年老代大小。此值对系统性能影响较大，Sun官方推荐配置为整个堆的3/8<br>Xss：指定线程的最大栈空间, 此参数决定了java函数调用的深度, 值越大调用深度越深, 若值太小则容易出栈溢出错误(StackOverflowError)<br>Java中如何创建一个进程<br>1、Runtime.exec()方法来创建一个进程，由于任何进程只会运行于一个虚拟机实例当中，所以在Runtime中采用了单例模式，即只会产生一个虚拟机实例，最终还是通过ProcessBuilder类的start方法来创建的<br>2、通过ProcessBuilder的start方法来创建进程，ProcessBuilder是一个final类<br>线程和进程的区别<br>进程是系统进行资源分配和调度的一个独立单位.<br>线程是CPU调度和分派的基本单位,它是比进程更小的能独立运行的基本单位.线程自己基本上不拥有系统资源，线程共享进程所拥有的全部资源。<br>一个线程可以创建和撤销另一个线程;同一个进程中的多个线程之间可以并发执行.<br>进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其它进程产生影响，而线程只是一个进程中的不同执行路径。线程有自己的堆栈和局部变量，但线程没有单独的地址空间，一个线程死掉就等于整个进程死掉，所以多进程的程序要比多线程的程序健壮，但在进程切换时，耗费资源较大，效率要差一些。但对于一些要求同时进行并且又要共享某些变量的并发操作，只能用线程，不能用进程。<br>创建一个线程，常用的方法。<br>继承Thread类创建线程类<br>通过Runnable接口创建线程类<br>通过Callable和FutureTask创建线程<br>（1）创建Callable接口的实现类，并实现call()方法，该call()方法将作为线程执行体，并且有返回值。<br>（2）创建Callable实现类的实例，使用FutureTask类来包装Callable对象，该FutureTask对象封装了该Callable对象的call()方法的返回值。<br>（3）使用FutureTask对象作为Thread对象的target创建并启动新线程。<br>（4）调用FutureTask对象的get()方法来获得子线程执行结束后的返回值<br>终止线程 4 种方式<br>1、    正常结束<br>2、    使用退出标志退出线程<br>3、    Interrupt [ˌɪntəˈrʌpt] 方法结束线程<br>4、    stop 方法终止线程（线程不安全）<br>sleep 与 wait 区别<br>1、对于sleep()方法，我们首先要知道该方法是属于Thread类中的。而wait()方法，则是属于 Object类中的。<br>2、 sleep()方法导致了程序暂停执行指定的时间，让出cpu该其他线程，但是他的监控状态依然 保持者，当指定的时间到了又会自动恢复运行状态。<br>3、 在调用sleep()方法的过程中，线程不会释放对象锁。<br>4、调用wait()方法的时候，线程会放弃对象锁，进入等待此对象的等待锁定池，只有针对此 对象调用notify()方法后本线程才进入对象锁定池准备获取对象锁进入运行状态。<br>start 与 run 区别 </p><ol><li>start（）方法来启动线程，真正实现了多线程运行。这时无需等待 run 方法体代码执行完毕， 可以直接继续执行下面的代码。 </li><li>通过调用 Thread 类的 start()方法来启动一个线程， 这时此线程是处于就绪状态， 并没有运 行。 </li><li>方法 run()称为线程体，它包含了要执行的这个线程的内容，线程就进入了运行状态，开始运 行run函数当中的代码。 Run方法运行结束， 此线程终止。然后CPU再调度其它线程。<br>JAVA锁<br>对 Java 锁的理解？<br>synchronize，Lock接口的应用<br>synchronized：在需要同步的对象中加入此控制，synchronized可以加在方法上，也可以加在特定代码块中，括号中表示需要锁的对象。<br>lock：需要显示指定起始位置和终止位置。一般使用ReentrantLock类做为锁，多个线程中必须要使用一个ReentrantLock类做为对象才能保证锁的生效。且在加锁和解锁处需要通过lock()和unlock()显示指出。所以一般会在finally块中写unlock()以防死锁。<br>锁的具体应用场景<br>悲观锁（synchronized）：比较适合写入操作比较频繁的场景，如果出现大量的读取操作，每次读取的时候都会进行加锁，这样会增加大量的锁的开销，降低了系统的吞吐量。<br>乐观锁（Lock-tryLock）：比较适合读取操作比较频繁的场景，如果出现大量的写入操作，数据发生冲突的可能性就会增大，为了保证数据的一致性，应用层需要不断的重新获取数据，这样会增加大量的查询操作，降低了系统的吞吐量。java 中的乐观锁基本都是通过 CAS 操作实现的，CAS 是一种更新的原子操作，比较当前值跟传入 值是否一样，一样则更新，否则失败。<br>例如ReentrantReadWriteLock读写锁，缓存用到了<br>synchronize，Lock的区别及优缺点<br>synchronized：jdk1.6之前采用的是悲观锁的机制，用的是重量级锁，线程获取的是独占锁。1.6之后做了优化（适应性自旋、锁消除，锁粗化等），其他线程只能依靠阻塞来等待线程释放锁。而在CPU转换线程阻塞时会引起线程上下文切换，当有很多线程竞争锁的时候，会引起CPU频繁切换导致效率很低。<br>Lock：采用乐观锁，每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止。乐观锁实现的机制就是CAS操作（Compare and Swap）<br>Synchronized和ReentranLock（riˈɛntrəntlɑːk可重入锁）的区别</li><li>ReentrantLock 通过方法 lock()与unlock()来进行加锁与解锁操作，与synchronized 会 被 JVM 自动解锁机制不同，ReentrantLock 加锁后需要手动进行解锁。为了避免程序出 现异常而无法正常解锁的情况，使用 ReentrantLock 必须在 finally 控制块中进行解锁操作。</li><li>ReentrantLock相比synchronized的优势是可中断、公平锁、多个锁。这种情况下需要使用ReentrantLock。<br>具体解释一下CAS<br>CAS（比较并交换）：包含三个操作数-需要读写的内存位置V，进行比较的值A和拟写入的新值B。当且仅当V的值等于A的值时，CAS才会通过原子方式用新值B的值来更新V的值，否则不会执行任何操作。<br>CAS里面是一个循环判断的过程，如果线程一直没有获取到状态，cpu资源会一直被占用。当使用引用类型的时候会出现ABA问题，例如对链表进行删除元素操作，JUC提供了带有标记的原子引用类来保证CAS的正确性。<br>5、    数据结构<br>排序算法：</li></ol><p>6、    计算机网络<br>http报文头里面含有什么<br>请求头<br>返回头<br>文本域<br>文本编码</p><p>谈谈你所理解的 HTTP 协议？<br>http协议是无状态的，简化了服务器的设计，支持大量并发请求。<br>采用TCP作为运输层协议，保证了数据的可靠性。但是http协议本身是无连接的，在通信双方交换http报文之前不需要先建立http连接。<br>HTTP连接最显著的特点是客户端发送的每次请求都需要服务器回送响应，在请求结束后，会主动释放连接。<br>1）在HTTP 1.0中，客户端的每次请求都要求建立一次单独的连接，在处理完本次请求后，就自动释放连接。<br>2）在HTTP 1.1中则可以在一次连接中处理多个请求，并且多个请求可以重叠进行，不需要等待一个请求结束后再发送下一个请求。<br>访问一个网址的流程：<br>a：域名解析<br>b：tcp3次握手建立连接<br>c：建立连接后，发起http请求<br>d：服务器端响应http请求，浏览器得到http请求的内容<br>e：浏览器解析html代码，并请求html代码中的资源<br>f：浏览器通过页面渲染，展现在用户面前<br>对 TCP 的理解？三次握手？滑动窗口？<br>TCP：一种面向连接的、可靠的、基于字节流的传输层通信协议，全双工模式<br>三次握手：为了保证服务端能收接受到客户端的信息并能做出正确的应答而进行前两次(第一次和第二次)握手，为了保证客户端能够接收到服务端的信息并能做出正确的应答而进行后两次(第二次和第三次)握手，第三步是防止了乙的一直等待而浪费自己的时间，而不是为了保证甲能够正确回应乙的信息。<br>三次握手的目的：为了防止已失效的连接请求报文段突然又传送到了服务端，而产生错误。<br>四次挥手：当 Client 发出FIN报文段时，只是表示 Client 已经没有数据要发送了，Client 告诉 Server，它的数据已经全部发送完毕了；但是，这个时候 Client 还是可以接受来自 Server 的数据；当 Server 返回ACK报文段时，表示它已经知道 Client 没有数据发送了，但是 Server 还是可以发送数据到 Client 的；当 Server 也发送了FIN报文段时，这个时候就表示 Server 也没有数据要发送了，就会告诉 Client ，我也没有数据要发送了，之后彼此就会愉快的中断这次TCP连接。<br>滑动窗口(以字节为单位)：TCP协议作为一个可靠的面向流的传输协议，其可靠性和流量控制由滑动窗口协议保证。<br>流量控制：发送方的发送窗口不能超过接收方给出的接收窗口的数值。<br>已发送并收到确认的数据（不再发送窗口和发送缓冲区之内）、已发送但未收到确认的数据（位于发送窗口之中）、允许发送但尚未发送的数据以及发送窗口外发送缓冲区内暂时不允许发送的数据；<br>TCP/UDP有哪些优缺点？<br>1、TCP面向连接（如打电话要先拨号建立连接）;UDP是无连接的，即发送数据之前不需要建立连接<br>2、TCP提供可靠的服务。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达;UDP尽最大努力交付，即不保证可靠交付<br>3、TCP面向字节流，实际上是TCP把数据看成一连串无结构的字节流;UDP是面向报文的<br>  UDP没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如IP电话，实时视频会议等）<br>4、每一条TCP连接只能是点到点的;UDP支持一对一，一对多，多对一和多对多的交互通信<br>5、TCP首部开销20字节;UDP的首部开销小，只有8个字节<br>6、TCP的逻辑通信信道是全双工的可靠信道，UDP则是不可靠信道<br>TCP可靠的四大手段：<br>顺序编号：tcp在传输文件的时候，会将文件拆分为多个tcp数据包，每个装满的数据包大小大约在1k左右，tcp协议为保证可靠传输，会将这些数据包顺序编号<br>确认机制：当数据包成功的被发送方发送给接收方，接收方会根据tcp协议反馈给发送方一个成功接收的ACK信号，信号中包含了当前包的序号<br>超时重传：当发送方发送数据包给接收方时，会为每一个数据包设置一个定时器，当在设定的时间内，发送方仍没有收到接收方的ACK信号，会再次发送该数据包，直到收到接收方的ACK信号或者连接已断开<br>校验信息：tcp首部校验信息较多，udp首部校验信息较少</p><p>为什么不能用两次握手进行连接？<br>答：3次握手完成两个重要的功能，既要双方做好发送数据的准备工作(双方都知道彼此已准备好)，也要允许双方就初始序列号进行协商，这个序列号在握手过程中被发送和确认。 现在把三次握手改成仅需要两次握手，死锁是可能发生的。<br>为什么连接的时候是三次握手，关闭的时候却是四次握手？<br>答：建立连接的时候， 服务器在LISTEN状态下，收到建立连接请求的SYN报文后，把ACK和SYN放在一个报文里发送给客户端。<br>而关闭连接时，服务器收到对方的FIN报文时，仅仅表示对方不再发送数据了但是还能接收数据，而自己也未必全部数据都发送给对方了，所以己方可以立即关闭，也可以发送一些数据给对方后，再发送FIN报文给对方来表示同意现在关闭连接，因此，己方ACK和FIN一般都会分开发送，从而导致多了一次。<br>如果已经建立了连接，但是客户端突然出现故障了怎么办？<br>TCP还设有一个保活计时器，显然，客户端如果出现故障，服务器不能一直等下去，白白浪费资源。服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75秒钟发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。<br>MSL(最大报文段生存时间)</p><p>7、    操作系统<br>操作系统的组成<br>1、驱动程序是最底层的、直接控制和监视各类硬件的部分，它们的职责是隐藏硬件的具体细节，并向其他部分提供一个抽象的、通用的接口。</p><p>2、内核是操作系统之最内核部分，通常运行在最高特权级，负责提供基础性、结构性的功能。</p><p>3、支承库是一系列特殊的程序库，它们职责在于把系统所提供的基本服务包装成应用程序所能够使用的编程接口（API），是最靠近应用程序的部分。例如，GNU C运行期库就属于此类，它把各种操作系统的内部编程接口包装成ANSI C和POSIX编程接口的形式。</p><p>4、外围是指操作系统中除以上三类以外的所有其他部分，通常是用于提供特定高级服务的部件。例如，在微内核结构中，大部分系统服务，以及UNIX/Linux中各种守护进程都通常被划归此列。<br>操作系统中的缓存<br>缓存（cache），原始意义是指访问速度比一般随机存取存储器（RAM）快的一种高速存储器，可以进行高速数据交换的存储器，它先于内存与CPU交换数据。<br>操作系统中虚拟内存是什么<br>虚拟内存允许执行进程不必完全在内存中。每个进程拥有独立的地址空间，这个空间被分为大小相等的多个块，称为页(Page)，每个页都是一段连续的地址。这些页被映射到物理内存，但并不是所有的页都必须在内存中才能运行程序。<br>进程和线程<br>（1）进程是对运行时程序的封装,是系统进行资源调度和分配的基本单位,实现操作系统的并发。</p><p>（2）线程是进程的子任务,是CPU调度和分派的基本单位,用于保证程序的实时性,实现进程内部的并发。</p><p>（3）一个程序至少有一个进程,一个进程至少有一个线程,线程依赖进程的存在。</p><p>（4）进程执行过程中拥有独立的内存单元,而多个线程共享进程的内存。<br>8、    io<br>什么叫做BIO、NIO、AIO、Netty<br>BIO：同步阻塞式IO，服务器端与客户端通过三次握手后建立连接，连接成功，双方通过I/O进行同步阻塞式通信。<br>NIO：NIO类库是jdk1.4中引入的，它弥补了同步阻塞IO的不足，它在Java提供了高速的，面向块的I/O。同步阻塞IO是以流的方式处理数据，而NIO是以块的方式处理数据。面向流的I/O通常比较慢, 按块处理数据比按(流式的)字节处理数据要快得多。<br>AIO：异步非阻塞I/O，NIO2的异步套接字通道时真正的异步非阻塞I/O，它对应unix网络驱动中的事件驱动I/O,它不需要通过多路复用器对注册的通道进行轮询操作即可实现异步读写，简化了NIO编程模型。<br>Netty：是业界最流行的NIO框架之一，具有健壮性，性能好，可定制性，可扩展性。<br>SSM框架<br>Spring框架中运用到了哪些设计模式，具体体现是什么<br>工厂设计模式 : Spring使用工厂模式通过 BeanFactory、ApplicationContext 创建 bean 对象。<br>代理设计模式 : Spring AOP 功能的实现。<br>单例设计模式 : Spring 中的 Bean 默认都是单例的。<br>模板方法模式 : Spring 中 jdbcTemplate、hibernateTemplate 等以 Template 结尾的对数据库操作的类，它们就使用到了模板模式。<br>包装器设计模式 : 我们的项目需要连接多个数据库，而且不同的客户在每次访问中根据需要会去访问不同的数据库。这种模式让我们可以根据客户的需求能够动态切换不同的数据源。<br>观察者模式: Spring 事件驱动模型就是观察者模式很经典的一个应用。<br>适配器模式 :Spring AOP 的增强或通知(Advice)使用到了适配器模式、spring MVC 中也是用到了适配器模式适配Controller。<br>Bean在spring中的生命周期是怎样的（*）<br>1.实例化bean对象<br>2.注入bean的所有属性<br>3.设置bean的id<br>        调用BeanNameAware接口的setBeanName(String)方法</p><p>4.设置bean工厂<br>        调用BeanFactoryAware接口的setBeanFactory()方法</p><p>5.设置实例所在的上下文空间<br>        调用ApplicationContextAware接口的setApplicationContext()方法，传入Spring上下文<br>6.调用后置处理器的预初始化方法<br>        调用BeanPostProcessor接口的postProcessorBeforeInitialization()方法<br>7.执行InitializingBean[ɪˈnɪʃəlaɪzɪŋ]的afterPropertiesSet()<br>8.调用使用init-method配置的自定义初始化方法<br>9.调用后置处理器的后初始化方法<br>        调用BeanPostProcessor接口的postProcessorAfterInitialization()方法<br>10.调用DisPosableBean接口的destory()方法<br>11.调用使用destroy-method配置的自定义销毁由方法</p><p>由BeanFactroy创建的bean<br>没有第五步<br>Spring 的IOC为什么叫做控制反转或者依赖注入<br>控制反转是从容器的角度来说的，以前对象都是应用程序new出来的，对象之间的依赖也是应用程序自己创建的，从而导致类与类之间高耦合，难于测试。现在，由Spring管理bean的生命周期以及bean之间的关系，降低了业务对象替换的复杂性，提高了组件之间的解耦。</p><p>对资源进行集中管理，实现了资源的可配置和易管理；</p><p>隐藏细节，不用自己组装，我们只负责调用。</p><p>依赖注入是从应用程序的角度来说的，即，应用程序依赖Spring管理的bean以及bean之间的关系。Spring容器中有很多bean的实例，它会将符合依赖关系的对象通过注入的方式进行关联，建立bean与bean之间的联系。<br>常见注入方式有：属性注入，构造器注入，数组注入，集合注入（list、map）。<br>自动装配（只适用于 ref类型，也就是引用类型 ）<br>    约定优于配置<br>自动装配：<br>&lt;bean … class=”org.entity.Course”  autowire=”byName|byType|constructor|no” &gt;  byName本质是byId<br>byName:  自动寻找：其他bean的id值=该Course类的属性名<br>byType:  其他bean的类型(class)  是否与 该Course类的ref属性类型一致  （注意，此种方式 必须满足：当前Ioc容器中 只能有一个Bean满足条件  ）<br>constructor： 其他bean的类型(class)  是否与 该Course类的构造方法参数 的类型一致；此种方式的本质就是byType<br>Spring的AOP怎么理解的<br>面向切面编程，通过预编译方式和运行期动态代理实现程序功能的统一维护的一种技术。AOP采取横向抽取机制，支持将公共业务提取出来（例如：安全/事务/日志）进行集中管理，面向核心业务编程，只需要关注业务本身，而不用去关注公共业务。使用AOP可以将那些与业务无关，却为业务模块所共同调用的逻辑或责任封装起来，便于减少系统的重复代码，降低模块间的耦合度，并有利于未来的可操作性和可维护性。<br>应用：事务管理、性能监视、安全检查、缓存 、日志等<br>原理：<br>Spring中实现AOP的方式有三种，分别为，基于AspectJ注解方式实现、基于Schema的xml配置、基于ProxyFactoryBean代理实现，但是底层都是基于动态代理实现的，动态代理有JDK动态代理和CGLIB动态代理，AOP默认使用的是JDK动态代理，当目标类没有接口时，使用CGLIB动态代理，也可以在配置文件中配置proxy-target-class=true，只使用CGLIB动态代理。<br>AOP术语</p><ol><li>target目标类：需要被代理的类。例如：UserService</li><li>Joinpoint连接点：所谓连接点是指那些可能被拦截到的方法。例如：所有的方法</li><li>PointCut切入点：已经被增强的连接点。例如：addUser()</li><li>advice通知/增强，增强代码。例如：after、before</li><li>Weaving织入：是指把增强advice应用到目标对象target来创建新的代理对象proxy的过程.</li><li>proxy代理类</li><li>Aspect切面：是切入点pointcut和通知advice的结合<br>一个线是一个特殊的面。<br>一个切入点和一个通知，组成成一个特殊的面。</li></ol><p>Spring 的常用注解</p><ol><li><p>控制反转<br>@Component，标注为一个普通的bean<br>@Service，@Repository</p></li><li><p>依赖注入<br>@Autowired<br>@Qulifier<br>@Resource<br>@Value</p></li><li><p>全局<br>@Configuration，代替配置文件，相当于beans<br>@ComponentScan，配置扫描包<br>@Scope，配置bean的生命周期<br>如何解决 get 和 post 乱码问题?</p></li><li><p>get乱码，手动转换<br>String name = new String(xx.getBytes(“iso-8859-1”),”utf-8”);<br>不行的话，再：<br>在server.xml中，修改编码和工程编码一致</p></li><li><p>post乱码，在web.xml中配置字符过滤的filter,采用的类是Spring的CharacterEncodingFilter<br>Spring 的事务</p></li><li><p>事务的特性ACID<br>原子性、一致性、隔离性、持久性</p></li><li><p>事务是一系列操作的最小单元，在Spring中，一个session对应一个事务，要么全部成功要么全部失败，如果中间有一条出现异常，那么回滚之前的所有操作</p></li><li><p>Spring中有自己的事务管理机制，实现方式共有两种：编程式和声明式。</p></li></ol><p>编程式事务：使用TransactionTemplate，重写execute方法实现事务管理</p><p>声明式事务：使用AOP面向切面编程实现，本质就是在目标方法执行前后进行拦截。在目标方法执行前加入或创建一个事务，在执行方法执行后，根据实际情况选择提交或是回滚事务。</p><p>实现声明式事务管理又有两种方式：<br>基于XML配置文件；</p><p>基于注解，使用@Transactional注解，将事务规则应用到业务逻辑中</p><ol start="4"><li>事务最重要的两个特性是事务的传播级别（7种）和数据隔离级别（4种）</li></ol><p>传播级别定义的是事务的控制范围。</p><p>我使用过的是REQUIRED和SUPPORTS<br>EQUIRED（增删改）：在事务中执行，如果没有事务存在，则会重新创建一个。<br>SUPPORTS（查）：使用当前的环境执行，如果当前存在事务，则使用这个事务；如果当前没有事务，则不使用事务</p><p>事务隔离级别定义的是事务在数据库读写方面的控制范围。</p><p>未授权读取，授权读取，可重复读取，序列化（隔离级别最高）</p><p>事务隔离的实现是基于悲观锁和乐观锁</p><p>Mysql默认的隔离级别是可重复读<br>谈谈你对SpringMVC的理解</p><ol><li>是一个基于MVC的web框架</li><li>SpringMVC是Spring的一个模块，是Spring的子容器，子容器可以拿父容器的东西，但是父容器不能拿子容器的东西</li><li>SpringMVC的前端控制器DispatcherServlet，用于分发请求，使开发变得简单</li><li>SpringMVC三大组件<br>1）HandlerMapping：处理器映射器<br>用户请求路径到Controller方法的映射<br>2）HandlerAdapter：处理器适配器<br>根据handler(controlelr类）的开发方式（注解开发/其他开发） 方式的不同去寻找不同的处理器适配器<br>3）ViewResolver：视图解析器<br>可以解析JSP/freemarkerr/pdf等<br>Spring MVC 原理<br>Spring的模型-视图-控制器（MVC）框架是围绕一个DispatcherServlet 来设计的，这个Servlet 会把请求分发给各个处理器，并支持可配置的处理器映射、视图渲染、本地化、时区与主题渲染 等，甚至还能支持文件上传。<br>流程图：<br>（1）用户发送请求至前端控制器DispatcherServlet；<br>（2） DispatcherServlet收到请求后，调用HandlerMapping处理器映射器，请求获取Handle；<br>（3）处理器映射器根据请求url找到具体的处理器，生成处理器对象及处理器拦截器(如果有则生成)一并返回给DispatcherServlet；<br>（4）DispatcherServlet 调用 HandlerAdapter处理器适配器；<br>（5）HandlerAdapter 经过适配调用 具体处理器(Handler，也叫后端控制器)；<br>（6）Handler执行完成返回ModelAndView；<br>（7）HandlerAdapter将Handler执行结果ModelAndView返回给DispatcherServlet；<br>（8）DispatcherServlet将ModelAndView传给ViewResolver视图解析器进行解析；<br>（9）ViewResolver解析后返回具体View；<br>（10）DispatcherServlet对View进行渲染视图（即将模型数据填充至视图中）<br>（11）DispatcherServlet响应用户。<br>SpringMVC 常用注解都有哪些?</li><li>@Controller，使用它标记的类就是一个SpringMVC Controller 对象</li><li>@RequestMapping，处理请求映射地址</li><li>@PathVariable，用于对应restful风格url中的参数<br>@RequestMapping(value=”/happy/{dayid}”) findPet(@PathVariable String dayid)</li><li>@RequestParam，将请求的参数绑定到方法中的参数上<br>@RequestParam(value = “name”, required = false)String name</li><li>@ResponseBody，将返回类型直接输入到http response body中</li><li>@RequestBody，方法参数直接被绑定到http request body中</li><li>@ModelAttribute和@SessionAttributes，用来传递和保存数据，有很多的坑，不建议使用</li></ol><p>Mybatis：mapper.xml中写sql语句，其中#符和$符有什么区别。<br>输入参数ParameterType，输出参数：ResultType</p><p>#{}、${}的区别：<br>a.#{任意值}<br>${value} ，其中的标识符只能是value</p><p>b.#{}自动给String类型加上’’  （自动类型转换）<br>  ${} 原样输出，但是适合于 动态排序（动态字段）</p><p>c.#{}可以防止SQL注入<br>  ${}不防止</p><p>${}、#{}相同之处：都可以 获取对象的值<br>Mybatis 的使用步骤是什么样的?<br>        1. 读取配置文件<br>        2. 创建SqlSessionFactoty<br>        3. 创建SqlSession<br>        4. 操作数据库<br>        5. 提交事务（增删改）<br>        6. 关闭session<br>使用 MyBatis 的 mapper 接口调用时有哪些要求</p><ol><li><p>namespace命名空间指向一个特定的dao接口（全路径）</p></li><li><p>每一个sql中的id，唯一标识接口中的一个方法</p></li><li><p>parameterType对应接口方法中的输入参数类型</p></li><li><p>resultType对应接口方法的返回类型</p></li><li><p>参数多个怎么做<br>map，索引，注解@Param<br>mybatis的缓存机制，一级，二级介绍一下</p></li><li><p>一级缓存</p><pre><code>默认开启</code></pre><p>SqlSession级别的缓存，实现在同一个会话中数据的共享<br>一级缓存的生命周期和SqlSession一致<br>当有多个SqlSession或者分布式环境下，数据库写操作会引起脏数据。</p></li><li><p>二级缓存<br>默认不开启，需手动开启<br>SqlSessionFactory级别的缓存，实现不同会话中数据的共享，是一个全局变量<br>可自定义存储源，如Ehcache<br>当开启缓存后，数据查询的执行的流程是：二级缓存&gt;一级缓存&gt;数据库<br>不同于一级缓存，二级缓存可设置是否允许刷新和刷新频率<br>实现：<br>实体类实现序列化<br>在mapper文件中开启<cache><br>在配置文件中设置cacheEnabled为true<br>数据库<br>事务的四个基本特性<br>① Atomic（原子性）：事务中包含的操作被看做一个逻辑单元，这个逻辑单元中的操作要么全部成 功，要么全部失败。</cache></p></li></ol><p>② Consistency（一致性）：事务完成时，数据必须处于一致状态，数据的完整性约束没有被破坏，事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没    有执行过一样。</p><p>③ Isolation（隔离性）：事务允许多个用户对同一个数据进行并发访问，而不破坏数据的正确性 和完整性。同时，并行事务的修改必须与其他并行事务的修改相互独立。</p><p> ④Durability（持久性）：事务结束后，事务处理的结果必须能够得到固化。<br>并行事务的四大问题：<br>    1.更新丢失：和别的事务读到相同的东西，各自写，自己的写被覆盖了。（谁写的快谁的更新就丢失了）<br>    2.脏读：读到别的事务未提交的数据。（万一回滚，数据就是脏的无效的了）<br>    3.不可重复读：两次读之间有别的事务修改。<br>    4.幻读：两次读之间有别的事务增删。<br>事务隔离级别<br>1、    读未提交。最低的隔离级别（是一种危险的隔离级别，会出现脏读），其含义是允许一个事务读取另外一个事务没有提交的数据。<br>原理：<br>1，事务对当前被读取的数据不加锁；<br>2，事务在更新某数据的瞬间（就是发生更新的瞬间），必须先对其加行级共享锁，直到事务结束才释放。<br>2、    读已提交。 指一个事务只能读取到另外一个事务已经提交的数据。<br>原理:<br>1，事务对当前被读取的数据加 行级共享锁（当读到时才加锁），一旦读完该行，立即释放该行级共享锁；<br>2，事务在更新某数据的瞬间（就是发生更新的瞬间），必须先对其加 行级排他锁，直到事务结束才释放。<br>3、    可重复读。 克服读写提交中出现的不可复读的现象，因为在读写提交的时候，可能出现一些值的变化，影响当前事务的执行。<br>原理:<br>1，事务在读取某数据的瞬间（就是开始读取的瞬间），必须先对其加 行级共享锁，直到事务结束才释放；<br>2，事务在更新某数据的瞬间（就是发生更新的瞬间），必须先对其加 行级排他锁，直到事务结束才释放。<br>4、    串行化     最高的隔离级别，会要求所有的SQL按照顺序执行，这样就可以克服上述隔离级别出现的问题，所以能够保证数据的一致性。<br>原理:<br>1，事务在读取数据时，必须先对其加表级共享锁 ，直到事务结束才释放；<br>2，事务在更新数据时，必须先对其加表级排他锁 ，直到事务结束才释放。<br>锁可以分为<br>表级锁：开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高,并发度最低。<br>行级锁：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低,并发度也最高。<br>页面锁：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般。<br>锁根据模式分为<br>共享锁(S)：发生在数据查找之前，多个事务的共享锁之间可以共存</p><p>排他锁(X)：发生在数据更新之前，排他锁是一个独占锁，与其他锁都不兼容</p><p>更新锁(U)：发生在更新语句中，更新锁用来查找数据，当查找的数据不是要更新的数据时转化为S锁，当是要更新的数据时转化为X锁</p><p>意向锁：发生在较低粒度级别的资源获取之前，表示对该资源下低粒度的资源添加对应的锁，意向共享锁（IS）：事务打算给数据行加行共享锁，事务在给一个数据行加共享锁前必须先取得该表的IS锁。<br>意向排他锁（IX）：事务打算给数据行加行排他锁，事务在给一个数据行加排他锁前必须先取得该表的IX锁。</p><p>有两个事务，第一个线程事务需要往数据库中插入5条，另外一个事务插入第6条，当第一个事务没有提交前，第二的线程事务可以提交吗？<br>如果两个线程都插入第五条数据，第一个没有提交，第二个可以提交吗？<br>都可以<br>Mysql的存储引擎<br>1.InnoDB（MySQL默认存储引擎 从版本5.5.5开始）<br>支持事务，行级锁，以及外键，拥有高并发处理能力。但是在创建索引和加载数据时，比MyISAM慢。默认的隔离级别是Repeatable Read（可重复读）</p><p>2.MyISAM<br>不支持事务和行级锁。所以速度很快，性能优秀。可以对整张表加锁，支持并发插入，支持全文索引。</p><p>3.MEMORY<br>支持Hash索引，内存表，Memory引擎将数据存储在内存中，表结构不是存储在内存中的，查询时不需要执行磁盘I/O操作，所以要比MyISAM和InnoDB快很多倍，但是数据库断电或是重启后，表中的数据将会丢失，表结构不会丢失。<br>Mysql的分页查询如何写。<br>使用limit<br>数据库调优如何做。最佳调优方式。（SQL调优）<br>1、缓存，应用系统将常被访问的数据，放在缓存里，减少对数据库的访问频率<br>2、如果确定知道访问几条数据，则用Limit<br>3、确定选那几列数据的时候，不要用select *<br>4、主键最好是int，推荐使用unsigned(&gt;=0的int)，并将其设置为自动增加auto_increment。<br>5、对于固定值的数据，用int（enum），不要用varchar,比如性别。增加应用系统的计算量，但是可以大大减少数据库的负载<br>6、尽可能的使用not null。除非你有一个很特别的原因要去使用null值。<br>7、存储引擎：MyIsam,适合大应用的查询，是表锁，所以在更新写的时候比较慢；innodb适合事务，是行锁，不适合高效率的查询。MyISAM适合SELECT密集型的表，而InnoDB适合INSERT和UPDATE密集型的表<br>8、建立合适的索引<br>9、架构方面，考虑：主从复制；读写分离；分库分表<br>数据库分库分表如何操作<br>一般就是垂直切分和水平切分，这是一种结果集描述的切分方式，是物理空间上的切分。如果是因为表多而数据多，使用垂直切分，根据业务切分成不同的库。如果是因为单张表的数据量太大，这时要用水平切分，即把表的数据按某种规则切分成多张表，甚至多个库上的多张表。 分库分表的顺序应该是先垂直分，后水平分。</p><p>消息中间件有了解<br>具体做过的项目，项目的背景是什么，具体要解决什么问题，主要负责哪方面。</p><p>分布式<br>分布式事务<br>保持一致性<br>CAP原理：<br>一致性：在分布式系统中的所有数据备份，在同一时刻具有同样的值，所有的节点在同一时刻读取的数据都是最新的数据副本。<br>可用性：在任何故障模型下，服务都会在有限的时间内处理完成并进行响应<br>分区容忍性：尽管网络上有部分消息丢失，但系统仍然可以继续工作<br>任何分布式系统只可以同时满足以上两点，分布式系统都需要满足分区容错性。<br>BASE（碱）<br>解决了CAP提出的分布式系统的一致性和不可用性不可兼得的问题。通过牺牲强一致性来获得可用性，通过达到最终一致性来尽量满足业务的需求。<br>包括三个元素：<br>BA：基本可用<br>S：软引用，状态可以在一段时间内不同步<br>E：最终一致性，在一定的时间窗口内，最终达到数据一致即可。<br>分布式事务一致性协议（两段提交协议，三段提交协议，阿里的TCC）<br>1、    两阶段提交协议（分为准备阶段和提交阶段，可以保证强一致性，但会存在阻塞，单点故障，脑裂）<br>准备阶段：事务管理器向资源管理器发起指令，资源管理器评估自己的状态，如果资源管理器评估指令可以完成，则会写redo日志（写前日志），然后锁定资源，执行操作，但是并不提交。<br>提交阶段：如果每个资源管理器明确返回准备成功，也就是预留资源和执行操作成功，则事务管理器向资源管理器发起提交指令，资源管理器提交资源变更的事务，释放锁定的资源；如果任何一个资源管理器明确返回准备失败，事务管理器发起中止指令，资源管理器取消已经变更的事务，执行日志，释放锁定的资源。<br>2、    三段提交协议（通过超时机制解决了阻塞的问题，分为询问阶段，准备阶段，提交阶段）<br>询问阶段：事务管理器询问资源管理器是否可以完成指令，事务管理器只需要回答是或者不是，而不需要做真正的操作，这个阶段超时会导致中止；<br>准备阶段和提交阶段和两段提交协议相似。<br>3、    TCC协议，将一个任务拆分成Try，Confirm，Cancel三个步骤，正常的流程会先执行try，如果执行没有问题，则执行Confirm，如果执行过程中出现了问题，则执行操作的逆操作Cancel，达到最终一致性状态。<br>缓存一致性（消息队列）<br>使用缓存来抗住读流量<br>如果性能要求不是很高，尽量使用分布式缓存，而不要使用本地缓存。<br>写缓存时数据一定要完整，如果缓存数据的一部分有效，另一部分无效，宁可去查询数据库，也不要把部分数据放入缓存中<br>使用缓存牺牲了一致性，为了提高性能，数据库与缓存只需要保持弱一致性，而不需要保持强一致性。<br>读的顺序是先读缓存，后读数据库，写的顺序需要先写数据库，后写缓存。<br>什么是Restful风格，什么是restful样式的API<br>它纯粹面向资源，面向服务的思想<br>RPC：远程服务调用<br>JDK RMI<br>一个java进程内的服务调用其他java进程内的服务，使用JDK内置的序列化和反序列化协议，但是RMI采用JDK自带的专用序列化协议，不能跨语言，使用了底层的网络协议，不如基于文本的http可读和广泛认可。<br>Hessian及Buriap（远程调用协议，基于http传输）<br>Hessian将对象序列化成二进制协议，Buriap将对象序列化成xml数据，<br>Hessian及Buriap都适合于传输较小的对象，对较大、复杂的对象，无论是在序列化方式上和传输通道上都没有RMI有优势。<br>由于服务化框架中大量的服务调用都是大规模的、高并发的短小请求，因此Hessian和Buriap协议在服务化架构中得到广泛应用。<br>Spring Http Invoker<br>重用了jdk内置的对象序列化技术传输对象，与RMI原理一致，他通过http通道传输数据，在效率上稍微低于RMI，并且使用了JDK内置的序列化机制，不能跨语言。<br>SOA（服务化）<br>Dubbo（分布式服务框架）<br>提供了高性能和透明化的RPC远程服务调用，基本的服务监控、服务治理和服务调度等功能，支持多种序列化协议和通信编码协议，默认使用Dubbo协议传输Hessian序列化的数据（二进制），Dubbo使用ZooKeeper作为注册中心来注册和发现服务，并通过客户端负载均衡来路由请求，负载均衡包括：随机、轮询、最少活跃调用数，一致性哈希。<br>HSF（High Speed Framework）<br>淘宝使用的高性能服务框架（分布式服务框架），以高性能的网络通信框架为基础（未开源）<br>Thrift<br>Facebook实现的一种高性能且支持多种语言的远程服务调用框架，传输数据时采用二进制序列化格式，相对于JDK本身的序列化、xml和json等需要的内存更小。<br>Mule ESB<br>企业服务总线产品，可以把多个复杂的异构系统通过总线模式集成在一起，并且让他们可以互相通信。</p><p>微服务<br>Spring Boot<br>可以创建独立、自启动的应用程序<br>不需要构建war包并发布到容器中<br>通过Maven定制化标签，快速创建Spring Boot应用程序<br>没有xml配置，不需要代码生成<br>Netfilt<br>合并到Spring Cloud项目中，主要提供服务发现、断路器和监控、智能路由、客户端负载均衡、易用的REST客户端等服务化必须的功能。<br>Hystrix框架提供了微服务架构所需的容错机制的解决方案和设计模式，大大简化了微服务下容错机制的实现，包括服务分组和隔离、熔断和防止级联失败、限流机制、失效转移机制和监控机制等。<br>Spring Cloud<br>集成了spring boot对微服务敏捷启动和发布的功能，以及Netflix提供微服务化管理和治理能力。<br>微服务特点：<br>将传统单体应用拆分成网络服务，来实现模块化组件<br>根据微服务架构的服务划分来分组职能团队，减少跨团队的沟通<br>每个服务对应一个团队，团队成员负责各自的任务。<br>去中心化，去SOA服务化的中心服务治理和去企业化服务的总线<br>微服务重视服务的合理拆分、分层和构造，可建设自动化持续发布平台，并进行敏捷开发和部署。<br>具备兼容性设计、容错性设计和服务的契约设计<br>微服务中，每一个组负责一项特定的功能，要做到数据统一就得做数据库的拆分（分库分表），把编译好的代码放到一个环境中形成一个镜像，然后把镜像放到服务端的docker（一个应用容器的引擎，采用沙箱模式，相互间不会有任何接口）运行环境中。</p><p>消息中间件<br>主要解决应用耦合，异步消息，流量削锋等问题<br>实现高性能，高可用，可伸缩和最终一致性架构<br>使用较多的消息队列有ActiveMQ，RabbitMQ，ZeroMQ，Kafka，MetaMQ，RocketMQ<br>二、消息队列应用场景<br>以下介绍消息队列在实际应用中常用的使用场景。异步处理，应用解耦，流量削锋和消息通讯四个场景</p><p>关注于数据的发送和接收，利用高效可靠的异步消息传递机制集成分布式系统。<br>优点<br>①     解耦 ② 异步 ③ 横向扩展 ④ 安全可靠 ⑤ 顺序保证（比如kafka）</p><p>消息中间件适用于需要可靠的数据传送的分布式环境。采用消息中间件机制的系统中，不同的对象之间通过传递消息来激活对方的事件，完成相应的操作。发送者将消息发送给消息服务器，消息服务器将消息存放在若干队列中，在合适的时候再将消息转发给接收者。消息中间件能在不同平台之间通信，它常被用来屏蔽掉各种平台及协议之间的特性，实现应用程序之间的协同，其优点在于能够在客户和服务器之间提供同步和异步的连接，并且在任何时刻都可以将消息进行传送或者存储转发，这也是它比远程过程调用更进一步的原因。</p><p>消息队列应用的场景<br>消息队列技术是分布式应用间交换信息的一种技术。消息队列可驻留在内存或磁盘上,队列存储消息直到它们被应用程序读走。通过消息队列，应用程序可独立地执行–它们不需要知道彼此的位置、或在继续执行前不需要等待接收程序接收此消息</p><ol><li>业务解耦：消息队列要解决的最本质问题，实现设计的单一性原则，不耦合其他模块的业务。</li><li>最终一致性：用来处理延迟不那么敏感的“分布式事务”场景或者不重要的业务。</li><li>广播：下游有很多系统关心你的系统发出的通知的时候。</li><li>错峰和流控：上下游系统处理能力存在差距的时候，利用消息队列做一个通用的“漏斗”。在下游有能力处理的时候，再进行分发。</li></ol><p>项目难点</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://picsum.photos/800/208&quot; alt&gt;&lt;br&gt;java和其他语言的区别和优势在哪？&lt;br&gt;（内存动态分配和垃圾收集技术）&lt;br&gt;C语言：贴近内存，运行极快，效率极高。但是他要进行指针和内存管理，指针可以直接操作内存，但是却没有做数组越界等检查，容易出错。而且自己申请的空间需要自己去释放。并且这些问题编译期间发现不了，运行时才会暴露。&lt;br&gt;C++：添加了面向对象的功能，兼容了c语言，加入了静态类型的检测，但是太复杂。&lt;br&gt;Java：摆脱了硬件平台的束缚，实现了垮平台。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="小结" scheme="ayjcsgm.github.io/tags/%E5%B0%8F%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>SQL优化</title>
    <link href="ayjcsgm.github.io/2019/10/15/SQL%E4%BC%98%E5%8C%96/"/>
    <id>ayjcsgm.github.io/2019/10/15/SQL优化/</id>
    <published>2019-10-15T08:29:36.000Z</published>
    <updated>2019-10-15T08:31:47.231Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://picsum.photos/800/207" alt><br>1.MySQL版本：<br>    5.x:<br>    5.0-5.1:早期产品的延续，升级维护<br>    5.4 - 5.x :  MySQL整合了三方公司的新存储引擎 （推荐5.5）<br>    <a id="more"></a><br>    安装：rpm -ivh rpm软件名<br>    如果安装时 与某个软件  xxx冲突，则需要将冲突的软件卸载掉：<br>        yun -y remove xxx<br>    安装时 有日志提示我们可以修改密码：/usr/bin/mysqladmin -u root password ‘new-password’</p><pre><code>注意：     如果提示“GPG keys...”安装失败，解决方案：        rpm -ivh rpm软件名  --force --nodoeps验证：mysqladmin --version启动mysql应用： service mysql start关闭： service mysql stop重启： service mysql restart在计算机reboot后 登陆MySQL :  mysql可能会报错：   &quot;/var/lib/mysql/mysql.sock不存在&quot;  --原因：是Mysql服务没有启动解决 ：  启动服务： 1.每次使用前 手动启动服务   /etc/init.d/mysql start           2.开机自启   chkconfig mysql on     ,  chkconfig mysql off        检查开机是否自动启动： ntsysv        给mysql 的超级管理员root 增加密码：/usr/bin/mysqladmin -u root password root登陆：mysql -u root -p数据库存放目录：ps -ef|grep mysql  可以看到：    数据库目录：     datadir=/var/lib/mysql     pid文件目录： --pid-file=/var/lib/mysql/bigdata01.pid    MySQL核心目录：        /var/lib/mysql :mysql 安装目录        /usr/share/mysql:  配置文件        /usr/bin：命令目录（mysqladmin、mysqldump等）        /etc/init.d/mysql启停脚本  MySQL配置文件         my-huge.cnf    高端服务器  1-2G内存         my-large.cnf   中等规模         my-medium.cnf  一般         my-small.cnf   较小        但是，以上配置文件mysql默认不能识别，默认只能识别 /etc/my.cnf        采用 my-huge.cnf ：        cp /usr/share/mysql/my-huge.cnf /etc/my.cnf        注意：mysql5.5默认配置文件/etc/my.cnf；Mysql5.6 默认配置文件/etc/mysql-default.cnf默认端口3306mysql字符编码：    sql  :  show variables like &apos;%char%&apos; ;    可以发现部分编码是 latin,需要统一设置为utf-8    设置编码：    vi /etc/my.cnf:    [mysql]    default-character-set=utf8    [client]    default-character-set=utf8    [mysqld]    character_set_server=utf8    character_set_client=utf8    collation_server=utf8_general_ci重启Mysql:  service mysql restart    sql  :  show variables like &apos;%char%&apos; ;注意事项：修改编码 只对“之后”创建的数据库生效，因此 我们建议 在mysql安装完毕后，第一时间 统一编码。mysql:清屏    ctrl+L    , system clear</code></pre><p>2.原理<br>      MYSQL逻辑分层 ：连接层 服务层 引擎层 存储层</p><pre><code>  InnoDB(默认) ：事务优先 （适合高并发操作；行锁）  MyISAM ：性能优先  （表锁）查询数据库引擎：  支持哪些引擎？ show engines ;        查看当前使用的引擎   show variables like &apos;%storage_engine%&apos; ;指定数据库对象的引擎：create table tb(    id int(4) auto_increment ,    name varchar(5),    dept varchar(5) ,    primary key(id)        )ENGINE=MyISAM AUTO_INCREMENT=1 DEFAULT CHARSET=utf8   ;</code></pre><p>3.SQL优化<br>    原因：性能低、执行时间太长、等待时间太长、SQL语句欠佳（连接查询）、索引失效、服务器参数设置不合理（缓冲、线程数）</p><pre><code>a.SQL ：    编写过程：        select dinstinct  ..from  ..join ..on ..where ..group by ...having ..order by ..limit ..    解析过程：                    from .. on.. join ..where ..group by ....having ...select dinstinct ..order by limit ...b.SQL优化， 主要就是 在优化索引    索引： 相当于书的目录    索引： index是帮助MYSQL高效获取数据的数据结构。索引是数据结构（树：B树(默认)、Hash树...）    索引的弊端：        1.索引本身很大， 可以存放在内存/硬盘（通常为 硬盘）        2.索引不是所有情况均适用： a.少量数据  b.频繁更新的字段   c.很少使用的字段        3.索引会降低增删改的效率（增删改  查）    优势：1提高查询效率（降低IO使用率）          2.降低CPU使用率 （...order by age desc,因为 B树索引 本身就是一个 好排序的结构，因此在排序时  可以直接使用）</code></pre><p><a href="https://www.cnblogs.com/annsshadow/p/5037667.html" target="_blank" rel="noopener">https://www.cnblogs.com/annsshadow/p/5037667.html</a></p><p>4.索引<br>    分类：<br>        主键索引：  不能重复。id    不能是null<br>        唯一索引  ：不能重复。id    可以是null<br>        单值索引  ： 单列， age ;一个表可以多个单值索引,name。<br>        复合索引  ：多个列构成的索引 （相当于 二级目录 ：  z: zhao）  (name,age)   (a,b,c,d,…,n)<br>    创建索引：<br>        方式一：<br>        create 索引类型  索引名  on 表(字段)<br>        单值：<br>        create index   dept_index on  tb(dept);<br>        唯一：<br>        create unique index  name_index on tb(name) ;<br>        复合索引<br>        create index dept_name_index on tb(dept,name);</p><pre><code>方式二：alter table 表名 索引类型  索引名（字段）单值：alter table tb add index dept_index(dept) ;唯一：alter table tb add unique index name_index(name);复合索引alter table tb add index dept_name_index(dept,name);注意：如果一个字段是primary key，则改字段默认就是 主键索引    删除索引：drop index 索引名 on 表名 ;drop index name_index on tb ;查询索引：show index from 表名 ;show index from 表名 \G</code></pre><p>5.SQL性能问题<br>    a.分析SQL的执行计划  : explain   ，可以模拟SQL优化器执行SQL语句，从而让开发人员 知道自己编写的SQL状况<br>    b.MySQL查询优化其会干扰我们的优化</p><pre><code>优化方法，官网：https://dev.mysql.com/doc/refman/5.5/en/optimization.html查询执行计划：  explain +SQL语句        explain  select  * from tb ;</code></pre><p> id : 编号<br> select_type ：查询类型<br> table ：表<br> type   ：类型<br> possible_keys ：预测用到的索引<br> key  ：实际使用的索引<br> key_len ：实际使用索引的长度<br> ref  :表之间的引用<br> rows ：通过索引查询到的数据量<br> Extra     :额外的信息</p><p>准备数据：<br>create table course<br>(<br>cid int(3),<br>cname varchar(20),<br>tid int(3)<br>);<br>create table teacher<br>(<br>tid int(3),<br>tname varchar(20),<br>tcid int(3)<br>);</p><p>create table teacherCard<br>(<br>tcid int(3),<br>tcdesc varchar(200)<br>);</p><p>insert into course values(1,’java’,1);<br>insert into course values(2,’html’,1);<br>insert into course values(3,’sql’,2);<br>insert into course values(4,’web’,3);</p><p>insert into teacher values(1,’tz’,1);<br>insert into teacher values(2,’tw’,2);<br>insert into teacher values(3,’tl’,3);</p><p>insert into teacherCard values(1,’tzdesc’) ;<br>insert into teacherCard values(2,’twdesc’) ;<br>insert into teacherCard values(3,’tldesc’) ;</p><p>查询课程编号为2  或 教师证编号为3  的老师信息<br>explain +sql:<br>(1)id: id值相同，从上往下 顺序执行。  t3-tc3-c4</p><pre><code>tc3--c4-t6</code></pre><p>表的执行顺序  因数量的个数改变而改变的原因： 笛卡儿积</p><pre><code>a      b       c4    3     2   =              2*3=6 * 4   =24                        3*4=12* 2   =24</code></pre><p>数据小的表 优先查询；</p><p>id值不同：id值越大越优先查询 (本质：在嵌套子查询时，先查内层 再查外层)</p><p>查询教授SQL课程的老师的描述（desc）<br>explain select tc.tcdesc from teacherCard tc,course c,teacher t where c.tid = t.tid<br>and t.tcid = tc.tcid and c.cname = ‘sql’ ;</p><p>将以上 多表查询 转为子查询形式：</p><p>explain select tc.tcdesc from teacherCard tc where tc.tcid =<br>(select t.tcid from teacher t where  t.tid =<br>    (select c.tid from course c where c.cname = ‘sql’)<br>);</p><p>子查询+多表：<br>explain select t.tname ,tc.tcdesc from teacher t,teacherCard tc where t.tcid= tc.tcid<br>and t.tid = (select c.tid from course c where cname = ‘sql’) ;</p><p>id值有相同，又有不同： id值越大越优先；id值相同，从上往下 顺序执行</p><p>(2)select_type:查询类型<br>PRIMARY:包含子查询SQL中的 主查询 （最外层）<br>SUBQUERY：包含子查询SQL中的 子查询 （非最外层）<br>simple:简单查询（不包含子查询、union）<br>derived:衍生查询(使用到了临时表)<br>    a.在from子查询中只有一张表<br>        explain select  cr.cname     from ( select * from course where tid in (1,2) ) cr ;</p><pre><code>b.在from子查询中， 如果有table1 union table2 ，则table1 就是derived,table2就是union    explain select  cr.cname     from ( select * from course where tid = 1  union select * from course where tid = 2 ) cr ;</code></pre><p>union:上例<br>union result :告知开发人员，那些表之间存在union查询</p><p>system &gt; const &gt; eq_ref &gt; ref &gt; fulltext &gt; ref_or_null &gt; index_merge &gt; unique_subquery &gt; index_subquery &gt; range &gt; index &gt; ALL</p><p>(3)type:索引类型、类型<br>    system&gt;const&gt;eq_ref&gt;ref&gt;range&gt;index&gt;all   ，要对type进行优化的前提：有索引</p><p>其中：system,const只是理想情况；实际能达到 ref&gt;range</p><p>system（忽略）: 只有一条数据的系统表 ；或 衍生表只有一条数据的主查询</p><p>create table test01<br>(<br>    tid int(3),<br>    tname varchar(20)<br>);</p><p>insert into test01 values(1,’a’) ;<br>commit;<br>增加索引<br>alter table test01 add constraint tid_pk primary key(tid) ;<br>explain select * from (select * from test01 )t where tid =1 ;</p><p>const:仅仅能查到一条数据的SQL ,用于Primary key 或unique索引  （类型 与索引类型有关）<br>explain select tid from test01 where tid =1 ;<br>alter table test01 drop primary key ;<br>create index test01_index on test01(tid) ;</p><p>eq_ref:唯一性索引：对于每个索引键的查询，返回匹配唯一行数据（有且只有1个，不能多 、不能0）<br>select … from ..where name = … .常见于唯一索引 和主键索引。</p><p> alter table teacherCard add constraint pk_tcid primary key(tcid);<br>alter table teacher add constraint uk_tcid unique index(tcid) ;</p><p>explain select t.tcid from teacher t,teacherCard tc where t.tcid = tc.tcid ;</p><p>以上SQL，用到的索引是 t.tcid,即teacher表中的tcid字段；<br>如果teacher表的数据个数 和 连接查询的数据个数一致（都是3条数据），则有可能满足eq_ref级别；否则无法满足。</p><p>ref：非唯一性索引，对于每个索引键的查询，返回匹配的所有行（0，多）<br>准备数据：<br> insert into teacher values(4,’tz’,4) ;<br> insert into teacherCard values(4,’tz222’);</p><p>测试：<br>alter table teacher add index index_name (tname) ;<br>explain select * from teacher     where tname = ‘tz’;</p><p>range：检索指定范围的行 ,where后面是一个范围查询(between   ,&gt; &lt; &gt;=,     特殊:in有时候会失效 ，从而转为 无索引all)<br>alter table teacher add index tid_index (tid) ;<br>explain select t.* from teacher t where t.tid in (1,2) ;<br>explain select t.* from teacher t where t.tid &lt;3 ;</p><p>index：查询全部索引中数据<br>explain select tid from teacher ; –tid 是索引， 只需要扫描索引表，不需要所有表中的所有数据</p><p>all：查询全部表中的数据<br>explain select cid from course ;  –cid不是索引，需要全表所有，即需要所有表中的所有数据</p><p>system/const: 结果只有一条数据<br>eq_ref:结果多条；但是每条数据是唯一的 ；<br>ref：结果多条；但是每条数据是是0或多条 ；</p><p>（4）possible_keys ：可能用到的索引，是一种预测，不准。</p><p>alter table  course add index cname_index (cname);</p><p>explain select t.tname ,tc.tcdesc from teacher t,teacherCard tc<br> where t.tcid= tc.tcid<br>and t.tid = (select c.tid from course c where cname = ‘sql’) ;</p><p>如果 possible_key/key是NULL，则说明没用索引</p><p>explain select tc.tcdesc from teacherCard tc,course c,teacher t where c.tid = t.tid<br>and t.tcid = tc.tcid and c.cname = ‘sql’ ;</p><p>（5） key ：实际使用到的索引</p><p>（6）key_len ：索引的长度 ;<br>    作用：用于判断复合索引是否被完全使用  （a,b,c）。<br>create table test_kl<br>(<br>    name char(20) not null default ‘’<br>);<br>alter table test_kl add index index_name(name) ;<br>explain select * from test_kl where name =’’ ;   – key_len :60<br>在utf8：1个字符站3个字节  </p><p>alter table test_kl add column name1 char(20) ;  –name1可以为null</p><p>alter table test_kl add index index_name1(name1) ;<br>explain select * from test_kl where name1 =’’ ;<br>–如果索引字段可以为Null,则会使用1个字节用于标识。</p><p>drop index index_name on test_kl ;<br>drop index index_name1 on test_kl ;</p><p>增加一个复合索引<br>alter table test_kl add index name_name1_index (name,name1) ; </p><p>explain select * from test_kl where name1 = ‘’ ; –121<br>explain select * from test_kl where name = ‘’ ; –60</p><p>varchar(20)<br>alter table test_kl add column name2 varchar(20) ; –可以为Null<br>alter table test_kl add index name2_index (name2) ;</p><p>explain select * from test_kl where name2 = ‘’ ;  –63<br>20*3=60 +  1(null)  +2(用2个字节 标识可变长度)  =63</p><p>utf8:1个字符3个字节<br>gbk:1个字符2个字节<br>latin:1个字符1个字节</p><p>(7) ref : 注意与type中的ref值区分。<br>    作用： 指明当前表所 参照的 字段。<br>        select ….where a.c = b.x ;(其中b.x可以是常量，const)</p><p>alter table course  add index tid_index (tid) ;</p><pre><code>explain select * from course c,teacher t where c.tid = t.tid  and t.tname =&apos;tw&apos; ;</code></pre><p>(8)rows: 被索引优化查询的 数据个数 (实际通过索引而查询到的 数据个数)<br>    explain select * from course c,teacher t  where c.tid = t.tid<br>    and t.tname = ‘tz’ ;</p><p>（9）Extra：<br>    (i).using filesort ： 性能消耗大；需要“额外”的一次排序（查询）  。常见于 order by 语句中。<br>排序：先查询</p><p>10个人 根据年龄排序。</p><p>create table test02<br>(<br>    a1 char(3),<br>    a2 char(3),<br>    a3 char(3),<br>    index idx_a1(a1),<br>    index idx_a2(a2),<br>    index idx_a3(a3)<br>);</p><p>explain select * from test02 where a1 =’’ order by a1 ;</p><p>a1:姓名  a2：年龄</p><p>explain select * from test02 where a1 =’’ order by a2 ; –using filesort<br>小结：对于单索引， 如果排序和查找是同一个字段，则不会出现using filesort；如果排序和查找不是同一个字段，则会出现using filesort；<br>    避免： where哪些字段，就order by那些字段2</p><p>复合索引：不能跨列（最佳左前缀）<br>drop index idx_a1 on test02;<br>drop index idx_a2 on test02;<br>drop index idx_a3 on test02;</p><p>alter table test02 add index idx_a1_a2_a3 (a1,a2,a3) ;<br>explain select *from test02 where a1=’’ order by a3 ;  –using filesort<br>explain select *from test02 where a2=’’ order by a3 ; –using filesort<br>explain select *from test02 where a1=’’ order by a2 ;<br>explain select *from test02 where a2=’’ order by a1 ; –using filesort<br>    小结：避免： where和order by 按照复合索引的顺序使用，不要跨列或无序使用。</p><pre><code>(ii). using temporary:性能损耗大 ，用到了临时表。一般出现在group by 语句中。explain select a1 from test02 where a1 in (&apos;1&apos;,&apos;2&apos;,&apos;3&apos;) group by a1 ;explain select a1 from test02 where a1 in (&apos;1&apos;,&apos;2&apos;,&apos;3&apos;) group by a2 ; --using temporary避免：查询那些列，就根据那些列 group by .(iii). using index :性能提升; 索引覆盖（覆盖索引）。原因：不读取原文件，只从索引文件中获取数据 （不需要回表查询）    只要使用到的列 全部都在索引中，就是索引覆盖using index例如：test02表中有一个复合索引(a1,a2,a3)    explain select a1,a2 from test02 where a1=&apos;&apos; or a2= &apos;&apos; ; --using index       drop index idx_a1_a2_a3 on test02;    alter table test02 add index idx_a1_a2(a1,a2) ;    explain select a1,a3 from test02 where a1=&apos;&apos; or a3= &apos;&apos; ;    如果用到了索引覆盖(using index时)，会对 possible_keys和key造成影响：    a.如果没有where，则索引只出现在key中；    b.如果有where，则索引 出现在key和possible_keys中。    explain select a1,a2 from test02 where a1=&apos;&apos; or a2= &apos;&apos; ;    explain select a1,a2 from test02  ;(iii).using where （需要回表查询）    假设age是索引列    但查询语句select age,name from ...where age =...,此语句中必须回原表查Name，因此会显示using where.explain select a1,a3 from test02 where a3 = &apos;&apos; ; --a3需要回原表查询(iv). impossible where ： where子句永远为false    explain select * from test02 where a1=&apos;x&apos; and a1=&apos;y&apos;  ;</code></pre><p>6.优化案例<br>    单表优化、两表优化、三表优化<br>    （1）单表优化<br>create table book<br>(<br>    bid int(4) primary key,<br>    name varchar(20) not null,<br>    authorid int(4) not null,<br>    publicid int(4) not null,<br>    typeid int(4) not null<br>);</p><p>insert into book values(1,’tjava’,1,1,2) ;<br>insert into book values(2,’tc’,2,1,2) ;<br>insert into book values(3,’wx’,3,2,1) ;<br>insert into book values(4,’math’,4,2,3) ;<br>commit;    </p><pre><code>查询authorid=1且 typeid为2或3的    bidexplain select bid from book where typeid in(2,3) and authorid=1  order by typeid desc ;(a,b,c)(a,b)优化：加索引alter table book add index idx_bta (bid,typeid,authorid);索引一旦进行 升级优化，需要将之前废弃的索引删掉，防止干扰。drop index idx_bta on book;根据SQL实际解析的顺序，调整索引的顺序：alter table book add index idx_tab (typeid,authorid,bid); --虽然可以回表查询bid，但是将bid放到索引中 可以提升使用using index ;再次优化（之前是index级别）：思路。因为范围查询in有时会实现，因此交换 索引的顺序，将typeid in(2,3) 放到最后。drop index idx_tab on book;alter table book add index idx_atb (authorid,typeid,bid);explain select bid from book where  authorid=1 and  typeid in(2,3) order by typeid desc ;--小结：    a.最佳做前缀，保持索引的定义和使用的顺序一致性  b.索引需要逐步优化  c.将含In的范围查询 放到where条件的最后，防止失效。本例中同时出现了Using where（需要回原表）; Using index（不需要回原表）：原因，where  authorid=1 and  typeid in(2,3)中authorid在索引(authorid,typeid,bid)中，因此不需要回原表（直接在索引表中能查到）；而typeid虽然也在索引(authorid,typeid,bid)中，但是含in的范围查询已经使该typeid索引失效，因此相当于没有typeid这个索引，所以需要回原表（using where）；例如以下没有了In，则不会出现using whereexplain select bid from book where  authorid=1 and  typeid =3 order by typeid desc ;还可以通过key_len证明In可以使索引失效。（2）两表优化</code></pre><p>create table teacher2<br>(<br>    tid int(4) primary key,<br>    cid int(4) not null<br>);</p><p>insert into teacher2 values(1,2);<br>insert into teacher2 values(2,1);<br>insert into teacher2 values(3,3);</p><p>create table course2<br>(<br>    cid int(4) ,<br>    cname varchar(20)<br>);</p><p>insert into course2 values(1,’java’);<br>insert into course2 values(2,’python’);<br>insert into course2 values(3,’kotlin’);<br>commit;</p><p>左连接：<br>    explain select *from teacher2 t left outer join course2 c<br>    on t.cid=c.cid where c.cname=’java’;</p><pre><code>索引往哪张表加？   -小表驱动大表                -索引建立经常使用的字段上 （本题 t.cid=c.cid可知，t.cid字段使用频繁，因此给该字段加索引） [一般情况对于左外连接，给左表加索引；右外连接，给右表加索引]小表：10大表：300where   小表.x 10 = 大表.y 300;  --循环了几次？10    大表.y 300=小表.x 10    --循环了300次小表:10大表:300select ...where 小表.x10=大表.x300 ;for(int i=0;i&lt;小表.length10;i++){    for(int j=0;j&lt;大表.length300;j++)    {        ...    }}select ...where 大表.x300=小表.x10 ;for(int i=0;i&lt;大表.length300;i++){    for(int j=0;j&lt;小表.length10;j++)    {        ...    }}</code></pre><p>–以上2个FOR循环，最终都会循环3000次；但是 对于双层循环来说：一般建议 将数据小的循环 放外层；数据大的循环放内存。</p><pre><code>--当编写 ..on t.cid=c.cid 时，将数据量小的表 放左边（假设此时t表数据量小）alter table teacher2 add index index_teacher2_cid(cid) ;alter table course2 add index index_course2_cname(cname);Using join buffer:extra中的一个选项，作用：Mysql引擎使用了 连接缓存。</code></pre><p>（3）三张表优化A B C<br>    a.小表驱动大表  b.索引建立在经常查询的字段上</p><p>示例：<br>create table test03<br>(<br>  a1 int(4) not null,<br>  a2 int(4) not null,<br>  a3 int(4) not null,<br>  a4 int(4) not null<br>);<br>alter table test03 add index idx_a1_a2_a3_4(a1,a2,a3,a4) ;</p><pre><code>explain select a1,a2,a3,a4 from test03 where a1=1 and a2=2 and a3=3 and a4 =4 ; --推荐写法，因为 索引的使用顺序（where后面的顺序） 和 复合索引的顺序一致explain select a1,a2,a3,a4 from test03 where a4=1 and a3=2 and a2=3 and a1 =4 ; --虽然编写的顺序 和索引顺序不一致，但是 sql在真正执行前 经过了SQL优化器的调整，结果与上条SQL是一致的。--以上 2个SQL，使用了 全部的复合索引explain select a1,a2,a3,a4 from test03 where a1=1 and a2=2 and a4=4 order by a3; --以上SQL用到了a1 a2两个索引，该两个字段 不需要回表查询using index ;而a4因为跨列使用，造成了该索引失效，需要回表查询 因此是using where；以上可以通过 key_len进行验证explain select a1,a2,a3,a4 from test03 where a1=1 and a4=4 order by a3; --以上SQL出现了 using filesort(文件内排序，“多了一次额外的查找/排序”) ：不要跨列使用( where和order by 拼起来，不要跨列使用)explain select a1,a2,a3,a4 from test03 where a1=1 and a4=4 order by a2 , a3; --不会using filesort--总结：i.如果 (a,b,c,d)复合索引  和使用的顺序全部一致(且不跨列使用)，则复合索引全部使用。如果部分一致(且不跨列使用)，则使用部分索引。select a,c where  a = and b= and d=     ii.where和order by 拼起来，不要跨列使用 using temporary:需要额外再多使用一张表. 一般出现在group by语句中；已经有表了，但不适用，必须再来一张表。</code></pre><p>解析过程：<br>from .. on.. join ..where ..group by ….having …select dinstinct ..order by limit …<br>    a.<br>        explain select * from test03 where a2=2 and a4=4 group by a2,a4 ;–没有using temporary<br>    b.<br>        explain select * from test03 where a2=2 and a4=4 group by a3 ;</p><p>7.避免索引失效的一些原则<br>    （1）复合索引<br>    a.复合索引，不要跨列或无序使用（最佳左前缀）<br>    (a,b,c)<br>    b.复合索引，尽量使用全索引匹配<br>    (a,b,c)<br>    （2）不要在索引上进行任何操作（计算、函数、类型转换），否则索引失效<br>        select ..where A.x = .. ;  –假设A.x是索引<br>        不要：select ..where A.x<em>3 = .. ;<br>        explain select * from book where authorid = 1 and typeid = 2 ;–用到了at2个索引<br>        explain select * from book where authorid = 1 and typeid</em>2 = 2 ;–用到了a1个索引<br>        explain select * from book where authorid<em>2 = 1 and typeid</em>2 = 2 ;—-用到了0个索引<br>        explain select * from book where authorid*2 = 1 and typeid = 2 ;—-用到了0个索引,原因：对于复合索引，如果左边失效，右侧全部失效。(a,b,c)，例如如果 b失效，则b c同时失效。</p><pre><code>     drop index idx_atb on book ;     alter table book add index idx_authroid (authorid) ;    alter table book add index idx_typeid (typeid) ;    explain select * from book where authorid*2 = 1 and typeid = 2 ;（3）复合索引不能使用不等于（!=  &lt;&gt;）或is null (is not null)，否则自身以及右侧所有全部失效。    复合索引中如果有&gt;，则自身和右侧索引全部失效。explain select * from book where authorid = 1 and typeid =2 ;-- SQL优化，是一种概率层面的优化。至于是否实际使用了我们的优化，需要通过explain进行推测。explain select * from book where authorid != 1 and typeid =2 ;explain select * from book where authorid != 1 and typeid !=2 ;体验概率情况(&lt; &gt; =)：原因是服务层中有SQL优化器，可能会影响我们的优化。drop index idx_typeid on book;drop index idx_authroid on book;alter table book add index idx_book_at (authorid,typeid);explain select * from book where authorid = 1 and typeid =2 ;--复合索引at全部使用explain select * from book where authorid &gt; 1 and typeid =2 ; --复合索引中如果有&gt;，则自身和右侧索引全部失效。explain select * from book where authorid = 1 and typeid &gt;2 ;--复合索引at全部使用----明显的概率问题---explain select * from book where authorid &lt; 1 and typeid =2 ;--复合索引at只用到了1个索引explain select * from book where authorid &lt; 4 and typeid =2 ;--复合索引全部失效--我们学习索引优化 ，是一个大部分情况适用的结论，但由于SQL优化器等原因  该结论不是100%正确。--一般而言， 范围查询（&gt; &lt;  in），之后的索引失效。（4）补救。尽量使用索引覆盖（using index）        （a,b,c）select a,b,c from xx..where a=  .. and b =.. ;(5) like尽量以“常量”开头，不要以&apos;%&apos;开头，否则索引失效select * from xx where name like &apos;%x%&apos; ; --name索引失效explain select * from teacher  where tname like &apos;%x%&apos;; --tname索引失效explain select * from teacher  where tname like &apos;x%&apos;;explain select tname from teacher  where tname like &apos;%x%&apos;; --如果必须使用like &apos;%x%&apos;进行模糊查询，可以使用索引覆盖 挽救一部分。（6）尽量不要使用类型转换（显示、隐式），否则索引失效explain select * from teacher where tname = &apos;abc&apos; ;explain select * from teacher where tname = 123 ;//程序底层将 123 -&gt; &apos;123&apos;，即进行了类型转换，因此索引失效（7）尽量不要使用or，否则索引失效explain select * from teacher where tname =&apos;&apos; or tcid &gt;1 ; --将or左侧的tname 失效。</code></pre><p>8.一些其他的优化方法<br>    （1）<br>    exist和in<br>    select ..from table where exist (子查询) ;<br>    select ..from table where 字段 in  (子查询) ;</p><pre><code>如果主查询的数据集大，则使用In   ,效率高。如果子查询的数据集大，则使用exist,效率高。    exist语法： 将主查询的结果，放到子查需结果中进行条件校验（看子查询是否有数据，如果有数据 则校验成功）  ，        如果 复合校验，则保留数据；select tname from teacher where exists (select * from teacher) ; --等价于select tname from teacherselect tname from teacher where exists (select * from teacher where tid =9999) ;in:select ..from table where tid in  (1,3,5) ;（2）order by 优化using filesort 有两种算法：双路排序、单路排序 （根据IO的次数）MySQL4.1之前 默认使用 双路排序；双路：扫描2次磁盘（1：从磁盘读取排序字段 ,对排序字段进行排序（在buffer中进行的排序）   2：扫描其他字段 ）    --IO较消耗性能MySQL4.1之后 默认使用 单路排序  ： 只读取一次（全部字段），在buffer中进行排序。但种单路排序 会有一定的隐患 （不一定真的是“单路|1次IO”，有可能多次IO）。原因：如果数据量特别大，则无法 将所有字段的数据 一次性读取完毕，因此 会进行“分片读取、多次读取”。    注意：单路排序 比双路排序 会占用更多的buffer。        单路排序在使用时，如果数据大，可以考虑调大buffer的容量大小：  set max_length_for_sort_data = 1024  单位byte如果max_length_for_sort_data值太低，则mysql会自动从 单路-&gt;双路   （太低：需要排序的列的总大小超过了max_length_for_sort_data定义的字节数）提高order by查询的策略：a.选择使用单路、双路 ；调整buffer的容量大小；b.避免select * ...  c.复合索引 不要跨列使用 ，避免using filesortd.保证全部的排序字段 排序的一致性（都是升序 或 降序）</code></pre><p>9.SQL排查 - 慢查询日志:MySQL提供的一种日志记录，用于记录MySQL种响应时间超过阀值的SQL语句 （long_query_time，默认10秒）<br>        慢查询日志默认是关闭的；建议：开发调优是 打开，而 最终部署时关闭。</p><pre><code>检查是否开启了 慢查询日志 ：   show variables like &apos;%slow_query_log%&apos; ;临时开启：    set global slow_query_log = 1 ;  --在内存种开启    exit    service mysql restart永久开启：    /etc/my.cnf 中追加配置：    vi /etc/my.cnf     [mysqld]    slow_query_log=1    slow_query_log_file=/var/lib/mysql/localhost-slow.log慢查询阀值：    show variables like &apos;%long_query_time%&apos; ;临时设置阀值：    set global long_query_time = 5 ; --设置完毕后，重新登陆后起效 （不需要重启服务）永久设置阀值：    /etc/my.cnf 中追加配置：    vi /etc/my.cnf     [mysqld]    long_query_time=3select sleep(4);select sleep(5);select sleep(3);select sleep(3);--查询超过阀值的SQL：  show global status like &apos;%slow_queries%&apos; ;(1)慢查询的sql被记录在了日志中，因此可以通过日志 查看具体的慢SQL。cat /var/lib/mysql/localhost-slow.log(2)通过mysqldumpslow工具查看慢SQL,可以通过一些过滤条件 快速查找出需要定位的慢SQLmysqldumpslow --helps：排序方式r:逆序l:锁定时间g:正则匹配模式        --获取返回记录最多的3个SQL    mysqldumpslow -s r -t 3  /var/lib/mysql/localhost-slow.log--获取访问次数最多的3个SQL    mysqldumpslow -s c -t 3 /var/lib/mysql/localhost-slow.log--按照时间排序，前10条包含left join查询语句的SQL    mysqldumpslow -s t -t 10 -g &quot;left join&quot; /var/lib/mysql/localhost-slow.log语法：    mysqldumpslow 各种参数  慢查询日志的文件</code></pre><p>10.分析海量数据</p><pre><code>a.模拟海量数据  存储过程（无return）/存储函数（有return）create database testdata ;use testdata</code></pre><p>create table dept<br>(<br>dno int(5) primary key default 0,<br>dname varchar(20) not null default ‘’,<br>loc varchar(30) default ‘’<br>)engine=innodb default charset=utf8;</p><p>create table emp<br>(<br>eid int(5) primary key,<br>ename varchar(20) not null default ‘’,<br>job varchar(20) not null default ‘’,<br>deptno int(5) not null default 0<br>)engine=innodb default charset=utf8;<br>    通过存储函数 插入海量数据：<br>    创建存储函数：<br>        randstring(6)  -&gt;aXiayx  用于模拟员工名称</p><pre><code>delimiter $ create function randstring(n int)   returns varchar(255) begin    declare  all_str varchar(100) default &apos;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ&apos; ;    declare return_str varchar(255) default &apos;&apos; ;    declare i int default 0 ;     while i&lt;n             do                                            set return_str = concat(  return_str,      substring(all_str,   FLOOR(1+rand()*52)   ,1)       );        set i=i+1 ;    end while ;    return return_str;end $ </code></pre><p>–如果报错：You have an error in your SQL syntax，说明SQL语句语法有错，需要修改SQL语句；</p><p> 如果报错This function has none of DETERMINISTIC, NO SQL, or READS SQL DATA in its declaration and binary logging is enabled (you <em>might</em> want to use the less safe log_bin_trust_function_creators variable)<br>    是因为 存储过程/存储函数在创建时 与之前的 开启慢查询日志冲突了<br>    解决冲突：<br>    临时解决( 开启log_bin_trust_function_creators )<br>        show variables like ‘%log_bin_trust_function_creators%’;<br>        set global log_bin_trust_function_creators = 1;<br>    永久解决：<br>    /etc/my.cnf<br>    [mysqld]<br>    log_bin_trust_function_creators = 1</p><pre><code>--产生随机整数create function ran_num() returns int(5)begin    declare i int default 0;    set i =floor( rand()*100 ) ;    return i ;end $--通过存储过程插入海量数据：emp表中  ，  10000,   100000create procedure insert_emp( in eid_start int(10),in data_times int(10))begin     declare i int default 0;    set autocommit = 0 ;    repeat        insert into emp values(eid_start + i, randstring(5) ,&apos;other&apos; ,ran_num()) ;        set i=i+1 ;        until i=data_times    end repeat ;    commit ;end $--通过存储过程插入海量数据：dept表中      create procedure insert_dept(in dno_start int(10) ,in data_times int(10))    begin        declare i int default 0;        set autocommit = 0 ;        repeat            insert into dept values(dno_start+i ,randstring(6),randstring(8)) ;            set i=i+1 ;            until i=data_times        end repeat ;    commit ;    end$--插入数据    delimiter ;     call insert_emp(1000,800000) ;    call insert_dept(10,30) ;b.分析海量数据:（1）profilesshow profiles ; --默认关闭show variables like &apos;%profiling%&apos;;set profiling = on ; show profiles  ：会记录所有profiling打开之后的  全部SQL查询语句所花费的时间。缺点：不够精确，只能看到 总共消费的时间，不能看到各个硬件消费的时间（cpu  io ）(2)--精确分析:sql诊断 show profile all for query 上一步查询的的Query_Id show profile cpu,block io for query 上一步查询的的Query_Id(3)全局查询日志 ：记录开启之后的 全部SQL语句。 （这次全局的记录操作 仅仅在调优、开发过程中打开即可，在最终的部署实施时 一定关闭）    show variables like &apos;%general_log%&apos;;    --执行的所有SQL记录在表中    set global general_log = 1 ;--开启全局日志    set global log_output=&apos;table&apos; ; --设置 将全部的SQL 记录在表中    --执行的所有SQL记录在文件中    set global log_output=&apos;file&apos; ;    set global general_log = on ;    set global general_log_file=&apos;/tmp/general.log&apos; ;    开启后，会记录所有SQL ： 会被记录 mysql.general_log表中。        select * from  mysql.general_log ;</code></pre><p>11.锁机制 ：解决因资源共享 而造成的并发问题。<br>    示例：买最后一件衣服X<br>    A:      X    买 ：  X加锁 -&gt;试衣服…下单..付款..打包 -&gt;X解锁<br>    B:    X       买：发现X已被加锁，等待X解锁，   X已售空</p><pre><code>分类：操作类型：    a.读锁（共享锁）： 对同一个数据（衣服），多个读操作可以同时进行，互不干扰。    b.写锁（互斥锁）： 如果当前写操作没有完毕（买衣服的一系列操作），则无法进行其他的读操作、写操作操作范围：    a.表锁 ：一次性对一张表整体加锁。如MyISAM存储引擎使用表锁，开销小、加锁快；无死锁；但锁的范围大，容易发生锁冲突、并发度低。    b.行锁 ：一次性对一条数据加锁。如InnoDB存储引擎使用行锁，开销大，加锁慢；容易出现死锁；锁的范围较小，不易发生锁冲突，并发度高（很小概率 发生高并发问题：脏读、幻读、不可重复度、丢失更新等问题）。    c.页锁        </code></pre><p>示例：</p><pre><code>（1）表锁 ：  --自增操作 MYSQL/SQLSERVER 支持；oracle需要借助于序列来实现自增</code></pre><p>create table tablelock<br>(<br>id int primary key auto_increment ,<br>name varchar(20)<br>)engine myisam;</p><p>insert into tablelock(name) values(‘a1’);<br>insert into tablelock(name) values(‘a2’);<br>insert into tablelock(name) values(‘a3’);<br>insert into tablelock(name) values(‘a4’);<br>insert into tablelock(name) values(‘a5’);<br>commit;</p><pre><code>增加锁：locak table 表1  read/write  ,表2  read/write   ,...查看加锁的表：show open tables ;会话：session :每一个访问数据的dos命令行、数据库客户端工具  都是一个会话===加读锁：    会话0：        lock table  tablelock read ;        select * from tablelock; --读（查），可以        delete from tablelock where id =1 ; --写（增删改），不可以        select * from emp ; --读，不可以        delete from emp where eid = 1; --写，不可以        结论1：        --如果某一个会话 对A表加了read锁，则 该会话 可以对A表进行读操作、不能进行写操作； 且 该会话不能对其他表进行读、写操作。        --即如果给A表加了读锁，则当前会话只能对A表进行读操作。    会话1（其他会话）：        select * from tablelock;   --读（查），可以        delete from tablelock where id =1 ; --写，会“等待”会话0将锁释放    会话1（其他会话）：        select * from emp ;  --读（查），可以        delete from emp where eno = 1; --写，可以        结论2：        --总结：            会话0给A表加了锁；其他会话的操作：a.可以对其他表（A表以外的表）进行读、写操作                            b.对A表：读-可以；  写-需要等待释放锁。    释放锁: unlock tables ;===加写锁：    会话0：        lock table tablelock write ;        当前会话（会话0） 可以对加了写锁的表  进行任何操作（增删改查）；但是不能 操作（增删改查）其他表    其他会话：        对会话0中加写锁的表 可以进行增删改查的前提是：等待会话0释放写锁</code></pre><p>MySQL表级锁的锁模式<br>MyISAM在执行查询语句（SELECT）前，会自动给涉及的所有表加读锁，<br>在执行更新操作（DML）前，会自动给涉及的表加写锁。<br>所以对MyISAM表进行操作，会有以下情况：<br>a、对MyISAM表的读操作（加读锁），不会阻塞其他进程（会话）对同一表的读请求，<br>但会阻塞对同一表的写请求。只有当读锁释放后，才会执行其它进程的写操作。<br>b、对MyISAM表的写操作（加写锁），会阻塞其他进程（会话）对同一表的读和写操作，<br>只有当写锁释放后，才会执行其它进程的读写操作。</p><p>分析表锁定：<br>    查看哪些表加了锁：   show open tables ;  1代表被加了锁<br>    分析表锁定的严重程度： show status like ‘table%’ ;<br>            Table_locks_immediate :即可能获取到的锁数<br>            Table_locks_waited：需要等待的表锁数(如果该值越大，说明存在越大的锁竞争)<br>    一般建议：<br>        Table_locks_immediate/Table_locks_waited &gt; 5000， 建议采用InnoDB引擎，否则MyISAM引擎</p><p>（2）行表（InnoDB）<br>create table linelock(<br>id int(5) primary key auto_increment,<br>name varchar(20)<br>)engine=innodb ;<br>insert into linelock(name) values(‘1’)  ;<br>insert into linelock(name) values(‘2’)  ;<br>insert into linelock(name) values(‘3’)  ;<br>insert into linelock(name) values(‘4’)  ;<br>insert into linelock(name) values(‘5’)  ;</p><p>–mysql默认自动commit;    oracle默认不会自动commit ;</p><p>为了研究行锁，暂时将自动commit关闭;  set autocommit =0 ; 以后需要通过commit</p><pre><code>会话0： 写操作    insert into linelock values(    &apos;a6&apos;) ;会话1： 写操作 同样的数据    update linelock set name=&apos;ax&apos; where id = 6;对行锁情况：    1.如果会话x对某条数据a进行 DML操作（研究时：关闭了自动commit的情况下），则其他会话必须等待会话x结束事务(commit/rollback)后  才能对数据a进行操作。    2.表锁 是通过unlock tables，也可以通过事务解锁 ; 行锁 是通过事务解锁。行锁，操作不同数据：会话0： 写操作    insert into linelock values(8,&apos;a8&apos;) ;会话1： 写操作， 不同的数据    update linelock set name=&apos;ax&apos; where id = 5;    行锁，一次锁一行数据；因此 如果操作的是不同数据，则不干扰。行锁的注意事项：a.如果没有索引，则行锁会转为表锁show index from linelock ;alter table linelock add index idx_linelock_name(name);会话0： 写操作    update linelock set name = &apos;ai&apos; where name = &apos;3&apos; ;会话1： 写操作， 不同的数据    update linelock set name = &apos;aiX&apos; where name = &apos;4&apos; ;会话0： 写操作    update linelock set name = &apos;ai&apos; where name = 3 ;会话1： 写操作， 不同的数据    update linelock set name = &apos;aiX&apos; where name = 4 ;--可以发现，数据被阻塞了（加锁）-- 原因：如果索引类 发生了类型转换，则索引失效。 因此 此次操作，会从行锁 转为表锁。b.行锁的一种特殊情况：间隙锁：值在范围内，但却不存在 --此时linelock表中 没有id=7的数据 update linelock set name =&apos;x&apos; where id &gt;1 and id&lt;9 ;   --即在此where范围中，没有id=7的数据，则id=7的数据成为间隙。间隙：Mysql会自动给 间隙 加索 -&gt;间隙锁。即 本题 会自动给id=7的数据加 间隙锁（行锁）。行锁：如果有where，则实际加索的范围 就是where后面的范围（不是实际的值）如何仅仅是查询数据，能否加锁？ 可以   for update 研究学习时，将自动提交关闭：    set autocommit =0 ;    start transaction ;    begin ; select * from linelock where id =2 for update ;通过for update对query语句进行加锁。行锁：InnoDB默认采用行锁；缺点： 比表锁性能损耗大。优点：并发能力强，效率高。因此建议，高并发用InnoDB，否则用MyISAM。行锁分析：  show status like &apos;%innodb_row_lock%&apos; ;     Innodb_row_lock_current_waits :当前正在等待锁的数量        Innodb_row_lock_time：等待总时长。从系统启到现在 一共等待的时间     Innodb_row_lock_time_avg  ：平均等待时长。从系统启到现在平均等待的时间     Innodb_row_lock_time_max  ：最大等待时长。从系统启到现在最大一次等待的时间     Innodb_row_lock_waits ：    等待次数。从系统启到现在一共等待的次数</code></pre><p>12.主从复制  （集群在数据库的一种实现）<br>    windows:mysql 主<br>    linux:mysql从</p><pre><code>安装windows版mysql:    如果之前计算机中安装过Mysql，要重新再安装  则需要：先卸载 再安装    先卸载：        通过电脑自带卸载工具卸载Mysql (电脑管家也可以)        删除一个mysql缓存文件C:\ProgramData\MySQL        删除注册表regedit中所有mysql相关配置        --重启计算机    安装MYSQL：        安装时，如果出现未响应：  则重新打开D:\MySQL\MySQL Server 5.5\bin\MySQLInstanceConfig.exe    图形化客户端： SQLyog, Navicat    如果要远程连接数据库，则需要授权远程访问。     授权远程访问 :(A-&gt;B,则再B计算机的Mysql中执行以下命令)    GRANT ALL PRIVILEGES ON *.* TO &apos;root&apos;@&apos;%&apos; IDENTIFIED BY &apos;root&apos; WITH GRANT OPTION;    FLUSH PRIVILEGES;    如果仍然报错：可能是防火墙没关闭 ：  在B关闭防火墙  service iptables stop 实现主从同步（主从复制）：图    1.master将改变的数 记录在本地的 二进制日志中（binary log） ；该过程 称之为：二进制日志件事    2.slave将master的binary log拷贝到自己的 relay log（中继日志文件）中    3.中继日志事件，将数据读取到自己的数据库之中MYSQL主从复制 是异步的，串行化的， 有延迟master:slave = 1:n配置： windows(mysql: my.ini)  linux(mysql: my.cnf)配置前，为了无误，先将权限(远程访问)、防火墙等处理：    关闭windows/linux防火墙： windows：右键“网络”   ,linux: service iptables stop    Mysql允许远程连接(windowos/linux)：        GRANT ALL PRIVILEGES ON *.* TO &apos;root&apos;@&apos;%&apos; IDENTIFIED BY &apos;root&apos; WITH GRANT OPTION;        FLUSH PRIVILEGES;</code></pre><p>主机（以下代码和操作 全部在主机windows中操作）：<br>my.ini<br>[mysqld]</p><p>#id<br>server-id=1</p><p>#二进制日志文件（注意是/  不是\）<br>log-bin=”D:/MySQL/MySQL Server 5.5/data/mysql-bin”</p><p>#错误记录文件<br>log-error=”D:/MySQL/MySQL Server 5.5/data/mysql-error”</p><p>#主从同步时 忽略的数据库<br>binlog-ignore-db=mysql</p><p>#(可选)指定主从同步时，同步哪些数据库<br>binlog-do-db=test    </p><p>windows中的数据库 授权哪台计算机中的数据库 是自己的从数据库：<br> GRANT REPLICATION slave,reload,super ON <em>.</em> TO ‘root’@’192.168.2.%’ IDENTIFIED BY ‘root’;<br> flush privileges ; </p><pre><code>查看主数据库的状态（每次在左主从同步前，需要观察 主机状态的最新值）    show master status;  （mysql-bin.000001、 107）</code></pre><p>从机（以下代码和操作 全部在从机linux中操作）：</p><p>my.cnf<br>[mysqld]<br>server-id=2<br>log-bin=mysql-bin<br>replicate-do-db=test</p><p>linux中的数据 授权哪台计算机中的数控 是自己的主计算机<br>CHANGE MASTER TO<br>MASTER_HOST = ‘192.168.2.2’,<br>MASTER_USER = ‘root’,<br>MASTER_PASSWORD = ‘root’,<br>MASTER_PORT = 3306,<br>master_log_file=’mysql-bin.000001’,<br>master_log_pos=107;<br>    如果报错：This operation cannot be performed with a running slave; run STOP SLAVE first<br>    解决：STOP SLAVE ;再次执行上条授权语句</p><p>开启主从同步：<br>    从机linux:<br>    start slave ;<br>    检验  show slave status \G    主要观察： Slave_IO_Running和 Slave_SQL_Running，确保二者都是yes；如果不都是yes，则看下方的 Last_IO_Error。<br>本次 通过 Last_IO_Error发现错误的原因是 主从使用了相同的server-id， 检查:在主从中分别查看serverid:  show variables like ‘server_id’ ;<br>    可以发现，在Linux中的my.cnf中设置了server-id=2，但实际执行时 确实server-id=1，原因：可能是 linux版Mysql的一个bug，也可能是 windows和Linux版本不一致造成的兼容性问题。<br>    解决改bug： set global server_id =2 ;</p><pre><code>stop slave ; set global server_id =2 ;start slave ; show slave status \G演示：主windows =&gt;从windows:将表，插入数据  观察从数据库中该表的数据</code></pre><p>数据库+后端</p><pre><code>spring boot（企业级框架,目前使用较多）  </code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://picsum.photos/800/207&quot; alt&gt;&lt;br&gt;1.MySQL版本：&lt;br&gt;    5.x:&lt;br&gt;    5.0-5.1:早期产品的延续，升级维护&lt;br&gt;    5.4 - 5.x :  MySQL整合了三方公司的新存储引擎 （推荐5.5）&lt;br&gt;
    
    </summary>
    
    
    
      <category term="SQL" scheme="ayjcsgm.github.io/tags/SQL/"/>
    
  </entry>
  
  <entry>
    <title>操作系统面试问题集锦</title>
    <link href="ayjcsgm.github.io/2019/10/04/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%E9%9B%86%E9%94%A6/"/>
    <id>ayjcsgm.github.io/2019/10/04/操作系统面试问题集锦/</id>
    <published>2019-10-04T13:36:07.000Z</published>
    <updated>2019-10-04T13:37:30.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://picsum.photos/800/206" alt><br> <strong>操作系统的组成</strong><br>1、<strong>驱动程序</strong>是最底层的、直接控制和监视各类硬件的部分，它们的职责是隐藏硬件的具体细节，并向其他部分提供一个抽象的、通用的接口。</p><p>2、<strong>内核</strong>是操作系统之最内核部分，通常运行在最高特权级，负责提供基础性、结构性的功能。</p><a id="more"></a><p>3、<strong>支承库</strong>是一系列特殊的程序库，它们职责在于把系统所提供的基本服务包装成应用程序所能够使用的编程接口（API），是最靠近应用程序的部分。例如，GNU C运行期库就属于此类，它把各种操作系统的内部编程接口包装成ANSI C和POSIX编程接口的形式。</p><p>4、<strong>外围</strong>是指操作系统中除以上三类以外的所有其他部分，通常是用于提供特定高级服务的部件。例如，在微内核结构中，大部分系统服务，以及UNIX/Linux中各种守护进程都通常被划归此列。</p><hr><p><strong>操作系统中的缓存</strong><br>缓存（cache），原始意义是指访问速度比一般随机存取存储器（RAM）快的一种高速存储器，可以进行高速数据交换的存储器，它先于内存与CPU交换数据。</p><hr><p><strong>进程和线程</strong><br><font color="red" size="3">定义： </font><br>　　<strong>进程</strong>是具有一定独立功能的程序关于某个数据集合上的一次运行活动,进程是系统进行资源分配和调度的一个独立单位.<br>　　<strong>线程</strong>是进程的一个实体,是CPU调度和分派的基本单位,它是比进程更小的能独立运行的基本单位.线程自己基本上不拥有系统资源,只拥有一点在运行中必不可少的资源(如程序计数器,一组寄存器和栈),但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源.<br>（1）进程是对运行时程序的封装,是系统进行资源调度和分配的基本单位,实现操作系统的并发。</p><p>（2）线程是进程的子任务,是CPU调度和分派的基本单位,用于保证程序的实时性,实现进程内部的并发。</p><p>（3）一个程序至少有一个进程,一个进程至少有一个线程,线程依赖进程的存在。</p><p>（4）进程执行过程中拥有独立的内存单元,而多个线程共享进程的内存。</p><hr><p><strong>进程间的通信的几种方式</strong></p><p><font color="red" size="3"> 管道（pipe）及命名管道（named pipe）： </font>管道可用于具有亲缘关系的父子进程间的通信，有名管道除了具有管道所具有的功能外，它还允许无亲缘关系进程间的通信；</p><p><font color="red" size="3"> 信号（signal）： </font>信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生；</p><p><font color="red" size="3"> 消息队列： </font>消息队列是消息的链接表，它克服了上两种通信方式中信号量有限的缺点，具有写权限得进程可以按照一定得规则向消息队列中添加新信息；对消息队列有读权限得进程则可以从消息队列中读取信息；</p><p><font color="red" size="3"> 共享内存： </font>可以说这是最有用的进程间通信方式。它使得多个进程可以访问同一块内存空间，不同进程可以及时看到对方进程中对共享内存中数据得更新。这种方式需要依靠某种同步操作，如互斥锁和信号量等；</p><p><font color="red" size="3"> 信号量： </font>主要作为进程之间及同一种进程的不同线程之间得同步和互斥手段；</p><p><font color="red" size="3"> 套接字： </font> 这是一种更为一般得进程间通信机制，它可用于网络中不同机器之间的进程间通信，应用非常广泛。<br><font color="red" size="3"> 几种方式的比较： </font><br>管道：速度慢、容量有限<br>消息队列：容量收到系统限制，且要注意第一次读的时候，要考虑上一次没有读完数据的问题。<br>信号量：不能传递复杂信息，只能用来同步。<br>共享内存：能够很容易控制容量，速度快，但要保持同步，比如一个进程在写的时候，另一个进程要注意读写的问题，相当于线程中的线程安全。</p><hr><p><strong>线程间通信</strong></p><p>(1)同步<br>多个线程通过synchronized通讯，类似于共享内存</p><p>(2)while轮询<br>线程A不断改变条件，线程B不断查看条件是否满足需求（比方说=5），从而实现通讯。<br>效率不高，因为B一直在查看，没做别的</p><p>(3)wait/notify<br>进入阻塞，而不是像轮询一样一直占用CPU资源</p><p>(4)管道通信<br>通过管道，将一个线程的消息发送个另一个线程</p><hr><p><strong>什么是死锁？死锁产生的条件？</strong></p><p>1). 死锁的概念</p><p>　　在两个或者多个并发进程中，如果每个进程持有某种资源而又等待其它进程释放它或它们现在保持着的资源，在未改变这种状态之前都不能向前推进，称这一组进程产生了死锁。通俗的讲，就是两个或多个进程无限期的阻塞、相互等待的一种状态。</p><p>2). 死锁产生的四个必要条件</p><ul><li><p><font color="red">互斥：</font>至少有一个资源必须属于非共享模式，即一次只能被一个进程使用；若其他申请使用该资源，那么申请进程必须等到该资源被释放为止；</p></li><li><p><font color="red">占有并等待：</font>一个进程必须占有至少一个资源，并等待另一个资源，而该资源为其他进程所占有；</p></li><li><p><font color="red">非抢占：</font>进程不能被抢占，即资源只能被进程在完成任务后自愿释放</p></li><li><p><font color="red">循环等待：</font>若干进程之间形成一种头尾相接的环形等待资源关系 </p></li></ul><p>3). 死锁的处理基本策略和常用方法</p><p>　　解决死锁的基本方法主要有 预防死锁、避免死锁、检测死锁、解除死锁 、鸵鸟策略 等。</p><p>　　(1). 死锁预防 <br>　　 <br>　　死锁预防的基本思想是<font color="red"> 只要确保死锁发生的四个必要条件中至少有一个不成立，就能预防死锁的发生</font>，具体方法包括：</p><ul><li><p>打破互斥条件：允许进程同时访问某些资源。但是，有些资源是不能被多个进程所共享的，这是由资源本身属性所决定的，因此，这种办法通常并无实用价值。</p></li><li><p>打破占有并等待条件：可以实行资源预先分配策略(进程在运行前一次性向系统申请它所需要的全部资源，若所需全部资源得不到满足，则不分配任何资源，此进程暂不运行；只有当系统能满足当前进程所需的全部资源时，才一次性将所申请资源全部分配给该线程)或者只允许进程在没有占用资源时才可以申请资源（一个进程可申请一些资源并使用它们，但是在当前进程申请更多资源之前，它必须全部释放当前所占有的资源）。但是这种策略也存在一些缺点：在很多情况下，无法预知一个进程执行前所需的全部资源，因为进程是动态执行的，不可预知的；同时，会降低资源利用率，导致降低了进程的并发性。</p></li><li><p>打破非抢占条件：允许进程强行从占有者哪里夺取某些资源。也就是说，但一个进程占有了一部分资源，在其申请新的资源且得不到满足时，它必须释放所有占有的资源以便让其它线程使用。这种预防死锁的方式实现起来困难，会降低系统性能。</p></li><li><p>打破循环等待条件：实行资源有序分配策略。对所有资源排序编号，所有进程对资源的请求必须严格按资源序号递增的顺序提出，即只有占用了小号资源才能申请大号资源，这样就不回产生环路，预防死锁的发生。</p></li></ul><p>　　(2). 死锁避免的基本思想 <br>　　 <br>　　死锁避免的基本思想是动态地检测资源分配状态，以确保循环等待条件不成立，从而确保系统处于安全状态。所谓安全状态是指：如果系统能按某个顺序为每个进程分配资源（不超过其最大值），那么系统状态是安全的，换句话说就是，如果存在一个安全序列，那么系统处于安全状态。资源分配图算法和银行家算法是两种经典的死锁避免的算法，其可以确保系统始终处于安全状态。其中，资源分配图算法应用场景为每种资源类型只有一个实例(申请边，分配边，需求边，不形成环才允许分配)，而银行家算法应用于每种资源类型可以有多个实例的场景。</p><p>　　(3). 死锁解除</p><p>　　死锁解除的常用两种方法为进程终止和资源抢占。所谓进程终止是指简单地终止一个或多个进程以打破循环等待，包括两种方式：终止所有死锁进程和一次只终止一个进程直到取消死锁循环为止；所谓资源抢占是指从一个或多个死锁进程那里抢占一个或多个资源，此时必须考虑三个问题：</p><p>　　(I). 选择一个牺牲品 <br>　　(II). 回滚：回滚到安全状态 <br>　　(III). 饥饿（在代价因素中加上回滚次数，回滚的越多则越不可能继续被作为牺牲品，避免一个进程总是被回滚）</p><hr><p><strong>进程有哪几种状态？</strong></p><ul><li><p>就绪状态：进程已获得除处理机以外的所需资源，等待分配处理机资源；</p></li><li><p>运行状态：占用处理机资源运行，处于此状态的进程数小于等于CPU数；</p></li><li><p>阻塞状态： 进程等待某种条件，在条件满足之前无法执行；</p><p>　　　　　　　　　　　　　<img src="https://imgconvert.csdnimg.cn/aHR0cDovLzViMDk4OGU1OTUyMjUuY2RuLnNvaHVjcy5jb20vaW1hZ2VzLzIwMTgxMTI4LzgyMDQxNTI5YWZkNDQ0ZGY5M2I2ZTJjY2I3YTY2OTU3LmpwZWc?x-oss-process=image/format,png" alt="在这里插入图片描述"></p></li></ul><hr><p><strong>线程有几种状态？</strong></p><p>1.&nbsp;<strong>新建(NEW)</strong>：新创建了一个线程对象。</p><p>2.&nbsp;<strong>可运行(RUNNABLE)</strong>：线程对象创建后，其他线程(比如main线程）调用了该对象的start()方法。该状态的线程位于可运行线程池中，等待被线程调度选中，获取cpu 的使用权 。</p><p>3.&nbsp;<strong>运行(RUNNING)</strong>：可运行状态(runnable)的线程获得了cpu 时间片（timeslice） ，执行程序代码。<br>4.&nbsp;<strong>阻塞(BLOCKED)</strong>：阻塞状态是指线程因为某种原因放弃了cpu 使用权，也即让出了cpu timeslice，暂时停止运行。直到线程进入可运行(runnable)状态，才有机会再次获得cpu timeslice 转到运行(running)状态。阻塞的情况分三种：&nbsp;</p><blockquote>(一). 等待阻塞：运行(running)的线程执行o.wait()方法，JVM会把该线程放入等待队列(waitting queue)中。<br>(二). 同步阻塞：运行(running)的线程在获取对象的同步锁时，若该同步锁被别的线程占用，则JVM会把该线程放入锁池(lock pool)中。<br>(三). 其他阻塞：运行(running)的线程执行Thread.sleep(long ms)或t.join()方法，或者发出了I/O请求时，JVM会把该线程置为阻塞状态。当sleep()状态超时、join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入可运行(runnable)状态。</blockquote><p>5.&nbsp;<strong>死亡(DEAD)</strong>：线程run()、main() 方法执行结束，或者因异常退出了run()方法，则该线程结束生命周期。死亡的线程不可再次复生。</p><p>在给定的时间点上，一个线程只能处于一种状态。</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9kbC5pdGV5ZS5jb20vdXBsb2FkL3BpY3R1cmUvcGljLzExNjcxOS83ZTc2Y2MxNy0wYWQ1LTNmZjMtOTU0ZS0xZjgzNDYzNTE5ZDEuanBn?x-oss-process=image/format,png" alt="在这里插入图片描述"></p><hr><p><strong>分页和分段有什么区别（内存管理）？</strong></p><p>　　段式存储管理是一种符合用户视角的内存分配管理方案。在段式存储管理中，将程序的地址空间划分为若干段（segment），如代码段，数据段，堆栈段；这样每个进程有一个二维地址空间，相互独立，互不干扰。段式管理的优点是：没有内碎片（因为段大小可变，改变段大小来消除内碎片）。但段换入换出时，会产生外碎片（比如4k的段换5k的段，会产生1k的外碎片）</p><p>　　页式存储管理方案是一种用户视角内存与物理内存相分离的内存分配管理方案。在页式存储管理中，将程序的逻辑地址划分为固定大小的页（page），而物理内存划分为同样大小的帧，程序加载时，可以将任意一页放入内存中任意一个帧，这些帧不必连续，从而实现了离散分离。页式存储管理的优点是：没有外碎片（因为页的大小固定），但会产生内碎片（一个页可能填充不满）。</p><p><font color="red"><b><strong>两者的不同点：</strong></b></font></p><ul><li><p><font color="red">目的不同：</font>分页是由于系统管理的需要而不是用户的需要，它是信息的物理单位；分段的目的是为了能更好地满足用户的需要，它是信息的逻辑单位，它含有一组其意义相对完整的信息；</p></li><li><p><font color="red">大小不同：</font>页的大小固定且由系统决定，而段的长度却不固定，由其所完成的功能决定；</p></li><li><p><font color="red">地址空间不同：</font> 段向用户提供二维地址空间；页向用户提供的是一维地址空间；</p></li><li><p><font color="red">信息共享：</font>段是信息的逻辑单位，便于存储保护和信息的共享，页的保护和共享受到限制；</p></li><li><p><font color="red">内存碎片：</font>页式存储管理的优点是没有外碎片（因为页的大小固定），但会产生内碎片（一个页可能填充不满）；而段式管理的优点是没有内碎片（因为段大小可变，改变段大小来消除内碎片）。但段换入换出时，会产生外碎片（比如4k的段换5k的段，会产生1k的外碎片）。</p></li></ul><hr><p><strong>操作系统中进程调度策略有哪几种？</strong></p><ul><li><p><font color="red">FCFS(先来先服务，队列实现，非抢占的)：</font>先请求CPU的进程先分配到CPU</p></li><li><p><font color="red">SJF(最短作业优先调度算法)：</font>平均等待时间最短，但难以知道下一个CPU区间长度</p></li><li><p><font color="red">优先级调度算法(可以是抢占的，也可以是非抢占的)：</font>优先级越高越先分配到CPU，相同优先级先到先服务，存在的主要问题是：低优先级进程无穷等待CPU，会导致无穷阻塞或饥饿；解决方案：<font color="red"><b>老化</b></font></p></li><li><p><font color="red">时间片轮转调度算法(可抢占的)：</font>队列中没有进程被分配超过一个时间片的CPU时间，除非它是唯一可运行的进程。如果进程的CPU区间超过了一个时间片，那么该进程就被抢占并放回就绪队列。</p></li><li><p><font color="red">多级队列调度算法：</font>将就绪队列分成多个独立的队列，每个队列都有自己的调度算法，队列之间采用固定优先级抢占调度。其中，一个进程根据自身属性被永久地分配到一个队列中。</p></li><li><p><font color="red">多级反馈队列调度算法：</font>与多级队列调度算法相比，其允许进程在队列之间移动：若进程使用过多CPU时间，那么它会被转移到更低的优先级队列；在较低优先级队列等待时间过长的进程会被转移到更高优先级队列，以防止饥饿发生。</p></li></ul><hr><p><strong>进程同步与互斥</strong></p><p><strong>互斥</strong>：指某一个资源同时只允许一个访问者对其进行访问，具有唯一性和排它性。但互斥无法限制访问者对资源的访问顺序，即访问是无序的<br><strong>同步</strong>：是指在互斥的基础上（大多数情况下），通过其它机制实现访问者对资源的有序访问。大多数情况下，同步已经实现了互斥，特别是所有写入资源的情况必定是互斥的。少数情况是指可以允许多个访问者同时访问资源。<br>同步：体现的是一种协作性。互斥：体现的是排它性。 </p><hr><p>　<strong>进程同步有哪几种机制:</strong></p><p>1.<strong>信号量机制</strong><br>一个信号量只能置一次初值，以后只能对之进行p操作或v操作。 由此也可以看到，信号量机制必须有公共内存，不能用于分布式操作系统，这是它最大的弱点。 </p><p>2.<strong>自旋锁</strong></p><p>旋锁是为了保护共享资源提出的一种锁机制。 调用者申请的资源如果被占用，即自旋锁被已经被别的执行单元保持，则调用者一直循环在那里看是否该自旋锁的保持着已经释放了锁，自旋锁是一种比较低级的保护数据结构和代码片段的原始方式，可能会引起以下两个问题;<br>（1）死锁<br>（2）过多地占用CPU资源 </p><p>3.<strong>管程</strong><br>信号量机制功能强大，但使用时对信号量的操作分散，而且难以控制，读写和维护都很困难。因此后来又提出了一种集中式同步进程——管程。其基本思想是将共享变量和对它们的操作集中在一个模块中，操作系统或并发程序就由这样的模块构成。这样模块之间联系清晰，便于维护和修改，易于保证正确性。 </p><p>4.<strong>会合</strong></p><p>进程直接进行相互作用 </p><p>5.<strong>分布式系统</strong></p><p>由于在分布式操作系统中没有公共内存，因此参数全为值参，而且不可为指针。</p><hr><p><strong>线程同步的方式</strong></p><ul><li><p><font color="red">互斥量 Synchronized/Lock：</font>采用互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限。因为互斥对象只有一个，所以可以保证公共资源不会被多个线程同时访问</p></li><li><p><font color="red">信号量 Semphare：</font>它允许同一时刻多个线程访问同一资源，但是需要控制同一时刻访问此资源的最大线程数量</p></li><li><p><font color="red">事件(信号)，Wait/Notify：</font>通过通知操作的方式来保持多线程同步，还可以方便的实现多线程优先级的比较操作</p></li></ul><hr><p><strong>什么是虚拟内存？</strong></p><p>1).内存的发展历程</p><p>　　没有内存抽象(单进程，除去操作系统所用的内存之外，全部给用户程序使用)  —&gt; 有内存抽象（多进程，进程独立的地址空间，交换技术(内存大小不可能容纳下所有并发执行的进程) <br>）—&gt; 连续内存分配(固定大小分区(多道程序的程度受限)，可变分区(首次适应，最佳适应，最差适应)，碎片) —&gt; 不连续内存分配（分段，分页，段页式，虚拟内存）</p><p>2).虚拟内存</p><p>　　虚拟内存允许执行进程不必完全在内存中。虚拟内存的基本思想是：每个进程拥有独立的地址空间，这个空间被分为大小相等的多个块，称为页(Page)，每个页都是一段连续的地址。这些页被映射到物理内存，但并不是所有的页都必须在内存中才能运行程序。当程序引用到一部分在物理内存中的地址空间时，由硬件立刻进行必要的映射；当程序引用到一部分不在物理内存中的地址空间时，由操作系统负责将缺失的部分装入物理内存并重新执行失败的命令。这样，<font color="red"><b>对于进程而言，逻辑上似乎有很大的内存空间，实际上其中一部分对应物理内存上的一块(称为帧，通常页和帧大小相等)，还有一些没加载在内存中的对应在硬盘上，如图5所示。</b></font> <br>注意，请求分页系统、请求分段系统和请求段页式系统都是针对虚拟内存的，通过请求实现内存与外存的信息置换。</p><p>　　　　　　　　　　　　　　　　　　　<img src="https://img-blog.csdn.net/20171021161259614" alt="这里写图片描述" title></p><p>　　由图可以看出，虚拟内存实际上可以比物理内存大。当访问虚拟内存时，会访问MMU（内存管理单元）去匹配对应的物理地址（比如图5的0，1，2）。如果虚拟内存的页并不存在于物理内存中（如图5的3,4），会产生缺页中断，从磁盘中取得缺的页放入内存，如果内存已满，还会根据某种算法将磁盘中的页换出。</p><p>3). 页面置换算法</p><ul><li><p><font color="red">FIFO先进先出算法</font>：在操作系统中经常被用到，比如作业调度（主要实现简单，很容易想到）；</p></li><li><p><font color="red">LRU（Least recently use）最近最少使用算法</font>：根据使用时间到现在的长短来判断；</p></li><li><p><font color="red">LFU（Least frequently use）最少使用次数算法</font>：根据使用次数来判断；</p></li><li><p><font color="red">OPT（Optimal replacement）最优置换算法</font>：理论的最优，理论；就是要保证置换出去的是不再被使用的页，或者是在实际内存中最晚使用的算法。</p></li></ul><p>4). 虚拟内存的应用与优点</p><p>　　虚拟内存很适合在多道程序设计系统中使用，许多程序的片段同时保存在内存中。当一个程序等待它的一部分读入内存时，可以把CPU交给另一个进程使用。虚拟内存的使用可以带来以下好处：</p><ul><li><p>在内存中可以保留多个进程，系统并发度提高</p></li><li><p>解除了用户与内存之间的紧密约束，进程可以比内存的全部空间还大</p></li></ul><hr><p><strong>颠簸</strong></p><p>　　颠簸本质上是指频繁的页调度行为，具体来讲，进程发生缺页中断，这时，必须置换某一页。然而，其他所有的页都在使用，它置换一个页，但又立刻再次需要这个页。因此，会不断产生缺页中断，导致整个系统的效率急剧下降，这种现象称为颠簸（抖动）。</p><p>　　内存颠簸的解决策略包括：</p><ul><li><p>如果是因为页面替换策略失误，可以修改替换算法来解决这个问题；</p></li><li><p>如果是因为运行的程序太多，造成程序无法同时将所有频繁访问的页面调入内存，则要降低多道程序的数量；</p></li><li><p>否则，还剩下两个办法：终止该进程或增加物理内存容量。</p></li></ul><hr><p><strong>局部性原理</strong></p><p>(1). 时间上的局部性：最近被访问的页在不久的将来还会被访问；</p><p>(2). 空间上的局部性：内存中被访问的页周围的页也很可能被访问。</p><hr><p><strong>中断和轮询</strong></p><p><strong>中断的定义</strong><br>指在计算机执行期间，系统内发生任何非寻常的或非预期的急需处理事件，使得CPU暂时中断当前正在执行的程序而转去执行相应的事件处理程序，待处理完毕后又返回原来被中断处继续执行或调度新的进程执行的过程</p><p><strong>轮询的定义</strong><br>定时对各种设备轮流询问一遍有无处理要求</p><hr><p><strong>临界区和冲突解决</strong><br>临界资源的定义:<br>一次仅允许一个进程使用的资源</p><p>临界区的定义:<br>每个进程中访问临界资源的那段程序</p><p>解决冲突:<br>如果有若干进程要求进入空闲的临界区，一次仅允许一个进程进入<br>任何时候，处于临界区内的进程不可多于一个<br>进入临界区的进程要在有限时间内退出，以便其它进程能及时进入自己的临界区<br>如果进程不能进入自己的临界区，则应让出CPU，避免进程出现“忙等”现象</p><hr><p><strong>缓冲区溢出</strong><br>缓冲区溢出的定义:<br>指当计算机向缓冲区内填充数据时超过了缓冲区本身的容量，溢出的数据覆盖在合法数据上</p><p>缓冲区溢出的危害:<br>程序崩溃导致拒绝服务、跳转并且执行一段恶意代码</p><p>缓冲区溢出的原因:<br>程序中没有仔细检查用户输入的参数</p><hr>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://picsum.photos/800/206&quot; alt&gt;&lt;br&gt; &lt;strong&gt;操作系统的组成&lt;/strong&gt;&lt;br&gt;1、&lt;strong&gt;驱动程序&lt;/strong&gt;是最底层的、直接控制和监视各类硬件的部分，它们的职责是隐藏硬件的具体细节，并向其他部分提供一个抽象的、通用的接口。&lt;/p&gt;
&lt;p&gt;2、&lt;strong&gt;内核&lt;/strong&gt;是操作系统之最内核部分，通常运行在最高特权级，负责提供基础性、结构性的功能。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="操作系统" scheme="ayjcsgm.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>HashMap源码分析(JDK1.8)</title>
    <link href="ayjcsgm.github.io/2019/10/03/HashMap%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-JDK1-8/"/>
    <id>ayjcsgm.github.io/2019/10/03/HashMap源码分析-JDK1-8/</id>
    <published>2019-10-03T07:55:29.000Z</published>
    <updated>2019-10-03T08:42:54.818Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://picsum.photos/800/205" alt></p><h1 id="HashMap简介："><a href="#HashMap简介：" class="headerlink" title="HashMap简介："></a><strong>HashMap简介</strong>：</h1><pre><code>HashMap在底层数据结构上采用了数组＋链表＋红黑树，通过散列映射来存储键值对数据因为在查询上使用散列码（通过键生成一个数字作为数组下标，这个数字就是hashcode）所以在查询上的访问速度比较快，HashMap最多允许一对键值对的Key为Null，允许多对键值对的value为Null。它是非线程安全的。在排序上面是无序的。</code></pre><a id="more"></a><h4 id="HashMap的主要成员变量："><a href="#HashMap的主要成员变量：" class="headerlink" title="HashMap的主要成员变量："></a>HashMap的主要成员变量：</h4><p><strong>transient Node&lt;K,V&gt;[] table</strong>：这是一个Node类型的数组（也有称作Hash桶），可以从下面源码中看到静态内部类Node在这边可以看做就是一个节点，多个Node节点构成链表，当链表长度大于8的时候转换为红黑树。<br><img src="https://img-blog.csdn.net/20180529155827859" alt="Node"><br><strong>transient int size</strong>：表示当前HashMap包含的键值对数量</p><p><strong>transient int modCount</strong>：表示当前HashMap修改次数</p><p><strong>int threshold</strong>：表示当前HashMap能够承受的最多的键值对数量，一旦超过这个数量HashMap就会进行扩容</p><p><strong>final float loadFactor</strong>：负载因子，用于扩容</p><p><strong>static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4</strong>：默认的table初始容量</p><p><strong>static final float DEFAULT_LOAD_FACTOR = 0.75f</strong>：默认的负载因子</p><p>介绍完了重要的几个参数后我们来看看HashMap的构造参数。</p><p>HashMap的构造方法有四种：<br><img src="https://img-blog.csdn.net/20180529164049237" alt="在这里插入图片描述"><br>详细代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal initial capacity: "</span> +</span><br><span class="line">                                           initialCapacity);</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">        initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">    <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal load factor: "</span> +</span><br><span class="line">                                           loadFactor);</span><br><span class="line">    <span class="keyword">this</span>.loadFactor = loadFactor;</span><br><span class="line">    <span class="keyword">this</span>.threshold = tableSizeFor(initialCapacity);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR; <span class="comment">// all other fields defaulted</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR;</span><br><span class="line">    putMapEntries(m, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>前面三个构造器的区别都是在于指定初始容量以及负载因子，如果你选择默认的构造器那么在创建的时候不会指定threshold的值，而第二个以及第三个构造器在一开始的时候就会根据下面的这个方法来确认threshold值，可以看到下面用到了移位算法，最后一个构造器很显然就是把另一个Map的值映射到当前新的Map中。<br><img src="https://img-blog.csdn.net/20180529165142867" alt="在这里插入图片描述"><br>这边先提下负载因子（loadFactor），源码中有个公式为threshold = loadFactor * 容量。HashMap和HashSet都允许你指定负载因子的构造器，表示当负载情况达到负载因子水平的时候，容器会自动扩容，HashMap默认使用的负载因子值为0.75f（当容量达到四分之三进行再散列（扩容））。当负载因子越大的时候能够容纳的键值对就越多但是查找的代价也会越高。所以如果你知道将要在HashMap中存储多少数据，那么你可以创建一个具有恰当大小的初始容量这可以减少扩容时候的开销。但是大多数情况下0.75在时间跟空间代价上达到了平衡所以不建议修改。</p><p>下面将根据默认的构造为出发点，从初始化一个HashMap到使用Get，Put方法进行一些源码解析。</p><h2 id="put-K-key-V-value-："><a href="#put-K-key-V-value-：" class="headerlink" title="put(K key, V value)："></a>put(K key, V value)：</h2><pre><code>在使用默认构造器初始化一个HashMap对象的时候，首次Put键值对的时候会先计算对应Key的hash值通过hash值来确定存放的地址。</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>   紧接着调用了putVal方法，在刚刚初始化之后的table值为null因此程序会进入到resize()方法中。而resize方法就是用来进行扩容的（稍后提到）。扩容后得到了一个table的节点（Node）数组，接着根据传入的hash值去获得一个对应节点p并去判断是否为空，是的话就存入一个新的节点（Node）。反之如果当前存放的位置已经有值了就会进入到else中去。接着根据前面得到的节点p的hash值以及key跟传入的hash值以及参数进行比较，如果一样则替覆盖。如果存在Hash碰撞就会以链表的形式保存，把当前传进来的参数生成一个新的节点保存在链表的尾部（JDK1.7保存在首部）。而如果链表的长度大于8那么就会以红黑树的形式进行保存。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">               <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>) <span class="comment">//首次初始化的时候table为null</span></span><br><span class="line">        n = (tab = resize()).length; <span class="comment">//对HashMap进行扩容</span></span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>) <span class="comment">//根据hash值来确认存放的位置。如果当前位置是空直接添加到table中</span></span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//如果存放的位置已经有值</span></span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            e = p; <span class="comment">//确认当前table中存放键值对的Key是否跟要传入的键值对key一致</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode) <span class="comment">//确认是否为红黑树</span></span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">        <span class="keyword">else</span> &#123;<span class="comment">//如果hashCode一样的两个不同Key就会以链表的形式保存</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st 判断链表长度是否大于8</span></span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                e.value = value; <span class="comment">//替换新的value并返回旧的value</span></span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ++modCount;</span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        resize();<span class="comment">//如果当前HashMap的容量超过threshold则进行扩容</span></span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="扩容机制核心方法Node-lt-K-V-gt-resize-："><a href="#扩容机制核心方法Node-lt-K-V-gt-resize-：" class="headerlink" title="扩容机制核心方法Node&lt;K,V&gt;[] resize()："></a>扩容机制核心方法Node&lt;K,V&gt;[] resize()：</h2><p>   HashMap扩容可以分为三种情况：</p><p>第一种：使用默认构造方法初始化HashMap。从前文可以知道HashMap在一开始初始化的时候会返回一个空的table，并且thershold为0。因此第一次扩容的容量为默认值DEFAULT_INITIAL_CAPACITY也就是16。同时threshold = DEFAULT_INITIAL_CAPACITY * DEFAULT_LOAD_FACTOR = 12。</p><p>第二种：指定初始容量的构造方法初始化HashMap。那么从下面源码可以看到初始容量会等于threshold，接着threshold = 当前的容量（threshold） * DEFAULT_LOAD_FACTOR。</p><p>第三种：HashMap不是第一次扩容。如果HashMap已经扩容过的话，那么每次table的容量以及threshold量为原有的两倍。</p><pre><code>这边也可以引申到一个问题就是HashMap是先插入数据再进行扩容的，但是如果是刚刚初始化容器的时候是先扩容再插入数据。</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] oldTab = table;<span class="comment">//首次初始化后table为Null</span></span><br><span class="line">    <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">    <span class="keyword">int</span> oldThr = threshold;<span class="comment">//默认构造器的情况下为0</span></span><br><span class="line">    <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;<span class="comment">//table扩容过</span></span><br><span class="line">         <span class="comment">//当前table容量大于最大值得时候返回当前table</span></span><br><span class="line">         <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span> oldTab;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">        <span class="comment">//table的容量乘以2，threshold的值也乘以2           </span></span><br><span class="line">        newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">    <span class="comment">//使用带有初始容量的构造器时，table容量为初始化得到的threshold</span></span><br><span class="line">    newCap = oldThr;</span><br><span class="line">    <span class="keyword">else</span> &#123;  <span class="comment">//默认构造器下进行扩容  </span></span><br><span class="line">         <span class="comment">// zero initial threshold signifies using defaults</span></span><br><span class="line">        newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">        newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">//使用带有初始容量的构造器在此处进行扩容</span></span><br><span class="line">        <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</span><br><span class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                  (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    threshold = newThr;</span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"rawtypes"</span>,<span class="string">"unchecked"</span>&#125;)</span><br><span class="line">        Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</span><br><span class="line">    table = newTab;</span><br><span class="line">  <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">//对新扩容后的table进行赋值，条件中的代码删减</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="get-Object-key-："><a href="#get-Object-key-：" class="headerlink" title="get(Object key)："></a>get(Object key)：</h2><p>   先前HashMap通过hashcode来存放数据，那么get方法一样要通过hashcode来获取数据。可以看到如果当前table没有数据的话直接返回null反之通过传进来的hash值找到对应节点（Node）first，如果first的hash值以及Key跟传入的参数匹配就返回对应的value反之判断是否是红黑树，如果是红黑树则从根节点开始进行匹配如果有对应的数据则结果否则返回Null，如果是链表的话就会循环查询链表，如果当前的节点不匹配的话就会从当前节点获取下一个节点来进行循环匹配，如果有对应的数据则返回结果否则返回Null。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="keyword">null</span> ? <span class="keyword">null</span> : e.value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">getNode</span><span class="params">(<span class="keyword">int</span> hash, Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="keyword">int</span> n; K k;</span><br><span class="line">    <span class="comment">//如果当前table没有数据的话返回Null</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//根据当前传入的hash值以及参数key获取一个节点即为first,如果匹配的话返回对应的value值</span></span><br><span class="line">        <span class="keyword">if</span> (first.hash == hash &amp;&amp; <span class="comment">// always check first node</span></span><br><span class="line">            ((k = first.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            <span class="keyword">return</span> first;</span><br><span class="line">        <span class="comment">//如果参数与first的值不匹配的话</span></span><br><span class="line">        <span class="keyword">if</span> ((e = first.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//判断是否是红黑树，如果是红黑树的话先判断first是否还有父节点，然后从根节点循环查询是否有对应的值</span></span><br><span class="line">            <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                <span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="comment">//如果是链表的话循环拿出数据</span></span><br><span class="line">            <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">return</span> e;</span><br><span class="line">            &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="htmledit_views" id="content_views">                                            <p><span style="font-size:18px;"> <span style="font-size:20px;">JDK1.8对HashMap进行了优化</span>， 真正理解它了吗？ <br></span></p><p><span style="font-size:18px;">考虑如下问题：&nbsp; <br></span></p><p><span style="font-size:18px;">1、哈希基本原理？（答：散列表、hash碰撞、链表、<strong><span style="color:#FF0000;">红黑树</span></strong>）<br></span></p><span style="font-size:18px;">2、hashmap查询的时间复杂度， 影响因素和原理？ （答：最好O（1），最差O（n）， 如果是<strong><span style="color:#FF0000;">红黑O（logn）</span></strong>）<br></span><p><span style="font-size:18px;">3、resize如何实现的， 记住已经没有rehash了！！！（答：拉链entry根据高位bit散列到当前位置i和size+i位置）</span></p><p><span style="font-size:18px;">4、<strong><span style="color:#FF0000;">为什么获取下标时用按位与&amp;，而不是取模%</span></strong>？ （答：不只是&amp;速度更快哦，&nbsp; 我觉得你能答上来便真正理解hashmap了）</span></p><p><span style="font-size:18px;">5、什么时机执行resize？</span></p><p><span style="font-size:18px;">答：hashmap实例里的元素个数大于threshold时执行resize(即桶数量扩容为2倍并散列原来的Entry)。 PS：threshold=桶数量*负载因子</span></p><p><span style="font-size:18px;"></span></p><pre><code class="hljs cs"><ol class="hljs-ln"><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="1"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"><span class="hljs-function">final V <span class="hljs-title">putVal</span>(<span class="hljs-params"><span class="hljs-params"><span class="hljs-keyword">int</span> hash, K key, V <span class="hljs-keyword">value</span>, boolean onlyIfAbsent,</span></span></span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="2"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"><span class="hljs-params">               boolean evict</span>) {</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="3"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="hljs-keyword">int</span> n, i;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="4"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    <span class="hljs-keyword">if</span> ((tab = table) == <span class="hljs-literal">null</span> || (n = tab.length) == <span class="hljs-number">0</span>)</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="5"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">        n = (tab = resize()).length;   <span class="hljs-comment">//初始化桶，默认16个元素</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="6"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    <span class="hljs-keyword">if</span> ((p = tab[i = (n - <span class="hljs-number">1</span>) &amp; hash]) == <span class="hljs-literal">null</span>)   <span class="hljs-comment">//如果第i个桶为空，创建Node实例</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="7"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">        tab[i] = newNode(hash, key, <span class="hljs-keyword">value</span>, <span class="hljs-literal">null</span>);</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="8"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    <span class="hljs-keyword">else</span> { <span class="hljs-comment">//哈希碰撞的情况， 即(n-1)&amp;hash相等</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="9"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">        Node&lt;K,V&gt; e; K k;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="10"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">        <span class="hljs-keyword">if</span> (p.hash == hash &amp;&amp;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="11"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">            ((k = p.key) == key || (key != <span class="hljs-literal">null</span> &amp;&amp; key.<span class="hljs-keyword">equals</span>(k))))</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="12"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">            e = p;   <span class="hljs-comment">//key相同，后面会覆盖value</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="13"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (p instanceof TreeNode)</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="14"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="hljs-keyword">this</span>, tab, hash, key, <span class="hljs-keyword">value</span>);  <span class="hljs-comment">//红黑树添加当前node</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="15"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">        <span class="hljs-keyword">else</span> {</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="16"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> binCount = <span class="hljs-number">0</span>; ; ++binCount) {</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="17"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">                <span class="hljs-keyword">if</span> ((e = p.next) == <span class="hljs-literal">null</span>) {</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="18"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">                    p.next = newNode(hash, key, <span class="hljs-keyword">value</span>, <span class="hljs-literal">null</span>);  <span class="hljs-comment">//链表添加当前元素</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="19"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">                    <span class="hljs-keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="hljs-number">1</span>) <span class="hljs-comment">// -1 for 1st</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="20"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">                        treeifyBin(tab, hash);  <span class="hljs-comment">//当链表个数大于等于7时，将链表改造为红黑树</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="21"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">                    <span class="hljs-keyword">break</span>;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="22"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">                }</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="23"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">                <span class="hljs-keyword">if</span> (e.hash == hash &amp;&amp;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="24"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">                    ((k = e.key) == key || (key != <span class="hljs-literal">null</span> &amp;&amp; key.<span class="hljs-keyword">equals</span>(k))))</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="25"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">                    <span class="hljs-keyword">break</span>;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="26"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">                p = e;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="27"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">            }</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="28"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">        }</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="29"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">        <span class="hljs-keyword">if</span> (e != <span class="hljs-literal">null</span>) { <span class="hljs-comment">// existing mapping for key</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="30"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">            V oldValue = e.<span class="hljs-keyword">value</span>;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="31"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">            <span class="hljs-keyword">if</span> (!onlyIfAbsent || oldValue == <span class="hljs-literal">null</span>)</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="32"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">                e.<span class="hljs-keyword">value</span> = <span class="hljs-keyword">value</span>;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="33"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">            afterNodeAccess(e);</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="34"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">            <span class="hljs-keyword">return</span> oldValue;            <span class="hljs-comment">//覆盖key相同的value并return， 即不会执行++size</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="35"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">        }</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="36"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    }</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="37"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    ++modCount;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="38"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    <span class="hljs-keyword">if</span> (++size &gt; threshold)    <span class="hljs-comment">//key不相同时，每次插入一条数据自增1. 当size大于threshold时resize</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="39"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">        resize();</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="40"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    afterNodeInsertion(evict);</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="41"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="42"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">}</div></div></li></ol></code><div class="hljs-button {2}" data-title="复制" onclick="hljs.copyCode(event)"></div></pre><br><p><span style="font-size:18px;">6、为什么负载因子默认为0.75f ？ 能不能变为0.1、0.9、2、3等等呢？</span></p><p><span style="font-size:18px;">答：0.75是平衡了时间和空间等因素； 负载因子越小桶的数量越多，读写的时间复杂度越低（极限情况O(1), 哈希碰撞的可能性越小）； 负载因子越大桶的数量越少，读写的时间复杂度越高(极限情况O(n), 哈希碰撞可能性越高)。 0.1，0.9，2，3等都是合法值。</span></p><p><span style="font-size:18px;">7、影响HashMap性能的因素？</span></p><p><span style="font-size:18px;">1、 负载因子；</span></p><p><span style="font-size:18px;">2、哈希值；理想情况是均匀的散列到各个桶。 一般HashMap使用String类型作为key，而String类重写了hashCode函数。</span></p><p><span style="font-size:18px;"></span></p><pre><code class="hljs java"><ol class="hljs-ln"><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="1"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">   <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> <span class="hljs-title">hash</span><span class="hljs-params">(Object key)</span> </span>{</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="2"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">        <span class="hljs-keyword">int</span> h;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="3"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">        <span class="hljs-keyword">return</span> (key == <span class="hljs-keyword">null</span>) ? <span class="hljs-number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="hljs-number">16</span>);</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="4"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    }</div></div></li></ol></code><div class="hljs-button {2}" data-title="复制" onclick="hljs.copyCode(event)"></div></pre><p><span style="font-size:18px;">8、HashMap的key需要满足什么条件？&nbsp;</span></p><p><span style="font-size:18px;">答：必须重写hashCode和equals方法， 常用的String类实现了这两个方法。</span></p><p><span style="font-size:18px;">示例代码：</span></p><p></p><pre><code class="hljs cpp"><ol class="hljs-ln"><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="1"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">KeyClass</span> {</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="2"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">        <span class="hljs-keyword">int</span> age;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="3"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">        String name;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="4"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"> </div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="5"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">        <span class="hljs-function"><span class="hljs-keyword">public</span> boolean <span class="hljs-title">equals</span><span class="hljs-params">(Object anyObject)</span> </span>{</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="6"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">            <span class="hljs-keyword">if</span> (anyObject == <span class="hljs-keyword">this</span>) {</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="7"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="8"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">            }</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="9"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"> </div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="10"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">            <span class="hljs-keyword">if</span> (anyObject instanceof KeyClass) {</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="11"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">                KeyClass obj = (KeyClass) anyObject;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="12"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">                <span class="hljs-keyword">if</span> (obj.age == <span class="hljs-keyword">this</span>.age</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="13"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">                        &amp;&amp; obj.name == <span class="hljs-keyword">this</span>.name) {</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="14"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">                    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="15"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">                }</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="16"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">            }</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="17"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="18"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">        }</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="19"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"> </div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="20"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">hashCode</span><span class="hljs-params">()</span> </span>{</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="21"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">            <span class="hljs-keyword">return</span> name==null? age : age|name.hashCode();</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="22"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">        }</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="23"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    }</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="24"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"> </div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="25"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="26"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">        HashMap&lt;KeyClass, String&gt; <span class="hljs-built_in">map</span> = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="27"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">        KeyClass obj1 = <span class="hljs-keyword">new</span> KeyClass();</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="28"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">        KeyClass obj2 = <span class="hljs-keyword">new</span> KeyClass();</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="29"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">        obj1.age = <span class="hljs-number">1</span>;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="30"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">        obj1.name = <span class="hljs-string">"Tom"</span>;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="31"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">        obj2.age = <span class="hljs-number">2</span>;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="32"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">        obj2.name =<span class="hljs-string">"Jack"</span>;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="33"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">        <span class="hljs-built_in">map</span>.put(obj1, <span class="hljs-string">"aaa"</span>);</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="34"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">        <span class="hljs-built_in">map</span>.put(obj2, <span class="hljs-string">"bbb"</span>);</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="35"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">        <span class="hljs-built_in">map</span>.put(obj1, <span class="hljs-string">"ccc"</span>);</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="36"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">        <span class="hljs-built_in">map</span>.put(obj2, <span class="hljs-string">"ddd"</span>);</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="37"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"> </div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="38"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">        <span class="hljs-built_in">map</span>.forEach((key, value) -&gt; {</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="39"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">            System.out.println(key.name + <span class="hljs-string">"---"</span> + value);</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="40"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">        });</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="41"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    }</div></div></li></ol></code><div class="hljs-button {2}" data-title="复制" onclick="hljs.copyCode(event)"></div></pre>输出：<p></p><pre><code class="hljs sql"><ol class="hljs-ln"><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="1"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">Tom<span class="hljs-comment">---ccc</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="2"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">Jack<span class="hljs-comment">---ddd</span></div></div></li></ol></code><div class="hljs-button {2}" data-title="复制" onclick="hljs.copyCode(event)"></div></pre><p><span style="font-size:18px;">9、HashMap允许key/value为null， 但最多只有一个。 为什么？ &nbsp;</span></p><p><span style="font-size:16px;">答： 如果key为null会放在第一个桶（即下标0）位置， 而且是在链表最前面（即第一个位置）。&nbsp;</span></p><p><span style="font-size:18px;"><br></span></p><p><span style="font-size:18px;">JDK1.8的HashMap源码： http://www.grepcode.com/file/repository.grepcode.com/java/root/jdk/openjdk/8u40-b25/java/util/HashMap.java#HashMap</span></p><p><span style="font-size:18px;"><br></span></p><p><span style="font-size:18px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 我的习惯是先看注释再看源码并调试， 先翻译一下源码注释吧， 不准之处请指正哈。</span></p><p><span style="font-size:18px;"><br></span></p><p><span style="font-size:18px;">Hash table based implementation of the <tt>Map</tt> interface. This implementation provides all of the optional map<br></span></p><p><span style="font-size:18px;">&nbsp;&nbsp; <span style="color:#009900;">HashTable实现了Map接口类， 这些接口实现了所有可选的map功能， 包括允许空值和空key。</span><br></span></p><p><span style="font-size:18px;">operations, and permits <tt>null</tt> values and the<tt>null</tt> key. (The<tt>HashMap</tt> class is roughly equivalent to<tt>Hashtable</tt>, except that it is unsynchronized and permits nulls.) This class makes no guarantees as to the order of the map; in particular, it does not guarantee that the order will remain constant over time.<br></span></p><p><span style="font-size:18px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#009900;"> HashMap和HashTable基本一致，&nbsp; 区别是HashMap是线程不同步的且允许空key。 HashMap不保证map的顺序， 而且顺序是可变的。</span><br></span></p><p><span style="font-size:18px;">This implementation provides constant-time performance for the basic operations (<tt>get</tt> and<tt>put</tt>), assuming the hash function disperses the elements properly among the buckets.<br></span></p><p><span style="font-size:18px;">&nbsp;&nbsp;&nbsp;<span style="color:#33CC00;"> <span style="color:#009900;">如果将数据适当的分散到桶里， HashMap的添加、查询函数的执行周期是常量值。</span></span><br></span></p><p><span style="font-size:18px;">Iteration over collection views requires time proportional to the "capacity" of the<tt>HashMap</tt> instance (the number of buckets) plus its size (the number of key-value mappings). Thus, it's very important not to set the initial capacity too high (or the load factor too low) if iteration performance is important.<br></span></p><p><span style="font-size:18px;">&nbsp;<span style="color:#009900;">&nbsp;&nbsp; 使用迭代器遍历所有数据的性能跟HashMap的桶（bucket）数量有直接关系，&nbsp;&nbsp; 为了提高遍历的性能， 不能设置比较大的桶数量或者负载因子过低。</span><br></span></p><p><span style="font-size:18px;">An instance of <tt>HashMap</tt> has two parameters that affect its performance:<em>initial capacity</em> and<em>load factor</em>. The<em>capacity</em> is the number of buckets in the hash table, and the initial capacity is simply the capacity at the time the hash table is created.<br></span></p><p><span style="font-size:18px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style="color:#009900;">HashMap实例有2个重要参数影响它的性能： 初始容量和负载因子。 初始容量是指在哈希表里的桶总数， 一般在创建HashMap实例时设置初始容量。</span><br></span></p><p><span style="font-size:18px;">The <em>load factor</em> is a measure of how full the hash table is allowed to get before its capacity is automatically increased.<br></span></p><p><span style="font-size:18px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#009900;"> 负载因子是指哈希表在多满时扩容的百分比比例。</span><br></span></p><p><span style="font-size:18px;">When the number of entries in the hash table exceeds the product of the load factor and the current capacity, the hash table is<em>rehashed</em> (that is, internal data structures are rebuilt) so that the hash table has approximately twice the number of buckets.<br></span></p><p><span style="font-size:18px;">&nbsp;<span style="color:#009900;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 当哈希表的数据个数超过负载因子和当前容量的乘积时， 哈希表要再做一次哈希（重建内部数据结构）， 哈希表每次扩容为原来的2倍。</span><br></span></p><p><span style="font-size:18px;">As a general rule, the default load factor (.75) offers a good tradeoff between time and space costs. Higher values decrease the space overhead but increase the lookup cost (reflected in most of the operations of the<tt>HashMap</tt> class, including <tt>get</tt> and <tt>put</tt>). <br></span></p><p><span style="font-size:18px;">&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#009900;">&nbsp;&nbsp;&nbsp; 负载因子的默认值是0.75， 它平衡了时间和空间复杂度。 负载因子越大会降低空间使用率，但提高了查询性能（表现在哈希表的大多数操作是读取和查询）</span><br></span></p><p><span style="font-size:18px;">The expected number of entries in the map and its load factor should be taken into account when setting its initial capacity, so as to minimize the number of rehash operations. If the initial capacity is greater than the maximum number of entries divided by the load factor, no rehash operations will ever occur.<br></span></p><p><span style="font-size:18px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#009900;"> 考虑哈希表的性能问题， 要设置合适的初始容量，&nbsp;&nbsp; 从而减少rehash的次数。 当哈希表中entry的总数少于负载因子和初始容量乘积时， 就不会发生rehash动作。</span><br></span></p><p><span style="font-size:18px;">If many mappings are to be stored in a <tt>HashMap</tt> instance, creating it with a sufficiently large capacity will allow the mappings to be stored more efficiently than letting it perform automatic rehashing as needed to grow the table. Note that using many keys with the same <code>hashCode()</code> is a sure way to slow down performance of any hash table. To ameliorate impact, when keys are<code><code><a href="http://www.grepcode.com/file/repository.grepcode.com/java/root/jdk/openjdk/8u40-b25/java/lang/Comparable.java#Comparable" rel="noopener" title="java.lang.Comparable" data-token="0d683665adbeba8c0a8f54b7a6a9bec6" target="_blank">java.lang.Comparable</a></code></code>, this class may use comparison order among keys to help break ties. <br></span></p><p><span style="font-size:18px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#009900;"> 如果有很多值要存储到HashMap实例中， 在创建HashMap实例时要设置足够大的初始容量， 避免自动扩容时rehash。 如果很多关键字的哈希值相同， 会降低哈希表的性能。 为了降低这个影响， 当关键字支持<code><code><a href="http://www.grepcode.com/file/repository.grepcode.com/java/root/jdk/openjdk/8u40-b25/java/lang/Comparable.java#Comparable" rel="noopener" title="java.lang.Comparable" data-token="0d683665adbeba8c0a8f54b7a6a9bec6" target="_blank">java.lang.Comparable</a></code></code>时， 可以对关键字做次排序以降低影响。</span><br></span></p><p><span style="font-size:18px;"><strong>Note that this implementation is not synchronized.</strong> If multiple threads access a hash map concurrently, and at<br></span></p><p><span style="font-size:18px;">least one of the threads modifies the map structurally, it<em>must</em> be synchronized externally. (A structural modification<br></span></p><p><span style="font-size:18px;">&nbsp;<span style="color:#009900;">&nbsp; 哈希表是非线程安全的， 如果多线程同时访问哈希表， 且至少一个线程修改了哈希表的结构， 那么必须在访问hashmap前设置同步锁。（修改结构是指添加或者删除一个或多个entry， 修改键值不算是修改结构。）</span><br></span></p><p><span style="font-size:18px;">is any operation that adds or deletes one or more mappings; merely changing the value associated with a key that an instance already contains is not a structural modification.) This is typically accomplished by synchronizing on some object that naturally encapsulates the map. <br></span></p><p><span style="font-size:18px;">&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#009900;"> 一般在多线程操作哈希表时，&nbsp; 要使用同步对象封装map。</span><br></span></p><p><span style="font-size:18px;">If no such object exists, the map should be "wrapped" using the<code>Collections.synchronizedMap</code> method. This is best done at creation time, to prevent accidental unsynchronized access to the map:</span></p><p><span style="font-size:18px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style="color:#009900;">如果不封装Hashmap， 可以使用<code>Collections.synchronizedMap</code>&nbsp; 方法调用HashMap实例。&nbsp; 在创建HashMap实例时避免其他线程操作该实例， 即保证了线程安全。</span><br></span></p><pre><span style="font-size:18px;">   Map m = Collections.synchronizedMap(new HashMap(...));</span></pre><span style="font-size:18px;"><br></span><p><span style="font-size:18px;">&nbsp;&nbsp;&nbsp;&nbsp;</span><span style="font-size:18px;">&nbsp;&nbsp; JDK1.8对哈希碰撞后的拉链算法进行了优化， 当拉链上entry数量太多（超过8个）时，将链表重构为<span style="color:#FF0000;">红黑树</span>。&nbsp; 下面是源码相关的注释：<br></span></p><p><span style="font-size:18px;">&nbsp;&nbsp; * This map usually acts as a binned (bucketed) hash table, but<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * when bins get <span style="color:#FF0000;">too large</span>, they are <span style="color:#FF0000;">transformed </span>into bins of<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * <span style="color:#FF0000;">TreeNodes</span>, each structured similarly to those in<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * java.util.TreeMap. Most methods try to use normal bins, but<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * relay to TreeNode methods when applicable (simply by checking<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * instanceof a node).&nbsp; Bins of TreeNodes may be traversed and<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * used like any others, but additionally support faster lookup<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * when overpopulated. However, since the vast majority of bins in<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * normal use are not overpopulated, checking for existence of<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * tree bins may be delayed in the course of table methods.</span></p><p><br></p><p><span style="font-size:18px;"><span style="color:#33CC00;"><span style="color:#000000;">看看HashMap的几个重要成员变量：</span><br></span></span></p><p><span style="font-size:18px;"><span style="color:#33CC00;">&nbsp;//The default initial capacity - MUST be a power of two.</span><br></span></p><p><span style="font-size:18px;">static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4;<span style="color:#33CC00;"> //为毛不写成16？？？ 大师是想用这种写法告诉你只能是2的幂</span><br></span></p><p><span style="font-size:18px;">&nbsp;HashMap的初始容量是16个， 而且容量只能是2的幂。&nbsp; 每次扩容时都是变成原来的2倍。</span></p><p><span style="font-size:18px;"><br></span></p><p><span style="font-size:18px;">static final float DEFAULT_LOAD_FACTOR = 0.75f;<br></span></p><p><span style="font-size:18px;">默认的负载因子是0.75f， 16*0.75=12。即默认的HashMap实例在插入第13个数据时，会扩容为32。</span></p><p><span style="font-size:18px;color:#009900;"><br></span></p><p><span style="font-size:18px;"><span style="color:#009900;"><span>The bin count threshold for using a tree rather than list for a bin. Bins are converted to trees when adding an element to a bin with at least this many nodes. The value must be greater than 2 and should be at least 8 to mesh with assumptions in tree removal about conversion back to plain bins upon shrinkage.</span></span><br>static final int TREEIFY_THRESHOLD = 8;</span></p><p><span style="font-size:18px;"><strong><span style="color:#FF0000;">注意：这是JDK1.8对HashMap的优化， 哈希碰撞后的链表上达到8个节点时要将链表重构为红黑树，&nbsp; 查询的时间复杂度变为O(logN)。</span></strong></span></p><p><span style="font-size:18px;"><span style="color:#FF0000;"><br></span></span></p><p><span style="font-size:18px;"><span style="color:#FF0000;"><span style="color:#009900;">The table, initialized on first use, and resized as necessary. When allocated, length is always a power of two. (We also tolerate length zero in some operations to allow bootstrapping mechanics that are currently not needed.) </span><br><span style="color:#000000;">transient Node&lt;K,V&gt;[] table;&nbsp; <span style="color:#009900;">//HashMap的桶， 如果没有哈希碰撞， HashMap就是个数组，我说的是如果</span>。<span style="color:#009900;">&nbsp; 数组的查询时间复杂度是O(1)，所以HashMap理想时间复杂度是O(1)；如果所有数据都在同一个下标位置， 即N个数据组成链表，时间复杂度为O(n)， 所以HashMap的最差时间复杂度为O(n)。如果链表达到8个元素时重构为红黑树，而红黑树的查询时间复杂度为O(logN), 所以这时HashMap的时间复杂度为O(logN)。</span></span></span><strong><span style="color:#FF0000;"><br></span></strong><span style="color:#FF0000;"><span style="color:#000000;"><br><span style="color:#009900;">Holds cached entrySet(). Note that AbstractMap fields are used for keySet() and values().</span><br>transient Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet; <span style="color:#009900;">//HashMap所有的值，因为用了Set， 所以HashMap不会有key、value都相同的数据。</span></span></span></span><span style="font-size:18px;"><strong><span style="color:#FF0000;"><br></span></strong></span></p><p><span style="font-size:18px;"><strong><span style="color:#FF0000;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<img src="https://img-blog.csdn.net/20160914094110132?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt><br></span></strong></span></p><p><span style="font-size:18px;"><strong><span style="color:#FF0000;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</span></strong><span style="color:#FF0000;"><span style="color:#000000;">哈希表的结构</span></span><strong><span style="color:#FF0000;"><br></span></strong></span></p><p><span style="font-size:18px;">1、 哈希碰撞的原因和解决方法：</span></p><p><span style="font-size:18px;">&nbsp;&nbsp;&nbsp;&nbsp; 哈希碰撞是不同的key值找到相同的下标，&nbsp; 对应HashMap里hashcode和容量的模相同。</span></p><p><span style="font-size:18px;">源码629行 &nbsp;&nbsp; if ((p = tab[i =<span style="color:#FF0000;"> (n - 1) &amp; hash</span>]) == null) ， 其中n是容量值，&nbsp;&nbsp;&nbsp; 即用哈希值和容量相与得到要保存的位置。 如果<span style="font-size:18px;"><span style="color:#FF0000;"><span style="color:#000000;">不同Key的</span>(n - 1) &amp; hash<span style="color:#000000;">相同， 那么要存储到同一个数组下标位置， 这个现象就叫哈希碰撞。</span></span></span></span></p><p><span style="font-size:18px;"><span style="font-size:18px;"><span style="color:#FF0000;"><span style="color:#000000;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; final V putVal(int hash, K key, V value, boolean onlyIfAbsent,boolean evict) {</span></span></span></span></p><p><span style="font-size:18px;"><span style="font-size:18px;"><span style="color:#FF0000;"><span style="color:#000000;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ....<br></span></span></span></span></p><p><span style="font-size:18px;"><span style="font-size:18px;"><span style="color:#FF0000;"><span style="color:#000000;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if ((p = tab[i = (n - 1) &amp; hash]) == null)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#33CC00;">//如果该下标没值，则存储到该下标位置</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tab[i] = newNode(hash, key, value, null);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Node&lt;K,V&gt; e; K k;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (p.hash == hash &amp;&amp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; e = p;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style="color:#33CC00;">//如果哈希值相同而且key相同， 则更新键值</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if (p instanceof TreeNode)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value);&nbsp;&nbsp;<span style="color:#33CC00;">//如果下标数据是TreeNode类型，则将新数据添加到红黑树中。</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (int binCount = 0; ; ++binCount) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if ((e = p.next) == null) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; p.next = newNode(hash, key, value, null);&nbsp;&nbsp; //将新Node添加到链表末尾<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; treeifyBin(tab, hash);&nbsp;&nbsp;&nbsp; <span style="color:#33CC00;">//如果链表个数达到8个时，将链表修改为红黑树结构</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }&nbsp;&nbsp;&nbsp;&nbsp; <br></span></span></span></span></p><p><span style="font-size:18px;"><span style="font-size:18px;"><span style="color:#FF0000;"><span style="color:#000000;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .....</span></span></span></span></p><p><span style="font-size:18px;"><span style="font-size:18px;"><span style="color:#FF0000;"><span style="color:#000000;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br></span></span></span></span></p><p><span style="font-size:18px;"><br></span></p><p><span style="font-size:18px;">2、JDK1.8对HashMap最大的优化是resize函数，&nbsp; 在扩容时不再需要rehash了， 下面就看看大师是怎么实现的。</span></p><p><span style="font-size:18px;"><span style="color:#009900;">Initializes or doubles table size. If null, allocates in accord with initial capacity target held in field threshold. Otherwise, because we are using power-of-two expansion, the elements from each bin must either stay at same index, or move with a power of two offset in the new table.</span></span></p><p><span style="font-size:18px;">初始化数组或者扩容为2倍，&nbsp;&nbsp; 初值为空时，则根据初始容量开辟空间来创建数组。否则， 因为我们使用2的幂定义数组大小，<span style="color:#CC0000;">数据要么待在原来的下标， 或者移动到新数组的高位下标</span>。 （举例： 初始数组是16个，假如有2个数据存储在下标为1的位置， 扩容后这2个数据可以存在下标为1或者16+1的位置）<br></span></p><p><span style="font-size:18px;">Returns:<br>&nbsp;&nbsp;&nbsp; the table<br>final Node&lt;K,V&gt;[] resize() {</span></p><p><span style="font-size:18px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ....</span></p><p><span style="font-size:18px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;newThr = oldThr &lt;&lt; 1;<span style="color:#009900;"> // double threshold,&nbsp;&nbsp; 大小扩大为2倍，出于性能考虑和者告诉使用者它是2的幂， 这里用的是位移， 而不是*2，<br></span></span></p><p><span style="font-size:18px;"><span style="color:#009900;"><br></span></span></p><p><span style="font-size:18px;">&nbsp;&nbsp; if (e.next == null)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; newTab[e.hash &amp; (newCap - 1)] = e;&nbsp;<span style="color:#009900;"> //如果该下标只有一个数据，则散列到当前位置或者高位对应位置（以第一次resize为例，原来在第4个位置，resize后会存储到第4个或者第4+16个位置）</span><br>&nbsp; else if (e instanceof TreeNode)<br>&nbsp;&nbsp;&nbsp;&nbsp; ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap);&nbsp;<span style="color:#009900;"> //红黑树重构</span><br></span></p><p><span style="font-size:18px;"><span style="color:#009900;"><span style="color:#000000;">&nbsp;&nbsp; else {</span></span><br></span></p><p><span style="font-size:18px;">&nbsp;&nbsp;&nbsp;&nbsp; do {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; next = e.next;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (<span style="color:#FF0000;">(e.hash &amp; oldCap) == 0</span>) {&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (loTail == null)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; loHead = e;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; loTail.next = e;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; loTail = e;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (hiTail == null)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hiHead = e;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hiTail.next = e;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hiTail = e;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } while ((e = next) != null);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (loTail != null) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; loTail.next = null;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; newTab[<span style="color:#FF0000;">j</span>] = loHead;&nbsp;&nbsp;<span style="color:#33CC00;"> //下标不变</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (hiTail != null) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hiTail.next = null;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; newTab[<span style="color:#FF0000;">j + oldCap</span>] = hiHead;<span style="color:#009900;"> //下标位置移动原来容量大小</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</span></p><p><span style="font-size:18px;">&nbsp;&nbsp; <span style="font-size:18px;"><span style="color:#FF0000;">(e.hash &amp; oldCap) == 0</span></span>写的很赞！！！ 它将原来的链表数据散列到2个下标位置，&nbsp; 概率是当前位置50%，高位位置50%。&nbsp;&nbsp;&nbsp;&nbsp; 你可能有点懵比， 下面举例说明。&nbsp; 上边图中第0个下标有496和896，&nbsp; 假设它俩的hashcode(int型，占4个字节)是</span></p><p><span style="font-size:18px;">resize前：<br></span></p><p><span style="font-size:18px;">496的hashcode: 00000000&nbsp; 00000000&nbsp; 00000000&nbsp; 00<span style="color:#FF0000;">0</span>00000</span></p><p><span style="font-size:18px;">896的hashcode: 01010000&nbsp; 01100000&nbsp; 10000000&nbsp; 00<span style="color:#CC0000;">1</span>00000</span></p><p><span style="font-size:18px;">oldCap是16:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 00000000&nbsp; 00000000&nbsp; 00000000&nbsp; 00010000<br></span></p><p><span style="font-size:18px;">&nbsp;&nbsp;&nbsp; <span style="font-size:18px;"><span style="font-size:18px;"><span style="color:#FF0000;"><span style="color:#000000;">496和896对应的</span>e.hash &amp; oldCap</span></span></span>的值为0， 即下标都是第0个。</span></p><p><span style="font-size:18px;"><br></span></p><p><span style="font-size:18px;">resize后：</span></p><p><span style="font-size:18px;"></span></p><p><span style="font-size:18px;">496的hashcode: 00000000&nbsp; 00000000&nbsp; 00000000&nbsp; 00<span style="color:#FF0000;">0</span>00000</span></p><p><span style="font-size:18px;">896的hashcode: 01010000&nbsp; 01100000&nbsp; 10000000&nbsp; 00<span style="color:#CC0000;">1</span>00000</span></p><span style="font-size:18px;">oldCap是32:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 00000000&nbsp; 00000000&nbsp; 00000000&nbsp; 00100000</span><p><span style="font-size:18px;"><span style="font-size:18px;"><span style="font-size:18px;">&nbsp;&nbsp;&nbsp;<span style="font-size:18px;"><span style="font-size:18px;"><span style="color:#FF0000;"><span style="color:#000000;">496和896对应的</span>e.hash &amp; oldCap</span></span></span>的值为0和1， 即下标都是第0个和第16个。</span></span></span></p><p><span style="font-size:18px;"><span style="font-size:18px;"><span style="font-size:18px;">&nbsp;&nbsp; 看明白了吗？&nbsp;&nbsp; 因为hashcode的第n位是0/1的概率相同， 理论上链表的数据会均匀分布到当前下标或高位数组对应下标。</span></span></span></p><p><span style="font-size:18px;"><span style="font-size:18px;"><span style="font-size:18px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 回顾JDK1.7的HashMap，在扩容时会rehash即每个entry的位置都要再计算一遍，&nbsp; 性能不好呀， 所以JDK1.8做了这个优化。<br></span></span></span></p><p><span style="font-size:18px;"><span style="font-size:18px;"><span style="font-size:18px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 再回到文章最开始的问题， HashMap为什么用&amp;得到下标，而不是%？&nbsp;&nbsp; 如果使用了取模%， 那么在容量变为2倍时， 需要rehash确定每个链表元素的位置。<br></span></span></span></p><p><span style="font-size:18px;"><span style="font-size:18px;"><span style="font-size:18px;">&nbsp;&nbsp;&nbsp;&nbsp; 很佩服HashMap的作者呀，&nbsp; 大师在运算符的使用上都是这么考究！！！</span></span><br></span></p><p><span style="font-size:18px;"><span style="font-size:18px;"><span style="font-size:18px;"><br></span></span></span></p><p><span style="font-size:18px;">PS: <span style="color:#ff0000;"><strong>顺便说一下ArrayList， 初始容量是10个， 每次扩容是原来的1.5倍。</strong></span></span></p><br>                                    </div>********]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://picsum.photos/800/205&quot; alt&gt;&lt;/p&gt;
&lt;h1 id=&quot;HashMap简介：&quot;&gt;&lt;a href=&quot;#HashMap简介：&quot; class=&quot;headerlink&quot; title=&quot;HashMap简介：&quot;&gt;&lt;/a&gt;&lt;strong&gt;HashMap简介&lt;/strong&gt;：&lt;/h1&gt;&lt;pre&gt;&lt;code&gt;HashMap在底层数据结构上采用了数组＋链表＋红黑树，通过散列映射来存储键值对数据因为在查询上使用散列码（通过键生成一个数字作为数组下标，
这个数字就是hashcode）所以在查询上的访问速度比较快，HashMap最多允许一对键值对的Key为Null，允许多对键值对的value为Null。
它是非线程安全的。在排序上面是无序的。&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
    
      <category term="Java" scheme="ayjcsgm.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>LinkedList类</title>
    <link href="ayjcsgm.github.io/2019/10/02/LinkedList%E7%B1%BB/"/>
    <id>ayjcsgm.github.io/2019/10/02/LinkedList类/</id>
    <published>2019-10-02T11:15:32.000Z</published>
    <updated>2019-10-03T09:18:06.851Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://picsum.photos/800/204" alt></p><article class="_2rhmJa"><h2>链表</h2><p>LinkedList是基于链表结构的一种List，在分析LinkedList源码前有必要对链表结构进行说明。</p><h3>链表的概念</h3><p>链表是由一系列非连续的节点组成的存储结构，简单分下类的话，链表又分为单向链表和双向链表，而单向/双向链表又可以分为循环链表和非循环链表，下面简单就这四种链表进行图解说明。</p><ol><a id="more"></a><li>单向链表<br>单向链表就是通过每个结点的指针指向下一个结点从而链接起来的结构，最后一个节点的next指向null。</li><p><img src="https://img-blog.csdnimg.cn/20191003165356244.png" alt="在这里插入图片描述"></p><ol start="2"><li>单向循环链表<br>单向循环链表和单向列表的不同是，最后一个节点的next不是指向null，而是指向head节点，形成一个“环”。</li><p><img src="https://img-blog.csdnimg.cn/20191003165619593.png" alt="在这里插入图片描述"></p><ol start="3"><li>双向链表<br>从名字就可以看出，双向链表是包含两个指针的，pre指向前一个节点，next指向后一个节点，但是第一个节点head的pre指向null，最后一个节点的tail指向null。</li><p><img src="https://img-blog.csdnimg.cn/2019100316572197.png" alt="在这里插入图片描述"></p><ol start="4"><li>双向循环链表<br>双向循环链表和双向链表的不同在于，第一个节点的pre指向最后一个节点，最后一个节点的next指向第一个节点，也形成一个“环”。<strong>而LinkedList就是基于双向循环链表设计的。</strong></li><p><img src="https://img-blog.csdnimg.cn/2019100316593257.png" alt="在这里插入图片描述"></p><h2 id="LinkedList简介"><a href="#LinkedList简介" class="headerlink" title="LinkedList简介"></a>LinkedList简介</h2><h3 id="LinkedList定义"><a href="#LinkedList定义" class="headerlink" title="LinkedList定义"></a>LinkedList定义</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">AbstractSequentialList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">Deque</span>&lt;<span class="title">E</span>&gt;, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></span><br></pre></td></tr></table></figure><p>LinkedList 是一个继承于AbstractSequentialList的双向循环链表。它也可以被当作堆栈、队列或双端队列进行操作。<br>LinkedList 实现 List 接口，能对它进行队列操作。<br>LinkedList 实现 Deque 接口，即能将LinkedList当作双端队列使用。<br>LinkedList 实现了Cloneable接口，即覆盖了函数clone()，能克隆。<br>LinkedList 实现java.io.Serializable接口，这意味着LinkedList支持序列化，能通过序列化去传输。<br>LinkedList 是非同步的。</p><h3 id="LinkedList属性"><a href="#LinkedList属性" class="headerlink" title="LinkedList属性"></a>LinkedList属性</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Entry&lt;E&gt; header = <span class="keyword">new</span> Entry&lt;E&gt;(<span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">int</span> size = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>LinkedList中提供了两个属性，其中size和ArrayList中一样用来计数，表示list的元素数量，而header则是链表的头结点，Entry则是链表的节点对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    E element;  <span class="comment">// 当前存储元素</span></span><br><span class="line">    Entry&lt;E&gt; next;  <span class="comment">// 下一个元素节点</span></span><br><span class="line">    Entry&lt;E&gt; previous;  <span class="comment">// 上一个元素节点</span></span><br><span class="line">    Entry(E element, Entry&lt;E&gt; next, Entry&lt;E&gt; previous) &#123;</span><br><span class="line">        <span class="keyword">this</span>.element = element;</span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">        <span class="keyword">this</span>.previous = previous;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Entry为LinkedList 的内部类，其中定义了当前存储的元素，以及该元素的上一个元素和下一个元素。</p><h3 id="LinkedList构造函数"><a href="#LinkedList构造函数" class="headerlink" title="LinkedList构造函数"></a>LinkedList构造函数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 构造一个空的LinkedList .</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//将header节点的前一节点和后一节点都设置为自身</span></span><br><span class="line">    header.next = header. previous = header ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 构造一个包含指定 collection 中的元素的列表，这些元素按其 collection 的迭代器返回的顺序排列</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>();</span><br><span class="line">    addAll(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意的是空的LinkedList构造方法，它将header节点的前一节点和后一节点都设置为自身，这里便说明LinkedList 是一个双向循环链表，如果只是单纯的双向链表而不是循环链表，他的实现应该是这样的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    header.next = <span class="keyword">null</span>;</span><br><span class="line">    header. previous = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>非循环链表的情况应该是header节点的前一节点和后一节点均为null（参见链表图解）。</p><h3 id="LinkedList源码解析-基于JDK1-6-0-45"><a href="#LinkedList源码解析-基于JDK1-6-0-45" class="headerlink" title="LinkedList源码解析(基于JDK1.6.0_45)"></a>LinkedList源码解析(基于JDK1.6.0_45)</h3><h3 id="增加"><a href="#增加" class="headerlink" title="增加"></a>增加</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将一个元素添加至list尾部</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">   <span class="comment">// 在header前添加元素e，header前就是最后一个结点啦，就是在最后一个结点的后面添加元素e</span></span><br><span class="line">   addBefore(e, header);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在指定位置添加元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果index等于list元素个数，则在队尾添加元素(header之前)，否则在index节点前添加元素</span></span><br><span class="line">    addBefore(element, (index== size ? header : entry(index)));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Entry&lt;E&gt; <span class="title">addBefore</span><span class="params">(E e, Entry&lt;E&gt; entry)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 用entry创建一个要添加的新节点，next为entry，previous为entry.previous，意思就是新节点插入entry前面，确定自身的前后引用，</span></span><br><span class="line">    Entry&lt;E&gt; newEntry = <span class="keyword">new</span> Entry&lt;E&gt;(e, entry, entry.previous);</span><br><span class="line">     <span class="comment">// 下面修改newEntry的前后节点的引用，确保其链表的引用关系是正确的</span></span><br><span class="line">    <span class="comment">// 将上一个节点的next指向自己</span></span><br><span class="line">    newEntry. previous.next = newEntry;</span><br><span class="line">    <span class="comment">// 将下一个节点的previous指向自己</span></span><br><span class="line">    newEntry. next.previous = newEntry;</span><br><span class="line">    <span class="comment">// 计数+1</span></span><br><span class="line">     size++;</span><br><span class="line">     modCount++;</span><br><span class="line">     <span class="keyword">return</span> newEntry;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到这里可以发现一点疑虑，header作为双向循环链表的头结点是不保存数据的，也就是说hedaer中的element永远等于null。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 添加一个集合元素到list中</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 将集合元素添加到list最后的尾部</span></span><br><span class="line">    <span class="keyword">return</span> addAll(size , c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在指定位置添加一个集合元素到list中</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(<span class="keyword">int</span> index, Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 越界检查</span></span><br><span class="line">    <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt; size)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException( <span class="string">"Index: "</span>+index+</span><br><span class="line">                                            <span class="string">", Size: "</span>+size );</span><br><span class="line">    Object[] a = c.toArray();</span><br><span class="line">    <span class="comment">// 要插入元素的个数</span></span><br><span class="line">    <span class="keyword">int</span> numNew = a.length ;</span><br><span class="line">    <span class="keyword">if</span> (numNew==<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    modCount++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 找出要插入元素的前后节点</span></span><br><span class="line">    <span class="comment">// 获取要插入index位置的下一个节点，如果index正好是lsit尾部的位置那么下一个节点就是header，否则需要查找index位置的节点</span></span><br><span class="line">    Entry&lt;E&gt; successor = (index== size ? header : entry(index));</span><br><span class="line">    <span class="comment">// 获取要插入index位置的上一个节点，因为是插入，所以上一个点击就是未插入前下一个节点的上一个</span></span><br><span class="line">    Entry&lt;E&gt; predecessor = successor. previous;</span><br><span class="line">    <span class="comment">// 循环插入</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;numNew; i++) &#123;</span><br><span class="line">        <span class="comment">// 构造一个节点，确认自身的前后引用</span></span><br><span class="line">        Entry&lt;E&gt; e = <span class="keyword">new</span> Entry&lt;E&gt;((E)a[i], successor, predecessor);</span><br><span class="line">        <span class="comment">// 将插入位置上一个节点的下一个元素引用指向当前元素（这里不修改下一个节点的上一个元素引用，是因为下一个节点随着循环一直在变）</span></span><br><span class="line">        predecessor. next = e;</span><br><span class="line">        <span class="comment">// 最后修改插入位置的上一个节点为自身，这里主要是为了下次遍历后续元素插入在当前节点的后面，确保这些元素本身的顺序</span></span><br><span class="line">        predecessor = e;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 遍历完所有元素，最后修改下一个节点的上一个元素引用为遍历的最后一个元素</span></span><br><span class="line">    successor. previous = predecessor;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 修改计数器</span></span><br><span class="line">    size += numNew;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20191003170532363.png" alt="在这里插入图片描述"><br>增加方法的代码理解起来可能有些困难，但是只要理解了双向链表的存储结构，掌握增加的核心逻辑就可以了，这里总结一下往链表中增加元素的核心逻辑：1.将元素转换为链表节点，2.增加该节点的前后引用（即pre和next分别指向哪一个节点），3.前后节点对该节点的引用（前节点的next指向该节点，后节点的pre指向该节点）。现在再看下就这么简单么，就是<strong>改变前后的互相指向关系</strong>（看图增加元素前后的变化）。</p><p>删除也是一样的，下面看看删除方法的实现。</p><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 删除第一个匹配的指定元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">     <span class="comment">// 遍历链表找到要被删除的节点</span></span><br><span class="line">    <span class="keyword">if</span> (o==<span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (Entry&lt;E&gt; e = header .next; e != header; e = e.next ) &#123;</span><br><span class="line">            <span class="keyword">if</span> (e.element ==<span class="keyword">null</span>) &#123;</span><br><span class="line">                remove(e);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Entry&lt;E&gt; e = header .next; e != header; e = e.next ) &#123;</span><br><span class="line">            <span class="keyword">if</span> (o.equals(e.element )) &#123;</span><br><span class="line">                remove(e);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> E <span class="title">remove</span><span class="params">(Entry&lt;E&gt; e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (e == header )</span><br><span class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 被删除的元素，供返回</span></span><br><span class="line">    E result = e. element;</span><br><span class="line">   <span class="comment">// 下面修正前后对该节点的引用</span></span><br><span class="line">   <span class="comment">// 将该节点的上一个节点的next指向该节点的下一个节点</span></span><br><span class="line">   e. previous.next = e.next;</span><br><span class="line">   <span class="comment">// 将该节点的下一个节点的previous指向该节点的上一个节点</span></span><br><span class="line">   e. next.previous = e.previous;</span><br><span class="line">   <span class="comment">// 修正该节点自身的前后引用</span></span><br><span class="line">    e. next = e.previous = <span class="keyword">null</span>;</span><br><span class="line">   <span class="comment">// 将自身置空，让gc可以尽快回收</span></span><br><span class="line">    e. element = <span class="keyword">null</span>;</span><br><span class="line">   <span class="comment">// 计数器减一</span></span><br><span class="line">    size--;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于节点被删除，该节点的上一个节点和下一个节点互相拉一下小手就可以了，注意的是“互相”，不能一厢情愿。</p><h3 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 修改指定位置索引位置的元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">set</span><span class="params">( <span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 查找index位置的节点</span></span><br><span class="line">    Entry&lt;E&gt; e = entry(index);</span><br><span class="line">    <span class="comment">// 取出该节点的元素，供返回使用</span></span><br><span class="line">    E oldVal = e. element;</span><br><span class="line">    <span class="comment">// 用新元素替换旧元素</span></span><br><span class="line">    e. element = element;</span><br><span class="line">    <span class="comment">// 返回旧元素</span></span><br><span class="line">    <span class="keyword">return</span> oldVal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>set方法看起来简单了很多，只要修改该节点上的元素就好了，但是不要忽略了这里的entry()方法，重点就是它。</p><h3 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h3><p>终于到查询了，终于发现了上面经常出现的那个方法entry()根据index查询节点，我们知道数组是有下标的，通过下标操作天然的支持根据index查询元素，而链表中是没有index概念呢，那么怎么样才能通过index查询到对应的元素呢，下面就来看看LinkedList是怎么实现的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 查找指定索引位置的元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">( <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> entry(index).element ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回指定索引位置的节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Entry&lt;E&gt; <span class="title">entry</span><span class="params">( <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 越界检查</span></span><br><span class="line">    <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= size)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException( <span class="string">"Index: "</span>+index+</span><br><span class="line">                                            <span class="string">", Size: "</span>+size );</span><br><span class="line">    <span class="comment">// 取出头结点</span></span><br><span class="line">    Entry&lt;E&gt; e = header;</span><br><span class="line">    <span class="comment">// size&gt;&gt;1右移一位代表除以2，这里使用简单的二分方法，判断index与list的中间位置的距离</span></span><br><span class="line">    <span class="keyword">if</span> (index &lt; (size &gt;&gt; <span class="number">1</span>)) &#123;</span><br><span class="line">        <span class="comment">// 如果index距离list中间位置较近，则从头部向后遍历(next)</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= index; i++)</span><br><span class="line">            e = e. next;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果index距离list中间位置较远，则从头部向前遍历(previous)</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = size; i &gt; index; i--)</span><br><span class="line">            e = e. previous;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>LinkedList是通过从header开始index计为0，然后一直往下遍历（next），直到到index位置。为了优化查询效率，LinkedList采用了<strong>二分查找</strong>（这里说的二分只是简单的一次二分），判断index与size中间位置的距离，采取从header向后还是向前查找。<br><strong>到这里我们明白，基于双向循环链表实现的LinkedList，通过索引Index的操作是低效的，index所对应的元素越靠近中间所费时间越长。而向链表两端插入和删除元素则是非常高效的（如果不是两端的话，都需要对链表进行遍历查找）</strong>。</p><h3 id="是否包含"><a href="#是否包含" class="headerlink" title="是否包含"></a>是否包含</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断LinkedList是否包含元素(o)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> indexOf(o) != -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从前向后查找，返回“值为对象(o)的节点对应的索引”</span></span><br><span class="line"><span class="comment">// 不存在就返回-1</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (o==<span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (Entry e = header .next; e != header; e = e.next ) &#123;</span><br><span class="line">            <span class="keyword">if</span> (e.element ==<span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> index;</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Entry e = header .next; e != header; e = e.next ) &#123;</span><br><span class="line">            <span class="keyword">if</span> (o.equals(e.element ))</span><br><span class="line">                <span class="keyword">return</span> index;</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从后向前查找，返回“值为对象(o)的节点对应的索引”</span></span><br><span class="line"><span class="comment">// 不存在就返回-1</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lastIndexOf</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> index = size ;</span><br><span class="line">    <span class="keyword">if</span> (o==<span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (Entry e = header .previous; e != header; e = e.previous ) &#123;</span><br><span class="line">            index--;</span><br><span class="line">            <span class="keyword">if</span> (e.element ==<span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> index;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Entry e = header .previous; e != header; e = e.previous ) &#123;</span><br><span class="line">            index--;</span><br><span class="line">            <span class="keyword">if</span> (o.equals(e.element ))</span><br><span class="line">                <span class="keyword">return</span> index;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和public boolean remove(Object o) 一样，indexOf查询元素位于容器的索引位置，都是需要对链表进行遍历操作，当然也就是低效了啦。</p><h3 id="判断容量"><a href="#判断容量" class="headerlink" title="判断容量"></a>判断容量</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns the number of elements in this list.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the number of elements in this list</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> size ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;This implementation returns &lt;tt&gt;size() == 0 &lt;/tt&gt;.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> size() == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和ArrayList一样，基于计数器size操作，容量判断很方便。</p><h3 id="LinkedList实现的Deque双端队列"><a href="#LinkedList实现的Deque双端队列" class="headerlink" title="LinkedList实现的Deque双端队列"></a>LinkedList实现的Deque双端队列</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Adds the specified element as the tail (last element) of this list.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> e the element to add</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &lt;tt&gt; true&lt;/tt&gt; (as specified by &#123;<span class="doctag">@link</span> Queue#offer&#125;)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.5</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> add(e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Retrieves and removes the head (first element) of this list</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the head of this list, or &lt;tt&gt;null &lt;/tt&gt; if this list is empty</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.5</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">poll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (size ==<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">return</span> removeFirst();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Removes and returns the first element from this list.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the first element from this list</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NoSuchElementException if this list is empty</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">removeFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> remove(header .next);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Retrieves, but does not remove, the head (first element) of this list.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the head of this list, or &lt;tt&gt;null &lt;/tt&gt; if this list is empty</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.5</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (size ==<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">return</span> getFirst();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns the first element in this list.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the first element in this list</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NoSuchElementException if this list is empty</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">getFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (size ==<span class="number">0</span>)</span><br><span class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> header .next. element;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Pushes an element onto the stack represented by this list.  In other</span></span><br><span class="line"><span class="comment"> * words, inserts the element at the front of this list.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;This method is equivalent to &#123;<span class="doctag">@link</span> #addFirst&#125;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> e the element to push</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.6</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    addFirst(e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Inserts the specified element at the beginning of this list.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> e the element to add</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addFirst</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">   addBefore(e, header.next );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看看Deque 的实现是不是很简单，逻辑都是基于上面讲的链表操作的。</p><p><strong>总结</strong>：<br>(01) LinkedList 实际上是通过双向链表去实现的。<br>它包含一个非常重要的内部类：<strong>Entry</strong>。Entry是<strong>双向链表节点</strong>所对应的数据结构，它包括的属性有：<strong>当前节点所包含的值，上一个节点，下一个节点</strong>。<br>(02) 从LinkedList的实现方式中可以发现，它不存在LinkedList容量不足的问题。<br>(03) LinkedList的克隆函数，即是将全部元素克隆到一个新的LinkedList对象中。<br>(04) LinkedList实现java.io.Serializable。当写入到输出流时，先写入“容量”，再依次写入“每一个节点保护的值”；当读出输入流时，先读取“容量”，再依次读取“每一个元素”。<br>(05) 由于LinkedList实现了Deque，而Deque接口定义了在双端队列两端访问元素的方法。提供插入、移除和检查元素的方法。每种方法都存在两种形式：一种形式在操作失败时抛出异常，另一种形式返回一个特殊值（null 或 false，具体取决于操作）。</p><h3 id="对LinkedList以及ArrayList的迭代效率比较"><a href="#对LinkedList以及ArrayList的迭代效率比较" class="headerlink" title="对LinkedList以及ArrayList的迭代效率比较"></a>对LinkedList以及ArrayList的迭代效率比较</h3><p><strong>结论：ArrayList使用最普通的for循环遍历比较快，LinkedList使用foreach循环比较快。</strong></p><p>看一下两个List的定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">RandomAccess</span>, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">AbstractSequentialList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">Deque</span>&lt;<span class="title">E</span>&gt;, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></span><br></pre></td></tr></table></figure><p>注意到ArrayList是实现了RandomAccess接口而LinkedList则没有实现这个接口，关于RandomAccess这个接口的作用，看一下JDK API上的说法：<br><img src="https://img-blog.csdnimg.cn/20191003171202800.png" alt="在这里插入图片描述"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>ArrayList和LinkedList的比较<br>1、顺序插入速度ArrayList会比较快，因为ArrayList是基于数组实现的，数组是事先new好的，只要往指定位置塞一个数据就好了；LinkedList则不同，每次顺序插入的时候LinkedList将new一个对象出来，如果对象比较大，那么new的时间势必会长一点，再加上一些引用赋值的操作，所以顺序插入LinkedList必然慢于ArrayList</p><p>2、基于上一点，因为LinkedList里面不仅维护了待插入的元素，还维护了Entry的前置Entry和后继Entry，如果一个LinkedList中的Entry非常多，那么LinkedList将比ArrayList更耗费一些内存</p><p>3、数据遍历的速度，结论是：<strong>使用各自遍历效率最高的方式，ArrayList的遍历效率会比LinkedList的遍历效率高一些</strong></p><p>4、有些说法认为LinkedList做插入和删除更快，这种说法其实是不准确的：</p><p>（1）LinkedList做插入、删除的时候，慢在寻址，快在只需要改变前后Entry的引用地址</p><p>（2）ArrayList做插入、删除的时候，慢在数组元素的批量copy，快在寻址</p><p>所以，<strong>如果待插入、删除的元素是在数据结构的前半段尤其是非常靠前的位置的时候，LinkedList的效率将大大快过ArrayList，因为ArrayList将批量copy大量的元素；越往后，对于LinkedList来说，因为它是双向链表，所以在第2个元素后面插入一个数据和在倒数第2个元素后面插入一个元素在效率上基本没有差别，但是ArrayList由于要批量copy的元素越来越少，操作速度必然追上乃至超过LinkedList。</strong></p><p>从这个分析看出，如果你十分确定你插入、删除的元素是在前半段，那么就使用LinkedList；如果你十分确定你删除、删除的元素在比较靠后的位置，那么可以考虑使用ArrayList。如果你不能确定你要做的插入、删除是在哪儿呢？那还是建议你使用LinkedList吧，因为一来LinkedList整体插入、删除的执行效率比较稳定，没有ArrayList这种越往后越快的情况；二来插入元素的时候，弄得不好ArrayList就要进行一次扩容，记住，<strong>ArrayList底层数组扩容是一个既消耗时间又消耗空间的操作。</strong></p><p>参考<br>该文为本人学习的笔记，读取了网上好几篇大牛的心得，其中主要是摘取了<a href="https://www.jianshu.com/p/d5ec2ff72b33" target="_blank" rel="noopener">该网站</a>当中的内容，请勿怪，谨当复习使用。</p></ol></ol></ol></ol></article>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://picsum.photos/800/204&quot; alt&gt;&lt;/p&gt;
&lt;article class=&quot;_2rhmJa&quot;&gt;&lt;h2&gt;链表&lt;/h2&gt;
&lt;p&gt;LinkedList是基于链表结构的一种List，在分析LinkedList源码前有必要对链表结构进行说明。&lt;/p&gt;
&lt;h3&gt;链表的概念&lt;/h3&gt;
&lt;p&gt;链表是由一系列非连续的节点组成的存储结构，简单分下类的话，链表又分为单向链表和双向链表，而单向/双向链表又可以分为循环链表和非循环链表，下面简单就这四种链表进行图解说明。&lt;/p&gt;
&lt;ol&gt;
    
    </summary>
    
    
    
      <category term="Java" scheme="ayjcsgm.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>ArrayList类</title>
    <link href="ayjcsgm.github.io/2019/10/01/%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AAArrayList/"/>
    <id>ayjcsgm.github.io/2019/10/01/简单实现一个ArrayList/</id>
    <published>2019-10-01T14:51:31.000Z</published>
    <updated>2019-10-01T16:04:15.779Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://picsum.photos/800/203" alt></p><h3>文章目录</h3><ul><li><a href="#javautilArrayListE_1" rel="nofollow" data-token="a618d5c35048e22d7511fddbfa6ee751" target="_self">`java.util.ArrayList`</a></li><li><a href="#ArrayList_22" rel="nofollow" data-token="5a05523de9f87613c99147e08fca875e" target="_self">数组和`ArrayList`的比较</a></li><li><a href="#1_54" rel="nofollow" data-token="dfaf009b3756283764874bc887e1f05a" target="_self">例1</a></li><li><a href="#2_127" rel="nofollow" data-token="a248e5df85b56d1bafc8ae15376be2f4" target="_self">例2</a></li><li><a href="#font_color0099fffont_173" rel="nofollow" data-token="379d5f661a035f153be4b7639bbc7353" target="_self"><font color="#0099ff">书后的练习<font></font></font></a></li></ul><p></p><a id="more"></a> <h1><a name="t1"></a><a id="javautilArrayListE_1"></a><code>java.util.ArrayList&lt;E&gt;</code></h1><p>从书中各种代码来看，<code>java.util.ArrayList&lt;E&gt;</code> 是非常重要的一个类，在代码中广泛使用，<code>E</code>表示泛型，<code>ArrayList</code>是一个泛型类。<br><code>ArrayList</code>相当于C++ 的<code>vector</code>，用于存储对象。与数组不同，数组一旦创建，长度固定，但是<code>ArrayList</code>的长度是动态的，不受限制，可以存储任意多的对象，但是只能存储对象，不能存储原生数据类型例如<code>int</code>。</p><div class="table-box"><table><thead><tr><th>java.util.ArrayList &lt; E &gt; 的一些方法</th><th>描述</th></tr></thead><tbody><tr><td>+ArrayList()</td><td>构造函数，创建一个空的列表, size为0</td></tr><tr><td>+add(o: E): void</td><td>在list的末尾添加一个元素o</td></tr><tr><td>+add(index: int, o: E): void</td><td>在指定的index处插入元素o</td></tr><tr><td>+clear(): void</td><td>从list中删除所有元素</td></tr><tr><td>+contains(o: Object): boolean</td><td>如果list含有元素o，返回true</td></tr><tr><td>+get(index: int): E</td><td>返回指定index处的元素</td></tr><tr><td>+indexOf(o: Object): int</td><td>返回list中第一个匹配元素的index</td></tr><tr><td>+isEmpty(): boolean</td><td>如果list不含元素，返回true</td></tr><tr><td>+lastIndexOf(o: Object): int</td><td>返回list中最后一个匹配元素的index</td></tr><tr><td>+remove(o: Object): boolean</td><td>删除list中的第一个元素o，如果元素被删除，返回true</td></tr><tr><td>+size(): int</td><td>返回list中元素个数</td></tr><tr><td>+remove(index: int): boolean</td><td>删除指定index处的元素，如果元素被删除，返回true</td></tr><tr><td>+set(index: int, o: E): E</td><td>设置指定index处的元素为o</td></tr></tbody></table></div><h1><a name="t2"></a><a id="ArrayList_22"></a>数组和<code>ArrayList</code>的比较</h1><div class="table-box"><table><thead><tr><th>操作</th><th>Array</th><th>ArrayList</th></tr></thead><tbody><tr><td>创建 array/ArrayList</td><td>String[] a = new String[10]</td><td>ArrayList list = new ArrayList&lt;&gt;();</td></tr><tr><td>访问一个元素</td><td>a[index]</td><td>list.get(index);</td></tr><tr><td>更新一个元素</td><td>a[index] = “London”;</td><td>list.set(index, “London”);</td></tr><tr><td>返回大小</td><td>a.length</td><td>list.size();</td></tr><tr><td>排序</td><td>java.util.Arrays.sort(array)</td><td>java.util.Collections.sort(arraylist)</td></tr><tr><td>添加一个新元素</td><td>相当复杂</td><td>list.add(“London”);</td></tr><tr><td>插入一个新元素</td><td>相当复杂</td><td>list.add(index, “London”);</td></tr><tr><td>删除一个元素</td><td>相当复杂</td><td>list.remove(index);</td></tr><tr><td>删除一个元素</td><td>相当复杂</td><td>list.remove(Object);</td></tr><tr><td>删除所有元素</td><td>？</td><td>list.clear();</td></tr></tbody></table></div><p>创建一个存储字符串的ArrayList对象：</p><pre class="prettyprint"><code class="prism language-java has-numbering" onclick="mdcp.copyCode(event)" style="position: unset;">ArrayList<span class="token generics function"><span class="token punctuation">&lt;</span>String<span class="token punctuation">&gt;</span></span> cities <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics function"><span class="token punctuation">&lt;</span>String<span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><div class="hljs-button {2}" data-title="复制"></div></code><ul class="pre-numbering" style></ul></pre><p>创建一个存储日期的ArrayList对象：</p><pre class="prettyprint"><code class="prism language-java has-numbering" onclick="mdcp.copyCode(event)" style="position: unset;">ArrayList<span class="token operator">&lt;</span>java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>Date<span class="token operator">&gt;</span> dates <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span>java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>Date<span class="token operator">&gt;</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><div class="hljs-button {2}" data-title="复制"></div></code><ul class="pre-numbering" style></ul></pre><p>JDK 7 之后，下述表达式</p><pre class="prettyprint"><code class="prism language-java has-numbering" onclick="mdcp.copyCode(event)" style="position: unset;">ArrayList<span class="token generics function"><span class="token punctuation">&lt;</span>AConcreteType<span class="token punctuation">&gt;</span></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics function"><span class="token punctuation">&lt;</span>AConcreteType<span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><div class="hljs-button {2}" data-title="复制"></div></code><ul class="pre-numbering" style></ul></pre><p>可以简化为：</p><pre class="prettyprint"><code class="prism language-java has-numbering" onclick="mdcp.copyCode(event)" style="position: unset;">ArrayList<span class="token generics function"><span class="token punctuation">&lt;</span>AConcreteType<span class="token punctuation">&gt;</span></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><div class="hljs-button {2}" data-title="复制"></div></code><ul class="pre-numbering" style></ul></pre><p>因为编译器有一个新的feature叫做类型推断(type inference)， 能够从变量声明推断类型。</p><h1><a name="t3"></a><a id="1_54"></a>例1</h1><pre class="prettyprint"><code class="prism language-java has-numbering" onclick="mdcp.copyCode(event)" style="position: unset;"><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>ArrayList<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TestArrayList</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">// Create a list to store cities</span>        ArrayList<span class="token generics function"><span class="token punctuation">&lt;</span>String<span class="token punctuation">&gt;</span></span> cityList <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics function"><span class="token punctuation">&lt;</span>String<span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><div class="hljs-button {2}" data-title="复制"></div></code><ul class="pre-numbering" style></ul></pre><p>其中<code>System.out.println(cityList.toString());</code> 等同于 <code>System.out.println(cityList);</code></p><p><code>toString()</code>方法返回列表的字符串表示，形式为 <code>[e0.toString(), e1.toString(), ..., ek.toString()]</code>，<code>e0, e1, . . . ,</code>和 <code>ek</code> 都是列表中的元素。</p><p>由于ArrayList只能存储对象，不能存储原生数据类型数据，下面的代码是错误的：<br><code>ArrayList&lt;int&gt; list = new ArrayList&lt;&gt;();</code> <strong>错误！！！！！</strong><br>只能写成：<br><code>ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;();</code></p><h1><a name="t4"></a><a id="2_127"></a>例2</h1><p>用户输入一个数字序列，假定输入以<code>0</code>结尾，且<code>0</code>不计入数字序列，打印序列中不重复的数字：</p><pre class="prettyprint"><code class="prism language-java has-numbering" onclick="mdcp.copyCode(event)" style="position: unset;"><span class="token keyword">package</span> TEST_ALL<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>ArrayList<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>Scanner<span class="token punctuation">;</span><p><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">DistinctNumbers</span> <span class="token punctuation">{</span><br>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span><br>        ArrayList<span class="token generics function"><span class="token punctuation">&lt;</span>Integer<span class="token punctuation">&gt;</span></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics function"><span class="token punctuation">&lt;</span>Integer<span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>        Scanner input <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Scanner</span><span class="token punctuation">(</span>System<span class="token punctuation">.</span>in<span class="token punctuation">)</span><span class="token punctuation">;</span><br>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token string">“Enter integers (input ends with 0): “</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>        <span class="token keyword">int</span> value<span class="token punctuation">;</span><br>        <span class="token keyword">do</span> <span class="token punctuation">{</span><br>            value <span class="token operator">=</span> input<span class="token punctuation">.</span><span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Read a value from the input</span><br>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>list<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> value <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span><br>            list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Add the value if it is not in the list</span><br>        <span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span>value <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>        <span class="token comment">// Display the distinct numbers</span><br>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> list<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><br>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span>list<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">“ “</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>    <span class="token punctuation">}</span><br><span class="token punctuation">}</span></p><div class="hljs-button {2}" data-title="复制"></div></code><ul class="pre-numbering" style></ul></pre><p>运行结果：</p><pre class="prettyprint"><code class="has-numbering" onclick="mdcp.copyCode(event)" style="position: unset;">Enter integers (input ends with 0): 2 32 3 1 2 3 2 9 02 32 3 1 9 <div class="hljs-button {2}" data-title="复制"></div></code><ul class="pre-numbering" style></ul></pre><p>可以用下列 foreach 循环遍历一个array list：</p><pre class="prettyprint"><code class="prism language-java has-numbering" onclick="mdcp.copyCode(event)" style="position: unset;"><span class="token keyword">for</span> <span class="token punctuation">(</span>elementType element<span class="token operator">:</span> arrayList<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">// Process the element </span><span class="token punctuation">}</span><div class="hljs-button {2}" data-title="复制"></div></code><ul class="pre-numbering" style></ul></pre><p>例如上例中的语句：</p><pre class="prettyprint"><code class="prism language-java has-numbering" onclick="mdcp.copyCode(event)" style="position: unset;"><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> list<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span>list<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">" "</span><span class="token punctuation">)</span><span class="token punctuation">;</span><div class="hljs-button {2}" data-title="复制"></div></code><ul class="pre-numbering" style></ul></pre><p>可以改写为：</p><pre class="prettyprint"><code class="prism language-java has-numbering" onclick="mdcp.copyCode(event)" style="position: unset;"><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> number<span class="token operator">:</span> list<span class="token punctuation">)</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span>number <span class="token operator">+</span> <span class="token string">" "</span><span class="token punctuation">)</span><span class="token punctuation">;</span><div class="hljs-button {2}" data-title="复制"></div></code><ul class="pre-numbering" style></ul></pre><h1><a name="t5"></a><a id="font_color0099fffont_173"></a><font color="#0099ff">书后的练习<font></font></font></h1><p>我做的答案：</p><p><strong>11.30 How do you do the following?</strong></p><p>a. Create an ArrayList for storing double values?</p><pre class="prettyprint"><code class="prism language-java has-numbering" onclick="mdcp.copyCode(event)" style="position: unset;">ArrayList<span class="token generics function"><span class="token punctuation">&lt;</span>Double<span class="token punctuation">&gt;</span></span> list_double <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics function"><span class="token punctuation">&lt;</span>Double<span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>`<div class="hljs-button {2}" data-title="复制"></div></code><ul class="pre-numbering" style></ul></pre><p>b. Append an object to a list?</p><pre class="prettyprint"><code class="prism language-java has-numbering" onclick="mdcp.copyCode(event)" style="position: unset;">Double o <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Double</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span><span class="token punctuation">;</span>list_double<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>o<span class="token punctuation">)</span><span class="token punctuation">;</span><div class="hljs-button {2}" data-title="复制"></div></code><ul class="pre-numbering" style></ul></pre><p>c. Insert an object at the beginning of a list?</p><pre class="prettyprint"><code class="prism language-java has-numbering" onclick="mdcp.copyCode(event)" style="position: unset;">Double o <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Double</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span><span class="token punctuation">;</span>list_double<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> o<span class="token punctuation">)</span><span class="token punctuation">;</span><div class="hljs-button {2}" data-title="复制"></div></code><ul class="pre-numbering" style></ul></pre><p>d. Find the number of objects in a list?</p><pre class="prettyprint"><code class="prism language-java has-numbering" onclick="mdcp.copyCode(event)" style="position: unset;">list_double<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><div class="hljs-button {2}" data-title="复制"></div></code><ul class="pre-numbering" style></ul></pre><p>e. Remove a given object from a list?</p><pre class="prettyprint"><code class="prism language-java has-numbering" onclick="mdcp.copyCode(event)" style="position: unset;">Double o <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Double</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">while</span><span class="token punctuation">(</span>list_double<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span>o<span class="token punctuation">)</span><span class="token punctuation">)</span>    list_double<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>o<span class="token punctuation">)</span><span class="token punctuation">;</span><div class="hljs-button {2}" data-title="复制"></div></code><ul class="pre-numbering" style></ul></pre><p>f. Remove the last object from the list?</p><pre class="prettyprint"><code class="prism language-java has-numbering" onclick="mdcp.copyCode(event)" style="position: unset;">list_double<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>list_double<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><div class="hljs-button {2}" data-title="复制"></div></code><ul class="pre-numbering" style></ul></pre><p>g. Check whether a given object is in a list?</p><pre class="prettyprint"><code class="prism language-java has-numbering" onclick="mdcp.copyCode(event)" style="position: unset;">Double o <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Double</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>list_double<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span>o<span class="token punctuation">)</span><span class="token punctuation">)</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"Y"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">else</span>     System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"N"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><div class="hljs-button {2}" data-title="复制"></div></code><ul class="pre-numbering" style></ul></pre><p>h. Retrieve an object at a specified index from a list?</p><pre class="prettyprint"><code class="prism language-java has-numbering" onclick="mdcp.copyCode(event)" style="position: unset;"><span class="token keyword">int</span> index <span class="token operator">=</span> <span class="token number">111</span><span class="token punctuation">;</span>list_double<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">;</span><div class="hljs-button {2}" data-title="复制"></div></code><ul class="pre-numbering" style></ul></pre><p><strong>11.31 Identify the errors in the following code.</strong></p><pre class="prettyprint"><code class="prism language-java has-numbering" onclick="mdcp.copyCode(event)" style="position: unset;">ArrayList<span class="token generics function"><span class="token punctuation">&lt;</span>String<span class="token punctuation">&gt;</span></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"Denver"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"Austin"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> # 错误，元素数据类型必须一致，不能改成DateString city <span class="token operator">=</span> list<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>list<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token string">"Dallas"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> #System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>list<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> # 错误，index 超出 size<div class="hljs-button {2}" data-title="复制"></div></code><ul class="pre-numbering" style></ul></pre><p><code>list.set(3, "Dallas")</code>; 和<code>list.get(3)</code>都是错的，You cannot use the <code>get(index)</code> and <code>set(index, element)</code> methods if the element is not in the list. 看源代码，<code>get</code> 和 <code>set</code> 都有<code>RangeCheck(index);</code> 这个函数：</p><pre class="prettyprint"><code class="prism language-java has-numbering" onclick="mdcp.copyCode(event)" style="position: unset;"><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">RangeCheck</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>index <span class="token operator">&gt;=</span> size<span class="token punctuation">)</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IndexOutOfBoundsException</span><span class="token punctuation">(</span><span class="token string">"Index: "</span><span class="token operator">+</span>index<span class="token operator">+</span><span class="token string">", Size: "</span><span class="token operator">+</span>size<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><div class="hljs-button {2}" data-title="复制"></div></code><ul class="pre-numbering" style></ul></pre><p><strong>11.32</strong> Suppose the <code>ArrayList list</code> contains <code>{"Dallas", "Dallas", "Houston", "Dallas"}</code>.What is the  <code>list</code> after invoking <code>list.remove("Dallas")</code>one time?<br>Does the following code correctly remove all elements with value <code>"Dallas"</code> from<br>the <code>list</code>?  If not, correct the code.</p><pre class="prettyprint"><code class="prism language-java has-numbering" onclick="mdcp.copyCode(event)" style="position: unset;"><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> list<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>    list<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token string">"Dallas"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><div class="hljs-button {2}" data-title="复制"></div></code><ul class="pre-numbering" style></ul></pre><p>调用一次<code>list.remove("Dallas")</code>， <code>list</code> 变为 <code>{ "Dallas", "Houston", "Dallas"}</code>，<br>code不能完全删除 <code>"Dallas"</code>，因为最后结果是<code>{"House", "Dallas"}</code>， 应该改成：</p><pre class="prettyprint"><code class="prism language-java has-numbering" onclick="mdcp.copyCode(event)" style="position: unset;"><span class="token keyword">while</span><span class="token punctuation">(</span>list<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span><span class="token string">"Dallas"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    list<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token string">"Dallas"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><div class="hljs-button {2}" data-title="复制"></div></code><ul class="pre-numbering" style></ul></pre><p><strong>11.33 Explain why the following code displays [1, 3] rather than [2, 3].</strong></p><pre class="prettyprint"><code class="prism language-java has-numbering" onclick="mdcp.copyCode(event)" style="position: unset;">ArrayList<span class="token generics function"><span class="token punctuation">&lt;</span>Integer<span class="token punctuation">&gt;</span></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>list<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>list<span class="token punctuation">)</span><span class="token punctuation">;</span><div class="hljs-button {2}" data-title="复制"></div></code><ul class="pre-numbering" style></ul></pre><p>因为<code>remove</code>方法有两种签名：<code>list.remove(Object)</code>，<code>list.remove(index)</code>;  此处调用的是第二种，如果要删除第一个元素，必须改成<code>list.remove((Integer)1)</code>.<br>(这里不是特别理解)</p><p><strong>11.34 Explain why the following code is wrong.</strong></p><pre class="prettyprint"><code class="prism language-java has-numbering" onclick="mdcp.copyCode(event)" style="position: unset;">ArrayList<span class="token generics function"><span class="token punctuation">&lt;</span>Double<span class="token punctuation">&gt;</span></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><div class="hljs-button {2}" data-title="复制"></div></code><ul class="pre-numbering" style></ul></pre><p>错误是因为， <code>1</code> 为整型，与 <code>Double</code> 类型不符，必须改成 <code>1.0</code>.<br>也不能改为<code>list.add((Double)1)</code>, 否则会显示 inconvertible type 的错误.</p><hr><p>[1] Introduction to Java Programming 10th edition  Chapter 11.11</p><pre><code>&lt;/div&gt;</code></pre><p>简单实现一个ArrayList类</p><pre><code>package hqp.MyArrayList;public class test {    //ArrayList底层是个object类型的数组    Object[] value;    //数组中被使用的数量    int count;    //空构造    public test() {        // value=new Object[10];        this(10);    }    // 参数构造器    public test(int length) {        value = new Object[length];    }    //添加add方法    public void add(Object o) {        value[count] = o;        count++;        if (count &gt;= value.length) {            Object[] newlist = new Object[value.length * 2 + 1];            for (int i = 0; i &lt; value.length; i++) {                newlist[i] = value[i];            }            value = newlist;        }    }    //重写tostring    @Override    public String toString() {        StringBuilder stringBuilder = new StringBuilder();        stringBuilder.append(&quot;[&quot;);        for (int i = 0; i &lt;=count-1; i++) {            stringBuilder.append(value[i] + &quot;,&quot;);        }        stringBuilder.setCharAt(stringBuilder.length() - 1, &apos;]&apos;);        return stringBuilder.toString();    }    private boolean isEmpty() {        return count==1;    }    private void clear() {        for (int i = 0; i &lt;count ; i++) {            value[i]=&quot;&quot;;            count=1;        }    }    private void remove(Object o) {        for (int i = 0; i &lt; count; i++) {            if (o.equals(value[i])) {                s(i);            }        }    }    private void s(int i) {        int s = count - i - 1;        if (s &gt; 0) {            System.arraycopy(value, i + 1, value, i, s);            value[--count] = null;        }    }    public static void main(String[] args) {        //创建一个自定义的数组的对象        test list = new test();        list.add(&quot;aaa&quot;);        list.add(1123);        list.add(1123);        list.add(1123);        list.add(1123);        list.add(1123);        list.add(1123);        list.add(1123);        list.add(1123);        list.add(1123);        list.add(1123);        list.remove(&quot;aaa&quot;);        System.out.println(list);        list.clear();        System.out.println(list);        System.out.println(list.isEmpty());    }}</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://picsum.photos/800/203&quot; alt&gt;&lt;/p&gt;
&lt;h3&gt;文章目录&lt;/h3&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;#javautilArrayListE_1&quot; rel=&quot;nofollow&quot; data-token=&quot;a618d5c35048e22d7511fddbfa6ee751&quot; target=&quot;_self&quot;&gt;`java.util.ArrayList`&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;#ArrayList_22&quot; rel=&quot;nofollow&quot; data-token=&quot;5a05523de9f87613c99147e08fca875e&quot; target=&quot;_self&quot;&gt;数组和`ArrayList`的比较&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;#1_54&quot; rel=&quot;nofollow&quot; data-token=&quot;dfaf009b3756283764874bc887e1f05a&quot; target=&quot;_self&quot;&gt;例1&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;#2_127&quot; rel=&quot;nofollow&quot; data-token=&quot;a248e5df85b56d1bafc8ae15376be2f4&quot; target=&quot;_self&quot;&gt;例2&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;#font_color0099fffont_173&quot; rel=&quot;nofollow&quot; data-token=&quot;379d5f661a035f153be4b7639bbc7353&quot; target=&quot;_self&quot;&gt;&lt;font color=&quot;#0099ff&quot;&gt;书后的练习&lt;font&gt;&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="Java" scheme="ayjcsgm.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络面试问题集锦</title>
    <link href="ayjcsgm.github.io/2019/10/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%E9%9B%86%E9%94%A6/"/>
    <id>ayjcsgm.github.io/2019/10/01/计算机网络面试问题集锦/</id>
    <published>2019-10-01T08:18:25.000Z</published>
    <updated>2019-10-02T11:17:31.650Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://picsum.photos/800/202" alt></p><hr><p><strong>摘要：</strong></p><p>本文对面试/笔试过程中经常会被问到的一些关于计算机网络的问题进行了梳理和总结。关于这块内容的初步了解和掌握，建议大家读一读《图解HTTP》一书。</p><hr><a id="more"></a> <p><strong>1、Http和Https的区别</strong></p><p>　　Http协议运行在TCP之上，明文传输，客户端与服务器端都无法验证对方的身份；Https是身披SSL(Secure Socket Layer)外壳的Http，运行于SSL上，SSL运行于TCP之上，是添加了加密和认证机制的HTTP。二者之间存在如下不同：</p><ul><li><p>端口不同：Http与Http使用不同的连接方式，用的端口也不一样，前者是80，后者是443；</p></li><li><p>资源消耗：和HTTP通信相比，Https通信会由于加减密处理消耗更多的CPU和内存资源；</p></li><li><p>开销：Https通信需要证书，而证书一般需要向认证机构购买； <br>　 <br>Https的加密机制是一种共享密钥加密和公开密钥加密并用的混合加密机制。</p></li></ul><hr><p><strong>2、对称加密与非对称加密</strong></p><p>　　对称密钥加密是指加密和解密使用同一个密钥的方式，这种方式存在的最大问题就是密钥发送问题，即如何安全地将密钥发给对方；而非对称加密是指使用一对非对称密钥，即公钥和私钥，公钥可以随意发布，但私钥只有自己知道。发送密文的一方使用对方的公钥进行加密处理，对方接收到加密信息后，使用自己的私钥进行解密。</p><p>　　由于非对称加密的方式不需要发送用来解密的私钥，所以可以保证安全性；但是和对称加密比起来，它非常的慢，所以我们还是要用对称加密来传送消息，但对称加密所使用的密钥我们可以通过非对称加密的方式发送出去。</p><hr><p><strong>3、三次握手与四次挥手</strong></p><p>　(1). 三次握手(我要和你建立链接，你真的要和我建立链接么，我真的要和你建立链接，成功)：</p><ul><li><p>第一次握手：Client将标志位SYN置为1，随机产生一个值seq=J，并将该数据包发送给Server，Client进入SYN_SENT状态，等待Server确认。</p></li><li><p>第二次握手：Server收到数据包后由标志位SYN=1知道Client请求建立连接，Server将标志位SYN和ACK都置为1，ack=J+1，随机产生一个值seq=K，并将该数据包发送给Client以确认连接请求，Server进入SYN_RCVD状态。</p></li><li><p>第三次握手：Client收到确认后，检查ack是否为J+1，ACK是否为1，如果正确则将标志位ACK置为1，ack=K+1，并将该数据包发送给Server，Server检查ack是否为K+1，ACK是否为1，如果正确则连接建立成功，Client和Server进入ESTABLISHED状态，完成三次握手，随后Client与Server之间可以开始传输数据了。</p><p>　　　　　　　　　　　　<img src="http://static.zybuluo.com/Rico123/c7m5fo6qdua0q7me88jm9w10/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.png" alt="三次握手.png-12.4kB" title></p></li></ul><hr><p>　(2). 四次挥手(我要和你断开链接；好的，断吧。我也要和你断开链接；好的，断吧)：</p><ul><li><p>第一次挥手：Client发送一个FIN，<font color="red"><b>用来关闭Client到Server的数据传送</b></font>，Client进入FIN_WAIT_1状态。</p></li><li><p>第二次挥手：Server收到FIN后，发送一个ACK给Client，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号），Server进入CLOSE_WAIT状态。此时TCP链接处于半关闭状态，即客户端已经没有要发送的数据了，但服务端若发送数据，则客户端仍要接收。</p></li><li><p>第三次挥手：Server发送一个FIN，<font color="red"><b>用来关闭Server到Client的数据传送</b></font>，Server进入LAST_ACK状态。</p></li><li><p>第四次挥手：Client收到FIN后，Client进入TIME_WAIT状态，接着发送一个ACK给Server，确认序号为收到序号+1，Server进入CLOSED状态，完成四次挥手。</p><p>　　　　　　　　　　　　<img src="http://static.zybuluo.com/Rico123/ardiuu1otopo9f1jd4df18iz/%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B.png" alt="四次挥手.png-12.6kB" title></p></li></ul><hr><p><strong>4、为什么TCP链接需要三次握手，两次不可以么，为什么？</strong></p><p>　　为了防止 <font color="red"><b>已失效的链接请求报文突然又传送到了服务端</b></font>，因而产生错误。</p><p>　　客户端发出的连接请求报文并未丢失，而是在某个网络节点长时间滞留了，以致延误到链接释放以后的某个时间才到达Server。这是，Server误以为这是Client发出的一个新的链接请求，于是就向客户端发送确认数据包，同意建立链接。若不采用“三次握手”，那么只要Server发出确认数据包，新的链接就建立了。由于client此时并未发出建立链接的请求，所以其不会理睬Server的确认，也不与Server通信；而这时Server一直在等待Client的请求，这样Server就白白浪费了一定的资源。若采用“三次握手”，在这种情况下，由于Server端没有收到来自客户端的确认，则就会知道Client并没有要求建立请求，就不会建立链接。</p><hr><p><strong>5、TCP协议如何来保证传输的可靠性</strong></p><p>　　TCP提供一种面向连接的、可靠的字节流服务。其中，面向连接意味着两个使用TCP的应用（通常是一个客户和一个服务器）在彼此交换数据之前必须先建立一个TCP连接。在一个TCP连接中，仅有两方进行彼此通信；而字节流服务意味着两个应用程序通过TCP链接交换8bit字节构成的字节流，TCP不在字节流中插入记录标识符。</p><p>　　<strong>对于可靠性，TCP通过以下方式进行保证：</strong></p><ul><li><p><font color="red">数据包校验：</font>目的是检测数据在传输过程中的任何变化，若校验出包有错，则丢弃报文段并且不给出响应，这时TCP发送数据端超时后会重发数据；</p></li><li><p><font color="red">对失序数据包重排序：</font>既然TCP报文段作为IP数据报来传输，而IP数据报的到达可能会失序，因此TCP报文段的到达也可能会失序。TCP将对失序数据进行重新排序，然后才交给应用层；</p></li><li><p><font color="red">丢弃重复数据：</font>对于重复数据，能够丢弃重复数据；</p></li><li><p><font color="red">应答机制：</font>当TCP收到发自TCP连接另一端的数据，它将发送一个确认。这个确认不是立即发送，通常将推迟几分之一秒；</p></li><li><p><font color="red">超时重发：</font>当TCP发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段；</p></li><li><p><font color="red">流量控制：</font>TCP连接的每一方都有固定大小的缓冲空间。TCP的接收端只允许另一端发送接收端缓冲区所能接纳的数据，这可以防止较快主机致使较慢主机的缓冲区溢出，这就是流量控制。TCP使用的流量控制协议是可变大小的滑动窗口协议。</p></li></ul><hr><p><strong>6、客户端不断进行请求链接会怎样？DDos(Distributed Denial of Service)攻击？</strong></p><p>　　服务器端会为每个请求创建一个链接，并向其发送确认报文，然后等待客户端进行确认</p><hr><p>1)、DDos 攻击</p><ul><li>客户端向服务端发送请求链接数据包</li><li>服务端向客户端发送确认数据包</li><li>客户端不向服务端发送确认数据包，服务器一直等待来自客户端的确认</li></ul><hr><p>2)、DDos 预防<font color="red"><b> ( 没有彻底根治的办法，除非不使用TCP )</b></font></p><ul><li>限制同时打开SYN半链接的数目</li><li>缩短SYN半链接的Time out 时间</li><li>关闭不必要的服务</li></ul><hr><p><strong>7、Get与POST的区别</strong></p><p>　　GET与POST是我们常用的两种HTTP Method，二者之间的区别主要包括如下五个方面： </p><p>(1). 从功能上讲，GET一般用来从服务器上获取资源，POST一般用来更新服务器上的资源；</p><p>(2). 从REST服务角度上说，GET是幂等的，即读取同一个资源，总是得到相同的数据，而POST不是幂等的，因为每次请求对资源的改变并不是相同的；进一步地，GET不会改变服务器上的资源，而POST会对服务器资源进行改变；</p><p>(3). 从请求参数形式上看，GET请求的数据会附在URL之后，即将请求数据放置在HTTP报文的<font color="red"> 请求头 </font>中，以?分割URL和传输数据，参数之间以&amp;相连。特别地，如果数据是英文字母/数字，原样发送；否则，会将其编码为 application/x-www-form-urlencoded MIME 字符串(如果是空格，转换为+，如果是中文/其他字符，则直接把字符串用BASE64加密，得出如：%E4%BD%A0%E5%A5%BD，其中％XX中的XX为该符号以16进制表示的ASCII)；而POST请求会把提交的数据则放置在是HTTP请求报文的 <font color="red">请求体</font> 中。</p><p>(4). 就安全性而言，POST的安全性要比GET的安全性高，因为GET请求提交的数据将明文出现在URL上，而且POST请求参数则被包装到请求体中，相对更安全。</p><p>(5). 从请求的大小看，GET请求的长度受限于浏览器或服务器对URL长度的限制，允许发送的数据量比较小，而POST请求则是没有大小限制的。</p><hr><p>1). GET请求中URL编码的意义</p><p>　　我们知道，在GET请求中会对URL中非西文字符进行编码，这样做的目的就是为了 <font color="red"><b>避免歧义</b></font>。看下面的例子，</p><p>　　针对“name1=value1&amp;name2=value2”的例子，我们来谈一下数据从客户端到服务端的解析过程。首先，上述字符串在计算机中用ASCII吗表示为： </p><pre class="prettyprint" name="code"><code class="language-text hljs mathematica has-numbering" onclick="mdcp.copyCode(event)" style="position: unset;">   <span class="hljs-number">6E616</span>D6531 <span class="hljs-number">3</span><span class="hljs-keyword">D</span> <span class="hljs-number">76616</span>C756531 <span class="hljs-number">26</span> <span class="hljs-number">6E616</span>D6532 <span class="hljs-number">3</span><span class="hljs-keyword">D</span> <span class="hljs-number">76616</span>C756532   <span class="hljs-number">6E616</span>D6531：name1    <span class="hljs-number">3</span><span class="hljs-keyword">D</span>：=    <span class="hljs-number">76616</span>C756531：value1    <span class="hljs-number">26</span>：&amp;   <span class="hljs-number">6E616</span>D6532：name2    <span class="hljs-number">3</span><span class="hljs-keyword">D</span>：=    <span class="hljs-number">76616</span>C756532：value2 <div class="hljs-button {2}" data-title="复制"></div></code><ul class="pre-numbering" style></ul></pre><p>　　服务端在接收到该数据后就可以遍历该字节流，一个字节一个字节的吃，当吃到3D这字节后，服务端就知道前面吃得字节表示一个key，再往后吃，如果遇到26，说明从刚才吃的3D到26子节之间的是上一个key的value，以此类推就可以解析出客户端传过来的参数。</p><p>　　现在考虑这样一个问题，如果我们的参数值中就包含=或&amp;这种特殊字符的时候该怎么办？比如，“name1=value1”，其中value1的值是“va&amp;lu=e1”字符串，那么实际在传输过程中就会变成这样“name1=va&amp;lu=e1”。这样，我们的本意是只有一个键值对，但是服务端却会解析成两个键值对，这样就产生了歧义。</p><p>　　那么，如何解决上述问题带来的歧义呢？解决的办法就是对参数进行URL编码：例如，我们对上述会产生歧义的字符进行URL编码后结果：“name1=va%26lu%3D”，这样服务端会把紧跟在“%”后的字节当成普通的字节，就是不会把它当成各个参数或键值对的分隔符。</p><hr><p><strong>8、TCP与UDP的区别</strong></p><p>　　TCP (Transmission Control Protocol)和UDP(User Datagram Protocol)协议属于传输层协议，它们之间的区别包括：</p><ul><li><p>TCP是面向连接的，UDP是无连接的；</p></li><li><p>TCP是可靠的，UDP是不可靠的；</p></li><li><p>TCP只支持点对点通信，UDP支持一对一、一对多、多对一、多对多的通信模式；</p></li><li><p>TCP是面向字节流的，UDP是面向报文的；</p></li><li><p>TCP有拥塞控制机制;UDP没有拥塞控制，适合媒体通信；</p></li><li><p>TCP首部开销(20个字节)比UDP的首部开销(8个字节)要大；</p></li></ul><hr><p><strong>9、TCP的拥塞处理</strong></p><p>　　计算机网络中的带宽、交换结点中的缓存及处理机等都是网络的资源。在某段时间，若对网络中某一资源的需求超过了该资源所能提供的可用部分，网络的性能就会变坏，这种情况就叫做拥塞。拥塞控制就是 <font color="red">防止过多的数据注入网络中，这样可以使网络中的路由器或链路不致过载</font>。注意，<font color="red"><b>拥塞控制和流量控制不同，前者是一个全局性的过程，而后者指点对点通信量的控制。</b></font>拥塞控制的方法主要有以下四种：</p><hr><p>1). <font color="red"><b>慢启动：</b></font>不要一开始就发送大量的数据，先探测一下网络的拥塞程度，也就是说由小到大逐渐增加拥塞窗口的大小;</p><hr><p>2). <font color="red"><b>拥塞避免：</b></font>拥塞避免算法让拥塞窗口缓慢增长，即每经过一个往返时间RTT就把发送方的拥塞窗口cwnd加1，而不是加倍，这样拥塞窗口按线性规律缓慢增长。</p><p>　　　　　　　　　　<img src="http://static.zybuluo.com/Rico123/whi0y5sbc3tx9qcdp0s532gw/%E6%85%A2%E5%BC%80%E5%A7%8B%E4%B8%8E%E6%8B%A5%E5%A1%9E%E9%81%BF%E5%85%8D.png" alt="慢开始与拥塞避免.png-90.3kB" title></p><hr><p>3). <font color="red"><b>快重传：</b></font>快重传要求接收方在收到一个 <font color="red"><b>失序的报文段</b></font> 后就立即发出 <font color="red"><b>重复确认</b></font>（为的是使发送方及早知道有报文段没有到达对方）而不要等到自己发送数据时捎带确认。快重传算法规定，发送方只要一连收到三个重复确认就应当立即重传对方尚未收到的报文段，而不必继续等待设置的重传计时器时间到期。</p><p>　　　　　　　　　　<img src="http://static.zybuluo.com/Rico123/wuktdms9jtg4s9m4pe5kcbiq/%E5%BF%AB%E9%87%8D%E4%BC%A0.jpg" alt="快重传.jpg-42.3kB" title></p><hr><p>4). <font color="red"><b>快恢复：</b></font>快重传配合使用的还有快恢复算法，当发送方连续收到三个重复确认时，就执行“乘法减小”算法，把ssthresh门限减半，但是接下去并不执行慢开始算法：因为如果网络出现拥塞的话就不会收到好几个重复的确认，所以发送方现在认为网络可能没有出现拥塞。所以此时不执行慢开始算法，而是将cwnd设置为ssthresh的大小，然后执行拥塞避免算法。</p><p>　　　　　　　　　　<img src="http://static.zybuluo.com/Rico123/90am1vmd7408ef00mav8pfzk/%E5%BF%AB%E6%81%A2%E5%A4%8D.jpg" alt="快恢复.jpg-52.9kB" title></p><hr><p><strong>10、从输入网址到获得页面的过程</strong></p><p>　　(1). 浏览器查询 DNS，获取域名对应的IP地址:具体过程包括浏览器搜索自身的DNS缓存、搜索操作系统的DNS缓存、读取本地的Host文件和向本地DNS服务器进行查询等。对于向本地DNS服务器进行查询，如果要查询的域名包含在本地配置区域资源中，则返回解析结果给客户机，完成域名解析(此解析具有权威性)；如果要查询的域名不由本地DNS服务器区域解析，但该服务器已缓存了此网址映射关系，则调用这个IP地址映射，完成域名解析（此解析不具有权威性）。如果本地域名服务器并未缓存该网址映射关系，那么将根据其设置发起递归查询或者迭代查询；</p><p>　　(2). 浏览器获得域名对应的IP地址以后，浏览器向服务器请求建立链接，发起三次握手；</p><p>　　(3). TCP/IP链接建立起来后，浏览器向服务器发送HTTP请求；</p><p>　　(4). 服务器接收到这个请求，并根据路径参数映射到特定的请求处理器进行处理，并将处理结果及相应的视图返回给浏览器；</p><p>　　(5). 浏览器解析并渲染视图，若遇到对js文件、css文件及图片等静态资源的引用，则重复上述步骤并向服务器请求这些资源；</p><p>　　(6). 浏览器根据其请求到的资源、数据渲染页面，最终向用户呈现一个完整的页面。</p><hr><p><strong>11、Session、Cookie 与 Application</strong></p><p>　　Cookie和Session都是客户端与服务器之间保持状态的解决方案，具体来说，cookie机制采用的是在客户端保持状态的方案，而session机制采用的是在服务器端保持状态的方案。</p><hr><p>(1). Cookie及其相关API</p><p>　　Cookie实际上是一小段的文本信息。客户端请求服务器，如果服务器需要记录该用户状态，就使用response向客户端浏览器颁发一个Cookie，而客户端浏览器会把Cookie保存起来。当浏览器再请求该网站时，浏览器把请求的网址连同该Cookie一同提交给服务器，服务器检查该Cookie，以此来辨认用户状态。服务器还可以根据需要修改Cookie的内容。</p><p>　　　　　　　　　　　<img src="http://static.zybuluo.com/Rico123/obkdzovq0ozu2oib430o9xvp/Cookoe-HttpServletResponse.png" alt="Cookoe-HttpServletResponse.png-38.6kB" title></p><p>　　　　　　　　　　　<img src="http://static.zybuluo.com/Rico123/q07mgp37mzhj1krtg0m46jvu/HttpServletrequest-cookie.png" alt="HttpServletrequest-cookie.png-8.6kB" title></p><hr><p>(2). Session及其相关API</p><p>　　同样地，会话状态也可以保存在服务器端。客户端请求服务器，如果服务器记录该用户状态，就获取Session来保存状态，这时，如果服务器已经为此客户端创建过session，服务器就按照sessionid把这个session检索出来使用；如果客户端请求不包含sessionid，则为此客户端创建一个session并且生成一个与此session相关联的sessionid，并将这个sessionid在本次响应中返回给客户端保存。保存这个sessionid的方式可以采用<font color="red"> cookie机制 </font>，这样在交互过程中浏览器可以自动的按照规则把这个标识发挥给服务器；若浏览器禁用Cookie的话，可以通过 <font color="red">URL重写机制</font> 将sessionid传回服务器。</p><p>　　　　　　　　　　　<img src="http://static.zybuluo.com/Rico123/fgsd064ji0ggxwmqosky1n1q/Session-HttpServletRequest.png" alt="Session-HttpServletRequest.png-10.1kB" title></p><hr><p>(3). Session 与 Cookie 的对比</p><ul><li><p><font color="red">实现机制：</font>Session的实现常常依赖于Cookie机制，通过Cookie机制回传SessionID；</p></li><li><p><font color="red">大小限制：</font>Cookie有大小限制并且浏览器对每个站点也有cookie的个数限制，Session没有大小限制，理论上只与服务器的内存大小有关；</p></li><li><p><font color="red">安全性：</font>Cookie存在安全隐患，通过拦截或本地文件找得到cookie后可以进行攻击，而Session由于保存在服务器端，相对更加安全；</p></li><li><p><font color="red">服务器资源消耗：</font>Session是保存在服务器端上会存在一段时间才会消失，如果session过多会增加服务器的压力。</p><p>Application（ServletContext）：与一个Web应用程序相对应，为应用程序提供了一个全局的状态，所有客户都可以使用该状态。</p></li></ul><hr><p>(4). Application</p><p>　　Application（Java Web中的ServletContext）：与一个Web应用程序相对应，为应用程序提供了一个全局的状态，所有客户都可以使用该状态。</p><hr><p><strong>12、SQL 注入</strong></p><p>　　SQL注入就是通过把SQL命令插入到Web表单提交或输入域名或页面请求的查询字符串，最终达到欺骗服务器执行恶意的SQL命令。</p><p>1). SQL注入攻击的总体思路</p><p>　　(1). 寻找到SQL注入的位置 <br>　　(2). 判断服务器类型和后台数据库类型 <br>　　(3). 针对不通的服务器和数据库特点进行SQL注入攻击</p><hr><p>2). SQL注入攻击实例</p><p>　　比如，在一个登录界面，要求输入用户名和密码，可以这样输入实现免帐号登录：</p><pre class="prettyprint" name="code"><code class="language-text hljs lua has-numbering" onclick="mdcp.copyCode(event)" style="position: unset;">用户名： ‘<span class="hljs-keyword">or</span> <span class="hljs-number">1</span> = <span class="hljs-number">1</span> <span class="hljs-comment">--</span>密 码：<div class="hljs-button {2}" data-title="复制"></div></code><ul class="pre-numbering" style></ul></pre><p>　　用户一旦点击登录，如若没有做特殊处理，那么这个非法用户就很得意的登陆进去了。这是为什么呢?下面我们分析一下：从理论上说，后台认证程序中会有如下的SQL语句：String sql = “select * from user_table where username=’ “+userName+” ’ and password=’ “+password+” ‘”; 因此，当输入了上面的用户名和密码，上面的SQL语句变成：<font color="red">SELECT * FROM user_table WHERE username=’’or 1 = 1 – and password=’’</font>。分析上述SQL语句我们知道， <br>username=‘ or 1=1 这个语句一定会成功；然后后面加两个-，这意味着注释，它将后面的语句注释，让他们不起作用。这样，上述语句永远都能正确执行，用户轻易骗过系统，获取合法身份。</p><hr><p>3). 应对方法</p><p>(1). 参数绑定</p><p>　　使用预编译手段，绑定参数是最好的防SQL注入的方法。目前许多的ORM框架及JDBC等都实现了SQL预编译和参数绑定功能，攻击者的恶意SQL会被当做SQL的参数而不是SQL命令被执行。在mybatis的mapper文件中，对于传递的参数我们一般是使用#和<span>$</span>来获取参数值。当使用#时，变量是占位符，就是一般我们使用javajdbc的PrepareStatement时的占位符，所有可以防止sql注入；当使用$时，变量就是直接追加在sql中，一般会有sql注入问题。</p><p>(2). 使用正则表达式过滤传入的参数</p><hr><p><strong>13、 XSS 攻击</strong></p><p>　　XSS是一种经常出现在web应用中的计算机安全漏洞，与SQL注入一起成为web中最主流的攻击方式。XSS是指恶意攻击者利用网站没有对用户提交数据进行转义处理或者过滤不足的缺点，进而添加一些脚本代码嵌入到web页面中去，使别的用户访问都会执行相应的嵌入代码，从而盗取用户资料、利用用户身份进行某种动作或者对访问者进行病毒侵害的一种攻击方式。</p><hr><p>1). XSS攻击的危害</p><ul><li><p>盗取各类用户帐号，如机器登录帐号、用户网银帐号、各类管理员帐号</p></li><li><p>控制企业数据，包括读取、篡改、添加、删除企业敏感数据的能力</p></li><li><p>盗窃企业重要的具有商业价值的资料</p></li><li><p>非法转账</p></li><li><p>强制发送电子邮件</p></li><li><p>网站挂马</p></li><li><p>控制受害者机器向其它网站发起攻击</p></li></ul><hr><p>2). 原因解析</p><p>　　<font color="red">主要原因：</font>过于信任客户端提交的数据！</p><p>　　<font color="red">解决办法：</font>不信任任何客户端提交的数据，只要是客户端提交的数据就应该先进行相应的过滤处理然后方可进行下一步的操作。</p><p>　　<font color="red">进一步分析细节：</font>客户端提交的数据本来就是应用所需要的，但是恶意攻击者利用网站对客户端提交数据的信任，在数据中插入一些符号以及javascript代码，那么这些数据将会成为应用代码中的一部分了，那么攻击者就可以肆无忌惮地展开攻击啦，因此我们绝不可以信任任何客户端提交的数据！！！</p><hr><p>3). XSS 攻击分类</p><p>(1). 反射性XSS攻击 (非持久性XSS攻击)</p><p>　　漏洞产生的原因是攻击者注入的数据反映在响应中。一个典型的非持久性XSS攻击包含一个带XSS攻击向量的链接(即每次攻击需要用户的点击)，例如，正常发送消息：</p><pre class="prettyprint" name="code"><code class="language-text hljs avrasm has-numbering" onclick="mdcp.copyCode(event)" style="position: unset;"><span class="hljs-label">http:</span>//www<span class="hljs-preprocessor">.test</span><span class="hljs-preprocessor">.com</span>/message<span class="hljs-preprocessor">.php</span>?send=Hello,World！<div class="hljs-button {2}" data-title="复制"></div></code><ul class="pre-numbering" style></ul></pre><p>接收者将会接收信息并显示Hello,World；但是，非正常发送消息：</p><pre class="prettyprint" name="code"><code class="language-text hljs xml has-numbering" onclick="mdcp.copyCode(event)" style="position: unset;">http://www.test.com/message.php?send=<span class="hljs-tag">&lt;<span class="hljs-title">script</span>&gt;</span><span class="javascript">alert(‘foolish!’)</span><span class="hljs-tag">&lt;/<span class="hljs-title">script</span>&gt;</span>！<div class="hljs-button {2}" data-title="复制"></div></code><ul class="pre-numbering" style></ul></pre><p>接收者接收消息显示的时候将会弹出警告窗口！</p><hr><p>(2). 持久性XSS攻击 (留言板场景)</p><p>　　XSS攻击向量(一般指XSS攻击代码)存储在网站数据库，当一个页面被用户打开的时候执行。也就是说，每当用户使用浏览器打开指定页面时，脚本便执行。与非持久性XSS攻击相比，持久性XSS攻击危害性更大。从名字就可以了解到，持久性XSS攻击就是将攻击代码存入数据库中，然后客户端打开时就执行这些攻击代码。</p><pre class="prettyprint"><code class="has-numbering" onclick="mdcp.copyCode(event)" style="position: unset;">例如，留言板表单中的表单域：<div class="hljs-button {2}" data-title="复制"></div></code><ul class="pre-numbering" style></ul></pre><pre class="prettyprint" name="code"><code class="language-text hljs xml has-numbering" onclick="mdcp.copyCode(event)" style="position: unset;"><span class="hljs-tag">&lt;<span class="hljs-title">input</span> <span class="hljs-attribute">type</span>=<span class="hljs-value">“text”</span> <span class="hljs-attribute">name</span>=<span class="hljs-value">“content”</span> <span class="hljs-attribute">value</span>=<span class="hljs-value">“这里是用户填写的数据”</span>&gt;</span><div class="hljs-button {2}" data-title="复制"></div></code><ul class="pre-numbering" style></ul></pre><p>正常操作流程是：用户是提交相应留言信息 —— 将数据存储到数据库 —— 其他用户访问留言板，应用去数据并显示；而非正常操作流程是攻击者在value填写:</p><pre class="prettyprint" name="code"><code class="language-javascript hljs  has-numbering" onclick="mdcp.copyCode(event)" style="position: unset;">&lt;script&gt;alert(‘foolish!’)；&lt;<span class="hljs-regexp">/script&gt; &lt;!--或者html其他标签（破坏样式。。。）、一段攻击型代码--&gt;</span><div class="hljs-button {2}" data-title="复制"></div></code><ul class="pre-numbering" style></ul></pre><p>并将数据提交、存储到数据库中；当其他用户取出数据显示的时候，将会执行这些攻击性代码。</p><hr><p>4). 修复漏洞方针</p><p>　　漏洞产生的根本原因是 <font color="red">太相信用户提交的数据，对用户所提交的数据过滤不足所导致的</font>，因此解决方案也应该从这个方面入手，具体方案包括：</p><ul><li><p>将重要的cookie标记为http only, 这样的话Javascript 中的document.cookie语句就不能 <br>获取到cookie了（如果在cookie中设置了HttpOnly属性，那么通过js脚本将无法读取到cookie信息，这样能有效的防止XSS攻击）；</p></li><li><p>表单数据规定值的类型，例如：年龄应为只能为int、name只能为字母数字组合。。。。</p></li><li><p>对数据进行Html Encode 处理</p></li><li><p>过滤或移除特殊的Html标签，例如: &lt;script&gt;, &lt;iframe&gt; , &lt; for &lt;, &gt; for&gt;, &amp;quot for</p></li><li><p>过滤JavaScript 事件的标签，例如 “οnclick=”, “onfocus” 等等。</p><p>　　需要注意的是，在有些应用中是允许html标签出现的，甚至是javascript代码出现。因此，我们在过滤数据的时候需要仔细分析哪些数据是有特殊要求（例如输出需要html代码、javascript代码拼接、或者此表单直接允许使用等等），然后区别处理！</p></li></ul><hr><p><strong>14、OSI网络体系结构与TCP/IP协议模型</strong></p><p>　　为了更好地了解计算机网络体系结构，笔者以两篇博客的篇幅来介绍这个计算机网络中最为重要的知识点，具体见<a href="http://blog.csdn.net/justloveyou_/article/details/69611328" rel="nofollow" target="_blank" data-token="fa5059c63a22260eef663a726421d953">《计算机网络体系结构综述（上）》</a> 和 <a href="http://blog.csdn.net/justloveyou_/article/details/69612153" rel="nofollow" target="_blank" data-token="2c8e3fa61109fce6dac5d9c5eeb094f8">《计算机网络体系结构综述（下）》</a>。下面只做简要的总结。</p><p>　　在<a href="http://blog.csdn.net/justloveyou_/article/details/69612153" rel="nofollow" target="_blank" data-token="2c8e3fa61109fce6dac5d9c5eeb094f8">《计算机网络体系结构综述（下）》</a>一文中，我们知道TCP/IP与OSI最大的不同在于：OSI是一个理论上的网络通信模型，而TCP/IP则是实际上的网络通信标准。但是，它们的初衷是一样的，都是为了使得两台计算机能够像两个知心朋友那样能够互相准确理解对方的意思并做出优雅的回应。现在，我们对OSI七层模型的各层进行简要的介绍：</p><p>　　　　　　　　　　<img src="http://static.zybuluo.com/Rico123/0qwq331jj8bzgmqst282f6lp/OSI%E7%BD%91%E7%BB%9C%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E4%B8%8ETCPIP%E5%8D%8F%E8%AE%AE%E6%A8%A1%E5%9E%8B.png" alt="OSI网络体系结构与TCPIP协议模型.png-51.3kB" title></p><hr><p>1). 物理层</p><p>　　参考模型的最低层，也是OSI模型的第一层，实现了相邻计算机节点之间比特流的透明传送，并尽可能地屏蔽掉具体传输介质和物理设备的差异，使其上层(数据链路层)不必关心网络的具体传输介质。</p><hr><p>2). 数据链路层（data link layer）</p><p>　　接收来自物理层的位流形式的数据，并封装成帧，传送到上一层；同样，也将来自上层的数据帧，拆装为位流形式的数据转发到物理层。这一层在物理层提供的比特流的基础上，通过差错控制、流量控制方法，使有差错的物理线路变为无差错的数据链路，即提供可靠的通过物理介质传输数据的方法。</p><hr><p>3). 网络层</p><p>　　将网络地址翻译成对应的物理地址，并通过路由选择算法为分组通过通信子网选择最适当的路径。</p><p>　　　　　　　　　　<img src="http://static.zybuluo.com/Rico123/ed9145bf4nus32fr7umxxnk7/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%E4%B8%8E%E7%BD%91%E8%B7%AF%E5%B1%82.png" alt="数据链路层与网路层.png-58.4kB" title></p><hr><p>4). 传输层（transport layer）</p><p>　　在源端与目的端之间提供可靠的透明数据传输，使上层服务用户不必关系通信子网的实现细节。在协议栈中，传输层位于网络层之上，传输层协议为不同主机上运行的进程提供逻辑通信，而网络层协议为不同主机提供逻辑通信，如下图所示。</p><p>　　　　　　　　　　<img src="http://static.zybuluo.com/Rico123/5td1y45fm09cbhgw07o6fgfc/%E7%BD%91%E8%B7%AF%E5%B1%82%E4%B8%8E%E4%BC%A0%E8%BE%93%E5%B1%82.png" alt="网路层与传输层.png-52.8kB" title></p><p>　　实际上，网络层可以看作是传输层的一部分，其为传输层提供服务。但对于终端系统而言，网络层对它们而言是透明的，它们知道传输层的存在，也就是说，在逻辑上它们认为是传输层为它们提供了端对端的通信，这也是分层思想的妙处。</p><hr><p>5). 会话层（Session Layer）</p><p>　　会话层是OSI模型的第五层，是用户应用程序和网络之间的接口，负责在网络中的两节点之间建立、维持和终止通信。</p><hr><p>6). 表示层（Presentation Layer）：数据的编码，压缩和解压缩，数据的加密和解密</p><p>　　表示层是OSI模型的第六层，它对来自应用层的命令和数据进行解释，以确保一个系统的应用层所发送的信息可以被另一个系统的应用层读取。</p><hr><p>7). 应用层（Application layer）：为用户的应用进程提供网络通信服务</p><hr><p><strong>15、TCP和UDP分别对应的常见应用层协议</strong></p><p>1). TCP对应的应用层协议</p><ul><li><p><font color="red">FTP</font>：定义了文件传输协议，使用21端口。常说某某计算机开了FTP服务便是启动了文件传输服务。下载文件，上传主页，都要用到FTP服务。</p></li><li><p><font color="red">Telnet</font>：它是一种用于远程登陆的端口，用户可以以自己的身份远程连接到计算机上，通过这种端口可以提供一种基于DOS模式下的通信服务。如以前的BBS是-纯字符界面的，支持BBS的服务器将23端口打开，对外提供服务。</p></li><li><p><font color="red">SMTP</font>：定义了简单邮件传送协议，现在很多邮件服务器都用的是这个协议，用于发送邮件。如常见的免费邮件服务中用的就是这个邮件服务端口，所以在电子邮件设置-中常看到有这么SMTP端口设置这个栏，服务器开放的是25号端口。</p></li><li><p><font color="red">POP3</font>：它是和SMTP对应，POP3用于接收邮件。通常情况下，POP3协议所用的是110端口。也是说，只要你有相应的使用POP3协议的程序（例如Fo-xmail或Outlook），就可以不以Web方式登陆进邮箱界面，直接用邮件程序就可以收到邮件（如是163邮箱就没有必要先进入网易网站，再进入自己的邮-箱来收信）。</p></li><li><p><font color="red">HTTP</font>：从Web服务器传输超文本到本地浏览器的传送协议。</p></li></ul><hr><p>2). UDP对应的应用层协议</p><ul><li><p><font color="red">DNS</font>：用于域名解析服务，将域名地址转换为IP地址。DNS用的是53号端口。</p></li><li><p><font color="red">SNMP</font>：简单网络管理协议，使用161号端口，是用来管理网络设备的。由于网络设备很多，无连接的服务就体现出其优势。</p></li><li><p><font color="red">TFTP(Trival File Transfer Protocal)</font>：简单文件传输协议，该协议在熟知端口69上使用UDP服务。</p></li></ul><hr><p>3). 图示</p><p>　　　　　　　　　　<img src="http://static.zybuluo.com/Rico123/r3gm4e6y9hlgqllw8ba10676/TCP%E5%92%8CUDP%E5%88%86%E5%88%AB%E5%AF%B9%E5%BA%94%E7%9A%84%E5%B8%B8%E8%A7%81%E5%BA%94%E7%94%A8%E5%B1%82%E5%8D%8F%E8%AE%AE.png" alt="TCP和UDP分别对应的常见应用层协议.png-41.5kB" title></p><hr><p><strong>16、网络层的ARP协议工作原理</strong></p><p>　　<font color="red"><b>网络层的ARP协议完成了IP地址与物理地址的映射。</b></font>首先，每台主机都会在自己的ARP缓冲区中建立一个ARP列表，以表示IP地址和MAC地址的对应关系。当源主机需要将一个数据包要发送到目的主机时，会首先检查自己ARP列表中是否存在该IP地址对应的MAC地址：如果有，就直接将数据包发送到这个MAC地址；如果没有，就向本地网段发起一个ARP请求的广播包，查询此目的主机对应的MAC地址。此ARP请求数据包里包括源主机的IP地址、硬件地址、以及目的主机的IP地址。网络中所有的主机收到这个ARP请求后，会检查数据包中的目的IP是否和自己的IP地址一致。如果不相同就忽略此数据包；如果相同，该主机首先将发送端的MAC地址和IP地址添加到自己的ARP列表中，如果ARP表中已经存在该IP的信息，则将其覆盖，然后给源主机发送一个ARP响应数据包，告诉对方自己是它需要查找的MAC地址；源主机收到这个ARP响应数据包后，将得到的目的主机的IP地址和MAC地址添加到自己的ARP列表中，并利用此信息开始数据的传输。如果源主机一直没有收到ARP响应数据包，表示ARP查询失败。</p><hr><p><strong>17、IP地址的分类</strong></p><p>　　IP地址是指互联网协议地址，是IP协议提供的一种统一的地址格式，它为互联网上的每一个网络和每一台主机分配一个逻辑地址，以此来屏蔽物理地址的差异。IP地址编址方案将IP地址空间划分为A、B、C、D、E五类，其中A、B、C是基本类，D、E类作为多播和保留使用，为特殊地址。</p><p>　　每个IP地址包括两个标识码（ID），即网络ID和主机ID。同一个物理网络上的所有主机都使用同一个网络ID，网络上的一个主机（包括网络上工作站，服务器和路由器等）有一个主机ID与其对应。A~E类地址的特点如下：</p><ul><li><p>A类地址：以0开头，第一个字节范围：0~127；</p></li><li><p>B类地址：以10开头，第一个字节范围：128~191；</p></li><li><p>C类地址：以110开头，第一个字节范围：192~223；</p></li><li><p>D类地址：以1110开头，第一个字节范围为224~239；</p></li><li><p>E类地址：以1111开头，保留地址</p></li></ul><hr><p>1). A类地址：1字节的网络地址 + 3字节主机地址，网络地址的最高位必须是“0”</p><p>　　一个A类IP地址是指， 在IP地址的四段号码中，第一段号码为网络号码，剩下的三段号码为本地计算机的号码。如果用二进制表示IP地址的话，A类IP地址就由1字节的网络地址和3字节主机地址组成，网络地址的最高位必须是“0”。A类IP地址中网络的标识长度为8位，主机标识的长度为24位，A类网络地址数量较少，有126个网络，每个网络可以容纳主机数达1600多万台。</p><p>　　A类IP地址的地址范围1.0.0.0到127.255.255.255（二进制表示为：00000001 00000000 00000000 00000000 - 01111110 11111111 11111111 11111111），最后一个是广播地址。A类IP地址的子网掩码为255.0.0.0，每个网络支持的最大主机数为256的3次方-2=16777214台。</p><hr><p>2). B类地址: 2字节的网络地址 + 2字节主机地址，网络地址的最高位必须是“10”</p><p>　　一个B类IP地址是指，在IP地址的四段号码中，前两段号码为网络号码。如果用二进制表示IP地址的话，B类IP地址就由2字节的网络地址和2字节主机地址组成，网络地址的最高位必须是“10”。B类IP地址中网络的标识长度为16位，主机标识的长度为16位，B类网络地址适用于中等规模的网络，有16384个网络，每个网络所能容纳的计算机数为6万多台。</p><p>　　B类IP地址地址范围128.0.0.0-191.255.255.255（二进制表示为：10000000 00000000 00000000 00000000—-10111111 11111111 11111111 11111111），最后一个是广播地址。B类IP地址的子网掩码为255.255.0.0，每个网络支持的最大主机数为256的2次方-2=65534台。</p><hr><p>3). C类地址: 3字节的网络地址 + 1字节主机地址，网络地址的最高位必须是“110”</p><p>　　一个C类IP地址是指，在IP地址的四段号码中，前三段号码为网络号码，剩下的一段号码为本地计算机的号码。如果用二进制表示IP地址的话，C类IP地址就由3字节的网络地址和1字节主机地址组成，网络地址的最高位必须是“110”。C类IP地址中网络的标识长度为24位，主机标识的长度为8位，C类网络地址数量较多，有209万余个网络。适用于小规模的局域网络，每个网络最多只能包含254台计算机。</p><p>　　C类IP地址范围192.0.0.0-223.255.255.255（二进制表示为: 11000000 00000000 00000000 00000000 - 11011111 11111111 11111111 11111111）。C类IP地址的子网掩码为255.255.255.0，每个网络支持的最大主机数为256-2=254台。</p><hr><p>4). D类地址:多播地址，用于1对多通信，最高位必须是“1110”</p><p>　　D类IP地址在历史上被叫做多播地址(multicast address)，即组播地址。在以太网中，多播地址命名了一组应该在这个网络中应用接收到一个分组的站点。多播地址的最高位必须是“1110”，范围从224.0.0.0到239.255.255.255。</p><hr><p>5). E类地址:为保留地址，最高位必须是“1111”</p><hr><p><strong>18、IP地址与物理地址</strong></p><p>　　物理地址是数据链路层和物理层使用的地址，IP地址是网络层和以上各层使用的地址，是一种逻辑地址，其中ARP协议用于IP地址与物理地址的对应。</p><hr><p><strong>19、 常见状态码及原因短语</strong></p><p>　　HTTP请求结构： 请求方式 + 请求URI + 协议及其版本 <br>　　HTTP响应结构： 状态码 + 原因短语 + 协议及其版本</p><hr><ul><li>1×× : 请求处理中，请求已被接受，正在处理</li></ul><hr><ul><li>2×× : 请求成功，请求被成功处理 <br>    200 OK</li></ul><hr><ul><li>3×× : 重定向，要完成请求必须进行进一步处理 <br>    301 : 永久性转移 <br>    302 ：暂时性转移 <br>    304 ： 已缓存</li></ul><hr><ul><li>4×× : 客户端错误，请求不合法 <br>    400：Bad Request,请求有语法问题 <br>    403：拒绝请求 <br>    404：客户端所访问的页面不存在</li></ul><hr><ul><li>5×× : 服务器端错误，服务器不能处理合法请求 <br>    500 ：服务器内部错误 <br>    503 ： 服务不可用，稍等 <br><br></li></ul><hr><p><strong>20、  http报文头里面含有什么</strong></p>请求头<p>返回头<br>文本域<br>文本编码</p><hr><p><strong>21、  谈谈你所理解的 HTTP 协议？</strong></p><p>http协议是无状态的，简化了服务器的设计，支持大量并发请求。<br>采用TCP作为运输层协议，保证了数据的可靠性。但是http协议本身是无连接的，在通信双方交换http报文之前不需要先建立http连接。<br>HTTP连接最显著的特点是客户端发送的每次请求都需要服务器回送响应，在请求结束后，会主动释放连接。<br>1）在HTTP 1.0中，客户端的每次请求都要求建立一次单独的连接，在处理完本次请求后，就自动释放连接。<br>2）在HTTP 1.1中则可以在一次连接中处理多个请求，并且多个请求可以重叠进行，不需要等待一个请求结束后再发送下一个请求。<br>**访问一个网址的流程：<br>a：域名解析<br>b：tcp3次握手建立连接<br>c：建立连接后，发起http请求<br>d：服务器端响应http请求，浏览器得到http请求的内容<br>e：浏览器解析html代码，并请求html代码中的资源<br>f：浏览器通过页面渲染，展现在用户面前</p><hr><p><strong>22、  对 TCP 的理解？三次握手？滑动窗口？</strong></p><p>TCP：一种面向连接的、可靠的、基于字节流的传输层通信协议，全双工模式<br>三次握手：为了保证服务端能收接受到客户端的信息并能做出正确的应答而进行前两次(第一次和第二次)握手，为了保证客户端能够接收到服务端的信息并能做出正确的应答而进行后两次(第二次和第三次)握手，第三步是防止了乙的一直等待而浪费自己的时间，而不是为了保证甲能够正确回应乙的信息。<br>三次握手的目的：为了防止已失效的连接请求报文段突然又传送到了服务端，而产生错误。<br>四次挥手：当 Client 发出FIN报文段时，只是表示 Client 已经没有数据要发送了，Client 告诉 Server，它的数据已经全部发送完毕了；但是，这个时候 Client 还是可以接受来自 Server 的数据；当 Server 返回ACK报文段时，表示它已经知道 Client 没有数据发送了，但是 Server 还是可以发送数据到 Client 的；当 Server 也发送了FIN报文段时，这个时候就表示 Server 也没有数据要发送了，就会告诉 Client ，我也没有数据要发送了，之后彼此就会愉快的中断这次TCP连接。<br>滑动窗口(以字节为单位)：TCP协议作为一个可靠的面向流的传输协议，其可靠性和流量控制由滑动窗口协议保证。<br>流量控制：发送方的发送窗口不能超过接收方给出的接收窗口的数值。<br>已发送并收到确认的数据（不再发送窗口和发送缓冲区之内）、已发送但未收到确认的数据（位于发送窗口之中）、允许发送但尚未发送的数据以及发送窗口外发送缓冲区内暂时不允许发送的数据；</p><hr><p><strong>23、  TCP/UDP有哪些优缺点？</strong></p>1、TCP面向连接（如打电话要先拨号建立连接）;UDP是无连接的，即发送数据之前不需要建立连接<p>2、TCP提供可靠的服务。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达;UDP尽最大努力交付，即不保证可靠交付<br>3、TCP面向字节流，实际上是TCP把数据看成一连串无结构的字节流;UDP是面向报文的<br>  UDP没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如IP电话，实时视频会议等）<br>4、每一条TCP连接只能是点到点的;UDP支持一对一，一对多，多对一和多对多的交互通信<br>5、TCP首部开销20字节;UDP的首部开销小，只有8个字节<br>6、TCP的逻辑通信信道是全双工的可靠信道，UDP则是不可靠信道</p><hr><p><strong>24、  TCP可靠的四大手段</strong></p><p>顺序编号：tcp在传输文件的时候，会将文件拆分为多个tcp数据包，每个装满的数据包大小大约在1k左右，tcp协议为保证可靠传输，会将这些数据包顺序编号<br>确认机制：当数据包成功的被发送方发送给接收方，接收方会根据tcp协议反馈给发送方一个成功接收的ACK信号，信号中包含了当前包的序号<br>超时重传：当发送方发送数据包给接收方时，会为每一个数据包设置一个定时器，当在设定的时间内，发送方仍没有收到接收方的ACK信号，会再次发送该数据包，直到收到接收方的ACK信号或者连接已断开<br>校验信息：tcp首部校验信息较多，udp首部校验信息较少</p><hr><p><strong>25、 为什么不能用两次握手进行连接？</strong></p><p>答：3次握手完成两个重要的功能，既要双方做好发送数据的准备工作(双方都知道彼此已准备好)，也要允许双方就初始序列号进行协商，这个序列号在握手过程中被发送和确认。 现在把三次握手改成仅需要两次握手，死锁是可能发生的。</p><hr><p><strong>26、 为什么连接的时候是三次握手，关闭的时候却是四次握手？</strong></p><p>答：建立连接的时候， 服务器在LISTEN状态下，收到建立连接请求的SYN报文后，把ACK和SYN放在一个报文里发送给客户端。<br>而关闭连接时，服务器收到对方的FIN报文时，仅仅表示对方不再发送数据了但是还能接收数据，而自己也未必全部数据都发送给对方了，所以己方可以立即关闭，也可以发送一些数据给对方后，再发送FIN报文给对方来表示同意现在关闭连接，因此，己方ACK和FIN一般都会分开发送，从而导致多了一次。</p><hr><p><strong>27、 如果已经建立了连接，但是客户端突然出现故障了怎么办？</strong></p>TCP还设有一个保活计时器，显然，客户端如果出现故障，服务器不能一直等下去，白白浪费资源。服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75秒钟发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。<p>MSL(最大报文段生存时间)</p><hr><blockquote>  <h2 id="引用">引用</h2>  <p><a href="https://blog.csdn.net/justloveyou_/article/details/78303617#commentBox?tdsourcetag=s_pcqq_aiomsg" rel="nofollow" target="_blank">面试/笔试 计算机网络</a> <br>  </p><p><a href="http://www.cnblogs.com/hyddd/archive/2009/03/31/1426026.html" rel="nofollow" target="_blank" data-token="9996eaa6b77b7a6472b68689a136eeed">浅谈HTTP中Get与Post的区别</a> <br>  <a href="http://blog.csdn.net/sicofield/article/details/9708383" rel="nofollow" target="_blank" data-token="761b7ffe8737eec4250717ca771bffbd">TCP的拥塞控制</a> <br>  <a href="http://www.cnblogs.com/xuxm2007/archive/2011/12/05/2276705.html/6557596.htmlB%E4%B8%8E%E6%8B%A5%E5%A1%9E%E9%81%BF%E5%85%8D.jpg" rel="nofollow" target="_blank" data-token="a2d350739ce1f40e36504b96b55ce597">Session简介</a> <br>  <a href="http://www.cnblogs.com/xdp-gacl/p/3803033.html.jpg" rel="nofollow" target="_blank" data-token="030f0e78a7945fa3d4a25845fda4b91a">javaweb学习总结(十一)——使用Cookie进行会话管理</a> <br>  <a href="http://www.cnblogs.com/phpstudy2015-6/p/6767032.html#_label1" rel="nofollow" target="_blank" data-token="29b8ea946d4cde54269133dff6f04cf1">XSS跨站脚本攻击</a></p></blockquote>                                    ]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://picsum.photos/800/202&quot; alt&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;摘要：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;本文对面试/笔试过程中经常会被问到的一些关于计算机网络的问题进行了梳理和总结。关于这块内容的初步了解和掌握，建议大家读一读《图解HTTP》一书。&lt;/p&gt;
&lt;hr&gt;
    
    </summary>
    
    
    
      <category term="计算机网络" scheme="ayjcsgm.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>SQL语句测试题带答案</title>
    <link href="ayjcsgm.github.io/2019/10/01/SQL%E8%AF%AD%E5%8F%A5%E6%B5%8B%E8%AF%95%E9%A2%98%E5%B8%A6%E7%AD%94%E6%A1%88/"/>
    <id>ayjcsgm.github.io/2019/10/01/SQL语句测试题带答案/</id>
    <published>2019-10-01T07:15:44.000Z</published>
    <updated>2019-10-01T08:15:36.579Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://picsum.photos/800/201" alt><br>Student(SId,Sname,Sage,Ssex) 学生表       SId：学号；Sname：学生姓名；Sage：学生年龄；Ssex：学生性别<br>Course(CId,Cname,TId) 课程表                    CId,课程编号；Cname：课程名字；TId：教师编号<br>SC(SId,CId,score) 成绩表                             SId：学号；CId,课程编号；score：成绩<br>Teacher(TId,Tname) 教师表                        TId：教师编号； Tname：教师名字</p><a id="more"></a> <p>问题：<br>1、查询“001”课程比“002”课程成绩高的所有学生的学号；<br>  select a.SId from (select sId,score from SC where CId=’001’) a,(select sId,score<br>  from SC where CId=’002’) b<br>  where a.score&gt;b.score and a.sId=b.sId;<br>2、查询平均成绩大于60分的同学的学号和平均成绩；<br>    select SId,avg(score)<br>    from sc<br>    group by SId having avg(score) &gt;60;<br>3、查询所有同学的学号、姓名、选课数、总成绩；<br>  select Student.SId,Student.Sname,count(SC.CId),sum(score)<br>  from Student left Outer join SC on Student.SId=SC.SId<br>  group by Student.SId,Sname<br>4、查询姓“李”的老师的个数；<br>  select count(distinct(Tname))<br>  from Teacher<br>  where Tname like ‘李%’;<br>5、查询没学过“叶平”老师课的同学的学号、姓名；<br>    select Student.SId,Student.Sname<br>    from Student<br>    where SId not in (select distinct( SC.SId) from SC,Course,Teacher where  SC.CId=Course.CId and Teacher.TId=Course.TId and Teacher.Tname=’叶平’);<br>6、查询学过“001”并且也学过编号“002”课程的同学的学号、姓名；<br>  select Student.SId,Student.Sname from Student,SC where Student.SId=SC.SId and SC.CId=’001’and exists( Select * from SC as SC_2 where SC_2.SId=SC.SId and SC_2.CId=’002’);<br>7、查询学过“叶平”老师所教的所有课的同学的学号、姓名；<br>  select SId,Sname<br>  from Student<br>  where SId in (select SId from SC ,Course ,Teacher where SC.CId=Course.CId and Teacher.TId=Course.TId and Teacher.Tname=’叶平’ group by SId having count(SC.CId)=(select count(CId) from Course,Teacher  where Teacher.TId=Course.TId and Tname=’叶平’));<br>8、查询课程编号“002”的成绩比课程编号“001”课程低的所有同学的学号、姓名；<br>  Select SId,Sname from (select Student.SId,Student.Sname,score ,(select score from SC SC_2 where SC_2.SId=Student.SId and SC_2.CId=’002’) score2<br>  from Student,SC where Student.SId=SC.SId and CId=’001’) S_2 where score2 &lt;score;<br>9、查询所有课程成绩小于60分的同学的学号、姓名；<br>  select SId,Sname<br>  from Student<br>  where SId not in (select Student.SId from Student,SC where S.SId=SC.SId and score&gt;60);<br>10、查询没有学全所有课的同学的学号、姓名；<br>    select Student.SId,Student.Sname<br>    from Student,SC<br>    where Student.SId=SC.SId group by  Student.SId,Student.Sname having count(CId) &lt;(select count(CId) from Course);</p><p>11、查询至少有一门课与学号为“1001”的同学所学相同的同学的学号和姓名；<br>    select SId,Sname from Student,SC where Student.SId=SC.SId and CId in select CId from SC where SId=’1001’;<br>12、查询至少学过学号为“001”同学所有一门课的其他同学学号和姓名；<br>    select distinct SC.SId,Sname<br>    from Student,SC<br>    where Student.SId=SC.SId and CId in (select CId from SC where SId=’001’);<br>13、把“SC”表中“叶平”老师教的课的成绩都更改为此课程的平均成绩；<br>    update SC set score=(select avg(SC_2.score)<br>    from SC SC_2<br>    where SC_2.CId=SC.CId ) from Course,Teacher where Course.CId=SC.CId and Course.TId=Teacher.TId and Teacher.Tname=’叶平’);<br>14、查询和“1002”号的同学学习的课程完全相同的其他同学学号和姓名；<br>    select SId from SC where CId in (select CId from SC where SId=’1002’)<br>    group by SId having count(<em>)=(select count(</em>) from SC where SId=’1002’);<br>15、删除学习“叶平”老师课的SC表记录；<br>    Delect SC<br>    from course ,Teacher<br>    where Course.CId=SC.CId and Course.TId= Teacher.TId and Tname=’叶平’;<br>16、向SC表中插入一些记录，这些记录要求符合以下条件：没有上过编号“003”课程的同学学号、2、<br>    号课的平均成绩；<br>    Insert SC select SId,’002’,(Select avg(score)<br>from SC where CId=’002’) from Student where SId not in (Select SId from SC where CId=’002’);<br> 17、按平均成绩从高到低显示所有学生的“数据库”、“企业管理”、“英语”三门的课程成绩，按如下形式显示： 学生ID,,数据库,企业管理,英语,有效课程数,有效平均分<br>    SELECT SId as 学生ID<br>        ,(SELECT score FROM SC WHERE SC.SId=t.SId AND CId=’004’) AS 数据库<br>        ,(SELECT score FROM SC WHERE SC.SId=t.SId AND CId=’001’) AS 企业管理<br>        ,(SELECT score FROM SC WHERE SC.SId=t.SId AND CId=’006’) AS 英语<br>        ,COUNT(<em>) AS 有效课程数, AVG(t.score) AS 平均成绩<br>    FROM SC AS t<br>    GROUP BY SId<br>    ORDER BY avg(t.score)<br>18、查询各科成绩最高和最低的分：以如下形式显示：课程ID，最高分，最低分<br>    SELECT L.CId As 课程ID,L.score AS 最高分,R.score AS 最低分<br>    FROM SC L ,SC AS R<br>    WHERE L.CId = R.CId and<br>        L.score = (SELECT MAX(IL.score)<br>                      FROM SC AS IL,Student AS IM<br>                      WHERE L.CId = IL.CId and IM.SId=IL.SId<br>                      GROUP BY IL.CId)<br>        AND<br>        R.Score = (SELECT MIN(IR.score)<br>                      FROM SC AS IR<br>                      WHERE R.CId = IR.CId<br>                  GROUP BY IR.CId<br>                    );<br>19、按各科平均成绩从低到高和及格率的百分数从高到低顺序<br>    SELECT t.CId AS 课程号,max(course.Cname)AS 课程名,isnull(AVG(score),0) AS 平均成绩<br>        ,100 * SUM(CASE WHEN  isnull(score,0)&gt;=60 THEN 1 ELSE 0 END)/COUNT(</em>) AS 及格百分数<br>    FROM SC T,Course<br>    where t.CId=course.CId<br>    GROUP BY t.CId<br>    ORDER BY 100 * SUM(CASE WHEN  isnull(score,0)&gt;=60 THEN 1 ELSE 0 END)/COUNT(*) DESC<br>20、查询如下课程平均成绩和及格率的百分数(用”1行”显示): 企业管理（001），马克思（002），OO&amp;UML （003），数据库（004）<br>    SELECT SUM(CASE WHEN CId =’001’ THEN score ELSE 0 END)/SUM(CASE CId WHEN ‘001’ THEN 1 ELSE 0 END) AS 企业管理平均分<br>        ,100 * SUM(CASE WHEN CId = ‘001’ AND score &gt;= 60 THEN 1 ELSE 0 END)/SUM(CASE WHEN CId = ‘001’ THEN 1 ELSE 0 END) AS 企业管理及格百分数<br>,SUM(CASE WHEN CId = ‘002’ THEN score ELSE 0 END)/SUM(CASE CId WHEN ‘002’ THEN 1 ELSE 0 END) AS 马克思平均分<br>        ,100 * SUM(CASE WHEN CId = ‘002’ AND score &gt;= 60 THEN 1 ELSE 0 END)/SUM(CASE WHEN CId = ‘002’ THEN 1 ELSE 0 END) AS 马克思及格百分数<br>        ,SUM(CASE WHEN CId = ‘003’ THEN score ELSE 0 END)/SUM(CASE CId WHEN ‘003’ THEN 1 ELSE 0 END) AS UML平均分<br>        ,100 * SUM(CASE WHEN CId = ‘003’ AND score &gt;= 60 THEN 1 ELSE 0 END)/SUM(CASE WHEN CId = ‘003’ THEN 1 ELSE 0 END) AS UML及格百分数<br>        ,SUM(CASE WHEN CId = ‘004’ THEN score ELSE 0 END)/SUM(CASE CId WHEN ‘004’ THEN 1 ELSE 0 END) AS 数据库平均分<br>        ,100 * SUM(CASE WHEN CId = ‘004’ AND score &gt;= 60 THEN 1 ELSE 0 END)/SUM(CASE WHEN CId = ‘004’ THEN 1 ELSE 0 END) AS 数据库及格百分数<br>  FROM SC<br>21、查询不同老师所教不同课程平均分从高到低显示<br>  SELECT max(Z.TId) AS 教师ID,MAX(Z.Tname) AS 教师姓名,C.CId AS 课程ＩＤ,MAX(C.Cname) AS 课程名称,AVG(Score) AS 平均成绩<br>    FROM SC AS T,Course AS C ,Teacher AS Z<br>    where T.CId=C.CId and C.TId=Z.TId<br>  GROUP BY C.CId<br>  ORDER BY AVG(Score) DESC<br>22、查询如下课程成绩第 3 名到第 6 名的学生成绩单：企业管理（001），马克思（002），UML （003），数据库（004）<br>    [学生ID],[学生姓名],企业管理,马克思,UML,数据库,平均成绩<br>    SELECT  DISTINCT top 3<br>      SC.SId As 学生学号,<br>        Student.Sname AS 学生姓名 ,<br>      T1.score AS 企业管理,<br>      T2.score AS 马克思,<br>      T3.score AS UML,<br>      T4.score AS 数据库,<br>      ISNULL(T1.score,0) + ISNULL(T2.score,0) + ISNULL(T3.score,0) + ISNULL(T4.score,0) as 总分<br>      FROM Student,SC  LEFT JOIN SC AS T1<br>                      ON SC.SId = T1.SId AND T1.CId = ‘001’<br>            LEFT JOIN SC AS T2<br>                      ON SC.SId = T2.SId AND T2.CId = ‘002’<br>            LEFT JOIN SC AS T3<br>ON SC.SId = T3.SId AND T3.CId = ‘003’<br>            LEFT JOIN SC AS T4<br>                      ON SC.SId = T4.SId AND T4.CId = ‘004’<br>      WHERE student.SId=SC.SId and<br>      ISNULL(T1.score,0) + ISNULL(T2.score,0) + ISNULL(T3.score,0) + ISNULL(T4.score,0)<br>      NOT IN<br>      (SELECT<br>            DISTINCT<br>            TOP 15 WITH TIES<br>            ISNULL(T1.score,0) + ISNULL(T2.score,0) + ISNULL(T3.score,0) + ISNULL(T4.score,0)<br>      FROM sc<br>            LEFT JOIN sc AS T1<br>                      ON sc.SId = T1.SId AND T1.CId = ‘k1’<br>            LEFT JOIN sc AS T2<br>                      ON sc.SId = T2.SId AND T2.CId = ‘k2’<br>            LEFT JOIN sc AS T3<br>                      ON sc.SId = T3.SId AND T3.CId = ‘k3’<br>            LEFT JOIN sc AS T4<br>                      ON sc.SId = T4.SId AND T4.CId = ‘k4’<br>      ORDER BY ISNULL(T1.score,0) + ISNULL(T2.score,0) + ISNULL(T3.score,0) + ISNULL(T4.score,0) DESC); </p><p>23、统计列印各科成绩,各分数段人数:课程ID,课程名称,[100-85],[85-70],[70-60],[ &lt;60]<br>    SELECT SC.CId as 课程ID, Cname as 课程名称<br>        ,SUM(CASE WHEN score BETWEEN 85 AND 100 THEN 1 ELSE 0 END) AS [100 - 85]<br>        ,SUM(CASE WHEN score BETWEEN 70 AND 85 THEN 1 ELSE 0 END) AS [85 - 70]<br>        ,SUM(CASE WHEN score BETWEEN 60 AND 70 THEN 1 ELSE 0 END) AS [70 - 60]<br>        ,SUM(CASE WHEN score &lt; 60 THEN 1 ELSE 0 END) AS [60 -]<br>    FROM SC,Course<br>    where SC.CId=Course.CId<br>    GROUP BY SC.CId,Cname; </p><p>24、查询学生平均成绩及其名次<br>      SELECT 1+(SELECT COUNT( distinct 平均成绩)<br>              FROM (SELECT SId,AVG(score) AS 平均成绩<br>                      FROM SC<br>                  GROUP BY SId<br>) AS T1<br>            WHERE 平均成绩 &gt; T2.平均成绩) as 名次,<br>      SId as 学生学号,平均成绩<br>    FROM (SELECT SId,AVG(score) 平均成绩<br>            FROM SC<br>        GROUP BY SId<br>        ) AS T2<br>    ORDER BY 平均成绩 desc; </p><p>25、查询各科成绩前三名的记录:(不考虑成绩并列情况)<br>      SELECT t1.SId as 学生ID,t1.CId as 课程ID,Score as 分数<br>      FROM SC t1<br>      WHERE score IN (SELECT TOP 3 score<br>              FROM SC<br>              WHERE t1.CId= CId<br>            ORDER BY score DESC<br>              )<br>      ORDER BY t1.CId;<br>26、查询每门课程被选修的学生数<br>  select cId,count(SId) from sc group by CId;<br>27、查询出只选修了一门课程的全部学生的学号和姓名<br>  select SC.SId,Student.Sname,count(CId) AS 选课数<br>  from SC ,Student<br>  where SC.SId=Student.SId group by SC.SId ,Student.Sname having count(CId)=1;<br>28、查询男生、女生人数<br>    Select count(Ssex) as 男生人数 from Student group by Ssex having Ssex=’男’;<br>    Select count(Ssex) as 女生人数 from Student group by Ssex having Ssex=’女’；<br>29、查询姓“张”的学生名单<br>    SELECT Sname FROM Student WHERE Sname like ‘张%’;<br>30、查询同名同性学生名单，并统计同名人数<br>  select Sname,count(<em>) from Student group by Sname having  count(</em>)&gt;1;;<br>31、1981年出生的学生名单(注：Student表中Sage列的类型是datetime)<br>    select Sname,  CONVERT(char (11),DATEPART(year,Sage)) as age<br>    from student<br>    where  CONVERT(char(11),DATEPART(year,Sage))=’1981’;<br>32、查询每门课程的平均成绩，结果按平均成绩升序排列，平均成绩相同时，按课程号降序排列<br>Select CId,Avg(score) from SC group by CId order by Avg(score),CId DESC ;<br>33、查询平均成绩大于85的所有学生的学号、姓名和平均成绩<br>    select Sname,SC.SId ,avg(score)<br>    from Student,SC<br>    where Student.SId=SC.SId group by SC.SId,Sname having    avg(score)&gt;85;<br>34、查询课程名称为“数据库”，且分数低于60的学生姓名和分数<br>    Select Sname,isnull(score,0)<br>    from Student,SC,Course<br>    where SC.SId=Student.SId and SC.CId=Course.CId and  Course.Cname=’数据库’and score &lt;60;<br>35、查询所有学生的选课情况；<br>    SELECT SC.SId,SC.CId,Sname,Cname<br>    FROM SC,Student,Course<br>    where SC.SId=Student.SId and SC.CId=Course.CId ;<br>36、查询任何一门课程成绩在70分以上的姓名、课程名称和分数；<br>    SELECT  distinct student.SId,student.Sname,SC.CId,SC.score<br>    FROM student,Sc<br>    WHERE SC.score&gt;=70 AND SC.SId=student.SId;<br>37、查询不及格的课程，并按课程号从大到小排列<br>    select cId from sc where scor e &lt;60 order by CId ;<br>38、查询课程编号为003且课程成绩在80分以上的学生的学号和姓名；<br>    select SC.SId,Student.Sname from SC,Student where SC.SId=Student.SId and Score&gt;80 and CId=’003’;<br>39、求选了课程的学生人数<br>    select count(<em>) from sc;<br>40、查询选修“叶平”老师所授课程的学生中，成绩最高的学生姓名及其成绩<br>    select Student.Sname,score<br>    from Student,SC,Course C,Teacher<br>    where Student.SId=SC.SId and SC.CId=C.CId and C.TId=Teacher.TId and Teacher.Tname=’叶平’ and SC.score=(select max(score)from SC where CId=C.CId );<br>41、查询各个课程及相应的选修人数<br>    select count(</em>) from sc group by CId;<br>42、查询不同课程成绩相同的学生的学号、课程号、学生成绩<br>  select distinct  A.SId,B.score from SC A  ,SC B where A.Score=B.Score and A.CId &lt;&gt;B.CId ;<br>43、查询每门功成绩最好的前两名<br>    SELECT t1.SId as 学生ID,t1.CId as 课程ID,Score as 分数<br>      FROM SC t1<br>      WHERE score IN (SELECT TOP 2 score<br>              FROM SC<br>              WHERE t1.CId= CId<br>  ORDER BY score DESC<br>              )<br>      ORDER BY t1.CId;<br>44、统计每门课程的学生选修人数（超过10人的课程才统计）。要求输出课程号和选修人数，查询结果按人数降序排列，查询结果按人数降序排列，若人数相同，按课程号升序排列<br>    select  CId as 课程号,count(<em>) as 人数<br>    from  sc<br>    group  by  CId<br>    order  by  count(</em>) desc,cId<br>45、检索至少选修两门课程的学生学号<br>    select  SId<br>    from  sc<br>    group  by  sId<br>    having  count(<em>)  &gt;  =  2<br>46、查询全部学生都选修的课程的课程号和课程名<br>    select  CId,Cname<br>    from  Course<br>    where  CId  in  (select  cId  from  sc group  by  cId)<br>47、查询没学过“叶平”老师讲授的任一门课程的学生姓名<br>    select Sname from Student where SId not in (select SId from Course,Teacher,SC where Course.TId=Teacher.TId and SC.CId=course.CId and Tname=’叶平’);<br>48、查询两门以上不及格课程的同学的学号及其平均成绩<br>    select SId,avg(isnull(score,0)) from SC where SId in (select SId from SC where score &lt;60 group by SId having count(</em>)&gt;2)group by SId;<br>49、检索“004”课程分数小于60，按分数降序排列的同学学号<br>    select SId from SC where CId=’004’and score &lt;60 order by score desc;<br>50、删除“002”同学的“001”课程的成绩<br>delete from Sc where SId=’002’and CId=’001’;</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://picsum.photos/800/201&quot; alt&gt;&lt;br&gt;Student(SId,Sname,Sage,Ssex) 学生表       SId：学号；Sname：学生姓名；Sage：学生年龄；Ssex：学生性别&lt;br&gt;Course(CId,Cname,TId) 课程表                    CId,课程编号；Cname：课程名字；TId：教师编号&lt;br&gt;SC(SId,CId,score) 成绩表                             SId：学号；CId,课程编号；score：成绩&lt;br&gt;Teacher(TId,Tname) 教师表                        TId：教师编号； Tname：教师名字&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="SQL" scheme="ayjcsgm.github.io/tags/SQL/"/>
    
  </entry>
  
  <entry>
    <title>Spring Boot个人博客</title>
    <link href="ayjcsgm.github.io/2019/09/23/my-fisrt-post/"/>
    <id>ayjcsgm.github.io/2019/09/23/my-fisrt-post/</id>
    <published>2019-09-23T06:20:34.960Z</published>
    <updated>2019-10-01T16:06:24.155Z</updated>
    
    <content type="html"><![CDATA[<p>作者：黄秋平<br>GitHub：<a href="https://github.com/AYJCSGM/spring-boot-blog" target="_blank" rel="noopener">https://github.com/AYJCSGM/spring-boot-blog</a></p><p><strong>个人博客功能：</strong></p><p><img src="https://camo.githubusercontent.com/5e0fe789d933a0ed40d5c468a1909f56d1f9fc68/68747470733a2f2f7773322e73696e61696d672e636e2f6c617267652f303036744b665463677931666b376d323768626e346a33316473307963646e702e6a7067" alt></p><a id="more"></a> <p><strong>技术组合：</strong></p><ul><li>后端：Spring Boot + JPA + thymeleaf模板</li><li>数据库：MySQL</li><li>前端UI：Semantic UI框架</li></ul><p><strong>工具与环境：</strong></p><ul><li>IDEA</li><li>Maven 3</li><li>JDK 8</li><li>Axure RP 8</li></ul><p><strong>课程内容模块：</strong></p><ul><li>需求分析与功能规划</li><li>页面设计与开发</li><li>技术框架搭建</li><li>后端管理功能实现</li><li>前端管理功能实现</li></ul><p><strong>你能学得什么？</strong></p><ul><li>基于Spring Boot的完整全栈式的开发套路</li><li>Semantic UI框架的使用</li><li>一套博客系统的源代码与设计</li></ul><h2 id="1、需求与功能"><a href="#1、需求与功能" class="headerlink" title="1、需求与功能"></a>1、需求与功能</h2><h3 id="1-1-用户故事"><a href="#1-1-用户故事" class="headerlink" title="1.1 用户故事"></a>1.1 用户故事</h3><p>用户故事是敏捷框架中的一种开发方法。可以帮助开发者转换视角，以用户的角度更好的把握需求，从而实现具有商业价值的功能。</p><blockquote><p> 用户故事最好是用户团队编写</p></blockquote><p><strong>用户故事模板</strong>：</p><ul><li>As a (role of user), I want (some feature) so that (some business value).</li><li>作为一个(某个角色) 使用者，我可以做(某个功能) 事情，如此可以有(某个商业价值) 的好处</li></ul><p><strong>关键点</strong>：角色、功能、商业价值</p><p><strong>举例</strong>：</p><ul><li>作为一个招聘网站<strong>注册用户</strong>，我想<strong>查看最近3天发布的招聘信息</strong>，以便于<strong>了解最新的招聘信息</strong>。</li><li>作为公司，可以张贴新工作。</li></ul><p>个人博客系统的用户故事：</p><p>角色：<strong>普通访客</strong>，<strong>管理员（我）</strong></p><ul><li>访客，可以分页查看所有的博客</li><li>访客，可以快速查看博客数最多的6个分类</li><li>访客，可以查看所有的分类</li><li>访客，可以查看某个分类下的博客列表</li><li>访客，可以快速查看标记博客最多的10个标签</li><li>访客，可以查看所有的标签</li><li>访客，可以查看某个标签下的博客列表</li><li>访客，可以根据年度时间线查看博客列表</li><li>访客，可以快速查看最新的推荐博客</li><li>访客，可以用关键字全局搜索博客</li><li>访客，可以查看单个博客内容</li><li>访客，可以对博客内容进行评论</li><li>访客，可以赞赏博客内容</li><li>访客，可以微信扫码阅读博客内容</li><li>访客，可以在首页扫描公众号二维码关注我</li><li>我，可以用户名和密码登录后台管理</li><li>我，可以管理博客<ul><li>我，可以发布新博客</li><li>我，可以对博客进行分类</li><li>我，可以对博客打标签</li><li>我，可以修改博客</li><li>我，可以删除博客</li><li>我，可以根据标题，分类，标签查询博客</li></ul></li><li>我，可以管理博客分类<ul><li>我，可以新增一个分类</li><li>我，可以修改一个分类</li><li>我，可以删除一个分类</li><li>我，可以根据分类名称查询分类</li></ul></li><li>我，可以管理标签<ul><li>我，可以新增一个标签</li><li>我，可以修改一个标签</li><li>我，可以删除一个标签</li><li>我，可以根据名称查询标签</li></ul></li></ul><h3 id="1-2-功能规划"><a href="#1-2-功能规划" class="headerlink" title="1.2 功能规划"></a>1.2 功能规划</h3><p><img src="https://ws2.sinaimg.cn/large/006tKfTcgy1fk7m27hbn4j31ds0ycdnp.jpg" alt></p><h2 id="2、页面设计与开发"><a href="#2、页面设计与开发" class="headerlink" title="2、页面设计与开发"></a>2、页面设计与开发</h2><h3 id="2-1-设计"><a href="#2-1-设计" class="headerlink" title="2.1 设计"></a>2.1 设计</h3><p><strong>页面规划：</strong></p><p>前端展示：首页、详情页、分类、标签、归档、关于我</p><p>后台管理：模板页</p><h3 id="2-2-页面开发"><a href="#2-2-页面开发" class="headerlink" title="2.2 页面开发"></a>2.2 页面开发</h3><p><a href="https://semantic-ui.com/" target="_blank" rel="noopener">Semantic UI官网</a></p><p><a href="http://www.semantic-ui.cn/" target="_blank" rel="noopener">Semantic UI中文官网</a></p><p><a href="https://imcoding.me/blogs/5" target="_blank" rel="noopener">WebStorm下载与破解</a></p><p><a href="https://www.toptal.com/designers/subtlepatterns/" target="_blank" rel="noopener">背景图片资源</a></p><h3 id="2-3-插件集成"><a href="#2-3-插件集成" class="headerlink" title="2.3 插件集成"></a>2.3 插件集成</h3><p><a href="https://pandao.github.io/editor.md/" target="_blank" rel="noopener">编辑器 Markdown</a></p><p><a href="https://github.com/sofish/typo.css" target="_blank" rel="noopener">内容排版 typo.css</a></p><p><a href="https://daneden.github.io/animate.css/" target="_blank" rel="noopener">动画 animate.css</a></p><p><a href="https://github.com/PrismJS/prism" target="_blank" rel="noopener">代码高亮 prism</a></p><p><a href="https://tscanlin.github.io/tocbot/" target="_blank" rel="noopener">目录生成 Tocbot</a></p><p><a href="http://imakewebthings.com/waypoints/" target="_blank" rel="noopener">滚动侦测 waypoints</a></p><p><a href="https://github.com/flesler/jquery.scrollTo" target="_blank" rel="noopener">平滑滚动 jquery.scrollTo</a></p><p><a href="https://davidshimjs.github.io/qrcodejs/" target="_blank" rel="noopener">二维码生成 qrcode.js</a></p><h2 id="3、框架搭建"><a href="#3、框架搭建" class="headerlink" title="3、框架搭建"></a>3、框架搭建</h2><blockquote><p> <a href="https://www.jetbrains.com/idea/" target="_blank" rel="noopener">IDEA下载 https://www.jetbrains.com/idea/</a></p></blockquote><h3 id="3-1-构建与配置"><a href="#3-1-构建与配置" class="headerlink" title="3.1 构建与配置"></a>3.1 构建与配置</h3><p><strong>1、引入Spring Boot模块：</strong></p><ul><li>web</li><li>Thymeleaf</li><li>JPA</li><li>MySQL</li><li>Aspects</li><li>DevTools</li></ul><p><strong>2、application.yml配置</strong></p><ul><li><p>使用 thymeleaf 3</p><p>pom.xml:</p></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">thymeleaf.version</span>&gt;</span>3.0.2.RELEASE<span class="tag">&lt;/<span class="name">thymeleaf.version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">thymeleaf-layout-dialect.version</span>&gt;</span>2.1.1<span class="tag">&lt;/<span class="name">thymeleaf-layout-dialect.version</span>&gt;</span></span><br></pre></td></tr></table></figure><pre><code>application.yml:</code></pre><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  thymeleaf:</span></span><br><span class="line"><span class="attr">    mode:</span> <span class="string">HTML</span></span><br></pre></td></tr></table></figure><ul><li>数据库连接配置</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  datasource:</span></span><br><span class="line"><span class="attr">    driver-class-name:</span> <span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line"><span class="attr">    url:</span> <span class="attr">jdbc:mysql://localhost:3306/blog?useUnicode=true&amp;characterEncoding=utf-8</span></span><br><span class="line"><span class="attr">    username:</span> <span class="string">root</span></span><br><span class="line"><span class="attr">    password:</span> <span class="string">root</span></span><br><span class="line"><span class="attr">  jpa:</span></span><br><span class="line"><span class="attr">    hibernate:</span></span><br><span class="line"><span class="attr">      ddl-auto:</span> <span class="string">update</span></span><br><span class="line"><span class="attr">    show-sql:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><ul><li><p>日志配置</p><p>application.yml:</p></li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">logging:</span></span><br><span class="line"><span class="attr">  level:</span></span><br><span class="line"><span class="attr">    root:</span> <span class="string">info</span></span><br><span class="line">    <span class="string">com.imcoding:</span> <span class="string">debug</span></span><br><span class="line"><span class="attr">  file:</span> <span class="string">log/imcoding.log</span></span><br></pre></td></tr></table></figure><p>​    logback-spring.xml：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--包含Spring boot对logback日志的默认配置--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">include</span> <span class="attr">resource</span>=<span class="string">"org/springframework/boot/logging/logback/defaults.xml"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"LOG_FILE"</span> <span class="attr">value</span>=<span class="string">"$&#123;LOG_FILE:-$&#123;LOG_PATH:-$&#123;LOG_TEMP:-$&#123;java.io.tmpdir:-/tmp&#125;&#125;&#125;/spring.log&#125;"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">include</span> <span class="attr">resource</span>=<span class="string">"org/springframework/boot/logging/logback/console-appender.xml"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--重写了Spring Boot框架 org/springframework/boot/logging/logback/file-appender.xml 配置--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">"TIME_FILE"</span></span></span><br><span class="line"><span class="tag">              <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.rolling.RollingFileAppender"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">encoder</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>$&#123;FILE_LOG_PATTERN&#125;<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">file</span>&gt;</span>$&#123;LOG_FILE&#125;<span class="tag">&lt;/<span class="name">file</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">rollingPolicy</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.rolling.TimeBasedRollingPolicy"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">fileNamePattern</span>&gt;</span>$&#123;LOG_FILE&#125;.%d&#123;yyyy-MM-dd&#125;.%i<span class="tag">&lt;/<span class="name">fileNamePattern</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--保留历史日志一个月的时间--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">maxHistory</span>&gt;</span>30<span class="tag">&lt;/<span class="name">maxHistory</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">            Spring Boot默认情况下，日志文件10M时，会切分日志文件,这样设置日志文件会在100M时切分日志</span></span><br><span class="line"><span class="comment">            --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">timeBasedFileNamingAndTriggeringPolicy</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP"</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">maxFileSize</span>&gt;</span>10MB<span class="tag">&lt;/<span class="name">maxFileSize</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">timeBasedFileNamingAndTriggeringPolicy</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;/<span class="name">rollingPolicy</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">root</span> <span class="attr">level</span>=<span class="string">"INFO"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">"CONSOLE"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">"TIME_FILE"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">    1、继承Spring boot logback设置（可以在appliaction.yml或者application.properties设置logging.*属性）</span></span><br><span class="line"><span class="comment">    2、重写了默认配置，设置日志文件大小在100MB时，按日期切分日志，切分后目录：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        my.2017-08-01.0   80MB</span></span><br><span class="line"><span class="comment">        my.2017-08-01.1   10MB</span></span><br><span class="line"><span class="comment">        my.2017-08-02.0   56MB</span></span><br><span class="line"><span class="comment">        my.2017-08-03.0   53MB</span></span><br><span class="line"><span class="comment">        ......</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br></pre></td></tr></table></figure><ul><li>生产环境与开发环境配置<ul><li>application-dev.yml</li><li>application-pro.yml</li></ul></li></ul><h3 id="3-2-异常处理"><a href="#3-2-异常处理" class="headerlink" title="3.2 异常处理"></a>3.2 异常处理</h3><p><strong>1、定义错误页面</strong></p><ul><li>404</li><li>500</li><li>error</li></ul><p><strong>2、全局处理异常</strong></p><p>统一处理异常：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ControllerAdvice</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ControllerExceptionHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(ControllerExceptionHandler.class);</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 异常处理</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> request</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> e</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@ExceptionHandler</span>(&#123;Exception.class&#125;)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ModelAndView <span class="title">handleException</span><span class="params">(HttpServletRequest request, Exception e)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        logger.error(<span class="string">"Request URL : &#123;&#125; , Exception : &#123;&#125;"</span>, request.getRequestURL(), e);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (AnnotationUtils.findAnnotation(e.getClass(), ResponseStatus.class) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125;</span><br><span class="line">        ModelAndView mav = <span class="keyword">new</span> ModelAndView();</span><br><span class="line">        mav.addObject(<span class="string">"url"</span>, request.getRequestURL());</span><br><span class="line">        mav.addObject(<span class="string">"exception"</span>, e);</span><br><span class="line">        mav.setViewName(<span class="string">"error/error"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> mav;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>错误页面异常信息显示处理：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">th:utext</span>=<span class="string">"'&amp;lt;!--'"</span> <span class="attr">th:remove</span>=<span class="string">"tag"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">th:utext</span>=<span class="string">"'Failed Request URL : ' + $&#123;url&#125;"</span> <span class="attr">th:remove</span>=<span class="string">"tag"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">th:utext</span>=<span class="string">"'Exception message : ' + $&#123;exception.message&#125;"</span> <span class="attr">th:remove</span>=<span class="string">"tag"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span> <span class="attr">th:remove</span>=<span class="string">"tag"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span> <span class="attr">th:each</span>=<span class="string">"st : $&#123;exception.stackTrace&#125;"</span> <span class="attr">th:remove</span>=<span class="string">"tag"</span>&gt;</span><span class="tag">&lt;<span class="name">span</span> <span class="attr">th:utext</span>=<span class="string">"$&#123;st&#125;"</span> <span class="attr">th:remove</span>=<span class="string">"tag"</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">th:utext</span>=<span class="string">"'--&amp;gt;'"</span> <span class="attr">th:remove</span>=<span class="string">"tag"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>3、资源找不到异常</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ResponseStatus</span>(HttpStatus.NOT_FOUND)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NotFoundExcepiton</span> <span class="keyword">extends</span> <span class="title">RuntimeException</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NotFoundExcepiton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NotFoundExcepiton</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NotFoundExcepiton</span><span class="params">(String message, Throwable cause)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(message, cause);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-3-日志处理"><a href="#3-3-日志处理" class="headerlink" title="3.3 日志处理"></a>3.3 日志处理</h3><p><strong>1、记录日志内容</strong></p><ul><li>请求 url</li><li>访问者 ip</li><li>调用方法 classMethod</li><li>参数 args</li><li>返回内容</li></ul><p><strong>2、记录日志类：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LogAspect</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(<span class="keyword">this</span>.getClass());</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 定义切面</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Pointcut</span>(<span class="string">"execution(* com.imcoding.web.*.*(..))"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">log</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before</span>(<span class="string">"log()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doBefore</span><span class="params">(JoinPoint joinPoint)</span> </span>&#123;</span><br><span class="line">        ServletRequestAttributes attributes = (ServletRequestAttributes) RequestContextHolder.getRequestAttributes();</span><br><span class="line">        HttpServletRequest request = attributes.getRequest();</span><br><span class="line">        String classMethod = joinPoint.getSignature().getDeclaringTypeName() + <span class="string">"."</span> + joinPoint.getSignature().getName();</span><br><span class="line">        ReqeustLog reqeustLog = <span class="keyword">new</span> ReqeustLog(</span><br><span class="line">                request.getRequestURL().toString(),</span><br><span class="line">                request.getRemoteAddr(),</span><br><span class="line">                classMethod,</span><br><span class="line">                joinPoint.getArgs()</span><br><span class="line">        );</span><br><span class="line">        logger.info(<span class="string">"Rquest  ----- &#123;&#125;"</span>,reqeustLog);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@After</span>(<span class="string">"log()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doAfter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//logger.info("---------- doAfter 2 ----------");</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AfterReturning</span>(returning = <span class="string">"result"</span>,pointcut = <span class="string">"log()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doAtfertRturning</span><span class="params">(Object result)</span> </span>&#123;</span><br><span class="line">        logger.info(<span class="string">"Return ------ &#123;&#125;"</span>,result );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">ReqeustLog</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> String url;</span><br><span class="line">        <span class="keyword">private</span> String ip;</span><br><span class="line">        <span class="keyword">private</span> String classMethod;</span><br><span class="line">        <span class="keyword">private</span> Object[] args;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">ReqeustLog</span><span class="params">(String url, String ip, String classMethod, Object[] args)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.url = url;</span><br><span class="line">            <span class="keyword">this</span>.ip = ip;</span><br><span class="line">            <span class="keyword">this</span>.classMethod = classMethod;</span><br><span class="line">            <span class="keyword">this</span>.args = args;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"ReqeustLog&#123;"</span> +</span><br><span class="line">                    <span class="string">"url='"</span> + url + <span class="string">'\''</span> +</span><br><span class="line">                    <span class="string">", ip='"</span> + ip + <span class="string">'\''</span> +</span><br><span class="line">                    <span class="string">", classMethod='"</span> + classMethod + <span class="string">'\''</span> +</span><br><span class="line">                    <span class="string">", args="</span> + Arrays.toString(args) +</span><br><span class="line">                    <span class="string">'&#125;'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-4-页面处理"><a href="#3-4-页面处理" class="headerlink" title="3.4 页面处理"></a>3.4 页面处理</h3><p><strong>1、静态页面导入project</strong></p><p><strong>2、thymeleaf布局</strong></p><ul><li>定义fragment</li><li>使用fragment布局</li></ul><p><strong>3、错误页面美化</strong></p><p>4、设计与规范</p><h3 id="4-1-实体设计"><a href="#4-1-实体设计" class="headerlink" title="4.1 实体设计"></a>4.1 实体设计</h3><p><strong>实体类：</strong></p><ul><li>博客 Blog</li><li>博客分类 Type</li><li>博客标签 Tag</li><li>博客评论 Comment</li><li>用户 User</li></ul><p><strong>实体关系：</strong></p><p><img src="http://on91wk3hn.bkt.clouddn.com/17-10-14/87092095.jpg" alt></p><p><strong>评论类自关联关系：</strong></p><p><img src="http://on91wk3hn.bkt.clouddn.com/17-10-14/41296045.jpg" alt></p><p><strong>Blog类：</strong></p><p><img src="http://on91wk3hn.bkt.clouddn.com/17-10-14/38390041.jpg" alt></p><p><strong>Type类：</strong></p><p><img src="http://on91wk3hn.bkt.clouddn.com/17-10-14/22984471.jpg" alt></p><p><strong>Tag类：</strong></p><p><img src="http://on91wk3hn.bkt.clouddn.com/17-10-14/70860077.jpg" alt></p><p><strong>Comment类：</strong></p><p><img src="http://on91wk3hn.bkt.clouddn.com/17-10-14/77104424.jpg" alt></p><p><strong>User类：</strong></p><p><img src="http://on91wk3hn.bkt.clouddn.com/17-10-14/10367795.jpg" alt></p><h3 id="4-2-应用分层"><a href="#4-2-应用分层" class="headerlink" title="4.2 应用分层"></a>4.2 应用分层</h3><p><img src="http://on91wk3hn.bkt.clouddn.com/17-10-14/64528736.jpg" alt></p><h3 id="4-3-命名约定"><a href="#4-3-命名约定" class="headerlink" title="4.3 命名约定"></a>4.3 命名约定</h3><p><strong>Service/DAO层命名约定：</strong></p><ul><li>获取单个对象的方法用get做前缀。</li><li>获取多个对象的方法用list做前缀。</li><li>获取统计值的方法用count做前缀。</li><li>插入的方法用save(推荐)或insert做前缀。</li><li>删除的方法用remove(推荐)或delete做前缀。</li><li>修改的方法用update做前缀。</li></ul><p><img src="https://ws2.sinaimg.cn/large/006tKfTcgy1fk7m27hbn4j31ds0ycdnp.jpg" alt></p><h2 id="5、后台管理功能实现"><a href="#5、后台管理功能实现" class="headerlink" title="5、后台管理功能实现"></a>5、后台管理功能实现</h2><h3 id="5-1-登录"><a href="#5-1-登录" class="headerlink" title="5.1 登录"></a>5.1 登录</h3><p><strong>1、构建登录页面和后台管理首页</strong></p><p><strong>2、UserService和UserRepository</strong></p><p><strong>3、LoginController实现登录</strong></p><p><strong>4、MD5加密</strong></p><p><strong>5、登录拦截器</strong></p><h3 id="5-2-分类管理"><a href="#5-2-分类管理" class="headerlink" title="5.2 分类管理"></a>5.2 分类管理</h3><p><strong>1、分类管理页面</strong></p><p><strong>2、分类列表分页</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"content"</span>:[</span><br><span class="line">    &#123;<span class="string">"id"</span>:<span class="number">123</span>,<span class="string">"title"</span>:<span class="string">"blog122"</span>,<span class="string">"content"</span>:<span class="string">"this is blog content"</span>&#125;,</span><br><span class="line">    &#123;<span class="string">"id"</span>:<span class="number">122</span>,<span class="string">"title"</span>:<span class="string">"blog121"</span>,<span class="string">"content"</span>:<span class="string">"this is blog content"</span>&#125;,</span><br><span class="line">    &#123;<span class="string">"id"</span>:<span class="number">121</span>,<span class="string">"title"</span>:<span class="string">"blog120"</span>,<span class="string">"content"</span>:<span class="string">"this is blog content"</span>&#125;,</span><br><span class="line">    &#123;<span class="string">"id"</span>:<span class="number">120</span>,<span class="string">"title"</span>:<span class="string">"blog119"</span>,<span class="string">"content"</span>:<span class="string">"this is blog content"</span>&#125;,</span><br><span class="line">    &#123;<span class="string">"id"</span>:<span class="number">119</span>,<span class="string">"title"</span>:<span class="string">"blog118"</span>,<span class="string">"content"</span>:<span class="string">"this is blog content"</span>&#125;,</span><br><span class="line">    &#123;<span class="string">"id"</span>:<span class="number">118</span>,<span class="string">"title"</span>:<span class="string">"blog117"</span>,<span class="string">"content"</span>:<span class="string">"this is blog content"</span>&#125;,</span><br><span class="line">    &#123;<span class="string">"id"</span>:<span class="number">117</span>,<span class="string">"title"</span>:<span class="string">"blog116"</span>,<span class="string">"content"</span>:<span class="string">"this is blog content"</span>&#125;,</span><br><span class="line">    &#123;<span class="string">"id"</span>:<span class="number">116</span>,<span class="string">"title"</span>:<span class="string">"blog115"</span>,<span class="string">"content"</span>:<span class="string">"this is blog content"</span>&#125;,</span><br><span class="line">    &#123;<span class="string">"id"</span>:<span class="number">115</span>,<span class="string">"title"</span>:<span class="string">"blog114"</span>,<span class="string">"content"</span>:<span class="string">"this is blog content"</span>&#125;,</span><br><span class="line">    &#123;<span class="string">"id"</span>:<span class="number">114</span>,<span class="string">"title"</span>:<span class="string">"blog113"</span>,<span class="string">"content"</span>:<span class="string">"this is blog content"</span>&#125;,</span><br><span class="line">    &#123;<span class="string">"id"</span>:<span class="number">113</span>,<span class="string">"title"</span>:<span class="string">"blog112"</span>,<span class="string">"content"</span>:<span class="string">"this is blog content"</span>&#125;,</span><br><span class="line">    &#123;<span class="string">"id"</span>:<span class="number">112</span>,<span class="string">"title"</span>:<span class="string">"blog111"</span>,<span class="string">"content"</span>:<span class="string">"this is blog content"</span>&#125;,</span><br><span class="line">    &#123;<span class="string">"id"</span>:<span class="number">111</span>,<span class="string">"title"</span>:<span class="string">"blog110"</span>,<span class="string">"content"</span>:<span class="string">"this is blog content"</span>&#125;,</span><br><span class="line">    &#123;<span class="string">"id"</span>:<span class="number">110</span>,<span class="string">"title"</span>:<span class="string">"blog109"</span>,<span class="string">"content"</span>:<span class="string">"this is blog content"</span>&#125;,</span><br><span class="line">    &#123;<span class="string">"id"</span>:<span class="number">109</span>,<span class="string">"title"</span>:<span class="string">"blog108"</span>,<span class="string">"content"</span>:<span class="string">"this is blog content"</span>&#125;],</span><br><span class="line">  <span class="string">"last"</span>:<span class="literal">false</span>,</span><br><span class="line">  <span class="string">"totalPages"</span>:<span class="number">9</span>,</span><br><span class="line">  <span class="string">"totalElements"</span>:<span class="number">123</span>,</span><br><span class="line">  <span class="string">"size"</span>:<span class="number">15</span>,</span><br><span class="line">  <span class="string">"number"</span>:<span class="number">0</span>,</span><br><span class="line">  <span class="string">"first"</span>:<span class="literal">true</span>,</span><br><span class="line">  <span class="string">"sort"</span>:[&#123;</span><br><span class="line">    <span class="string">"direction"</span>:<span class="string">"DESC"</span>,</span><br><span class="line">    <span class="string">"property"</span>:<span class="string">"id"</span>,</span><br><span class="line">    <span class="string">"ignoreCase"</span>:<span class="literal">false</span>,</span><br><span class="line">    <span class="string">"nullHandling"</span>:<span class="string">"NATIVE"</span>,</span><br><span class="line">    <span class="string">"ascending"</span>:<span class="literal">false</span></span><br><span class="line">  &#125;],</span><br><span class="line">  <span class="string">"numberOfElements"</span>:<span class="number">15</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>3、分类新增、修改、删除</strong></p><h3 id="5-3-标签管理"><a href="#5-3-标签管理" class="headerlink" title="5.3 标签管理"></a>5.3 标签管理</h3><h3 id="5-4-博客管理"><a href="#5-4-博客管理" class="headerlink" title="5.4 博客管理"></a>5.4 博客管理</h3><p><strong>1、博客分页查询</strong></p><p><strong>2、博客新增</strong></p><p><strong>3、博客修改</strong></p><p><strong>4、博客删除</strong></p><h2 id="6、前端展示功能实现"><a href="#6、前端展示功能实现" class="headerlink" title="6、前端展示功能实现"></a>6、前端展示功能实现</h2><h3 id="6-1-首页展示"><a href="#6-1-首页展示" class="headerlink" title="6.1 首页展示"></a>6.1 首页展示</h3><p><strong>1、博客列表</strong></p><p><strong>2、top分类</strong></p><p><strong>3、top标签</strong></p><p><strong>4、最新博客推荐</strong></p><p><strong>5、博客详情</strong></p><p><strong>1、Markdown 转换 HTML</strong></p><ul><li><a href="https://github.com/atlassian/commonmark-java" target="_blank" rel="noopener">commonmark-java  https://github.com/atlassian/commonmark-java</a></li><li>pom.xml引用commonmark和扩展插件</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.atlassian.commonmark<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commonmark<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.10.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.atlassian.commonmark<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commonmark-ext-heading-anchor<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.10.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.atlassian.commonmark<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commonmark-ext-gfm-tables<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.10.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>2、评论功能</strong></p><ul><li>评论信息提交与回复功能</li><li>评论信息列表展示功能</li><li>管理员回复评论功能</li></ul><h3 id="6-2-分类页"><a href="#6-2-分类页" class="headerlink" title="6.2 分类页"></a>6.2 分类页</h3><h3 id="6-3-标签页"><a href="#6-3-标签页" class="headerlink" title="6.3 标签页"></a>6.3 标签页</h3><h3 id="6-4-归档页"><a href="#6-4-归档页" class="headerlink" title="6.4 归档页"></a>6.4 归档页</h3><h3 id="6-5-关于我"><a href="#6-5-关于我" class="headerlink" title="6.5 关于我"></a>6.5 关于我</h3>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;作者：黄秋平&lt;br&gt;GitHub：&lt;a href=&quot;https://github.com/AYJCSGM/spring-boot-blog&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/AYJCSGM/spring-boot-blog&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;个人博客功能：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://camo.githubusercontent.com/5e0fe789d933a0ed40d5c468a1909f56d1f9fc68/68747470733a2f2f7773322e73696e61696d672e636e2f6c617267652f303036744b665463677931666b376d323768626e346a33316473307963646e702e6a7067&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="Spring Boot" scheme="ayjcsgm.github.io/tags/Spring-Boot/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="ayjcsgm.github.io/2019/09/23/hello-world/"/>
    <id>ayjcsgm.github.io/2019/09/23/hello-world/</id>
    <published>2019-09-23T06:06:49.578Z</published>
    <updated>2019-10-01T16:08:31.895Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://picsum.photos/800/200" alt></p><p></p><p>　　我听说，有一种猫叫做雨猫。天气温暖时，它就变得蓬松毛绒绒的，像白云一样上浮，你可以拴着它，像放风筝一样走，它会变透明，阳光透得过它的身体。天气晦暗时它会变黑，坠在地上，满地乱跑，毛变得硬硬的，像刚刮过的胡茬一样。你得抱着它，等天气晴朗时，再把它放出去，就像风筝末梢放着一团棉花糖。</p><hr><p><a id="more"></a> 　　我听说，有种青蛙，透明洁白，只吃茶叶。吃多之后，吐气如兰。冬天它便僵卧，张着大嘴，眠去一个季节。你往它肚里倒热水，水便成茶，馥郁芳香，可以倒在杯子里喝，香沁肺腑。有个女孩子，手头没有杯子，于是捧起青蛙，嘴对着嘴，把青蛙嘴当茶杯口。结果青蛙醒了，变成一白衣少年：“哪个公主吻了我？”</p><hr><a id="more" target="_blank"></a><p>　　在需要阶段的地方插入该代码语句我听说，有一种驯鹿，很爱长颈鹿的斑纹和气味，但是太矮，又碍于长颈鹿是哑巴，所以没法谈恋爱。于是它们就长起了杉树一样直拔云天的角，然后到处找一个人，在角的顶端造一个房子住着。每天，那个人负责在高树摘果子，送给长颈鹿吃，以促成驯鹿和长颈鹿的爱情——虽然见不到面，但灵魂相通的爱情。</p><hr><p>　　我听说，北方有一种松鼠，特别大，毛茸茸的，睡觉时喜欢摊开四肢，露出软绵绵的肚皮。你抓住一只，混熟了，就可以把它当床，睡在它的肚子上，用它的尾巴做被子。但它喜欢梦游，到处爬，所以你睡着前眼睛明明看见天花板的花纹，醒来时就可能看见松树枝、杉树枝、云、麻雀和松毛虫。</p><hr><p>　　我听说，有一种猫，特别怕冷，一遇到冷环境就全身长起蓬松松软绵绵的长毛，并且开始冬眠，怎么叫都不醒。冬天你把它挂在脖子上出门，就好像穿了件毛大衣。到了温暖的室内，它暖醒了，就喵一声跳下来，自己到炉子旁边去接着睡了。因为冬天很长，它在冬天基本是裘状，所以叫冬裘夏猫。</p><hr><p>　　我听说，有种野猪，睡一觉就长一层脂肪，起来跑一跑就练出一层肌肉，所以他身上肥瘦肥瘦，像夹心饼干。他爱去南方的海边泡澡，泡一身大粒子盐味，吹风，然后哼唧哼唧去温泉，一边蒸自己一边吃树叶子。你埋伏在温泉边，射倒它，能吃到现成的蒸火腿。你最好带蜂蜜，敷一遍再蒸，更好吃。</p><hr><p>　　我听说，以前有人喜欢在海蚌上写故事写诗。你走在海边，海蚌会跟你说：我身上有字，可以给你看噢，但有个条件，我不识字，你得念给我听。你答应了，海蚌就张开壳来，让你给它念故事。如果你看入神忘了继续念，或者企图摘抄剽窃，海蚌就会夹你一下；如果你念得好，海蚌就送你颗珍珠。</p><hr><p>　　我听说，南方有一种鸟，身材纤瘦，尾羽很长，善吟诗，平时看上去盈盈一握，却筋骨健壮。如果你和它混熟了，它就会把身体绷直，你可以握着它的腰，用它的嘴蘸墨、写字，画梅花、打印章时，还可以用它印个浅爪痕。可是它挑剔得很，墨质差，纸脏，字写得难看，或者句子毫无文采，它就会破口大骂：“居然用老娘写这么烂的文章！”</p><hr><p>我听说有种雪狐，极妩媚，皮毛柔滑。善学声音，爱恶作剧，喜在窗外学男主人女同学、女同事等声音，引女主人疑心吵架，引以为乐。被抓住后会要求：给你雪狐裘，放我走吧。若男主人不允，她便媚笑：原来是你舍不得我走啊嗯……女主人遂朝男主人双目圆睁：你留她干嘛，还不放走？心思又活络了嗯？！</p><hr><p>　　我听说，有种熊叫做云熊，其白如雪，其大若垂天之云。春天开始浮游，夏天吸取阳光。冬天，它随风在天空飘荡，到一个寒冷的地方，就开始下一团团的熊绒毛。熊绒可做大衣，闻得到夏天阳光的味道。熊绒落完，它也就飘下地来。你闻以蜂蜜，冬眠。到春天它长起了毛，就又变成云浮起来了。</p><hr><p>　　我听说有种蜗牛，寿命很长，以八千岁为春，以八千岁为秋。丈夫对妻子说，我要吻你一下，然后出门去买报纸。妻子就闭上眼，等了八天，吻到了，于是丈夫出门了。等他回来，妻子抱怨说：你这一走就是六百年，我好担心。丈夫说：哎呀，我是怕又过时了，站在那里花二百年把新闻看了嘛。</p><hr><p>　　我听说有种章鱼，善于下厨。你坐柜台后面，问它要三明治寿司刺身铁板烧咖啡茶涮锅烤串回锅肉，它舞起手臂们，切剔炒烹翻炸调撒料颠勺，又快又好，还能剩出三只手，一只负责收钱，两只和你打扑克解闷。但它开不起玩笑，偶尔它不小心手臂被铁板烫到，你可不能说“那我要这条章鱼烧！” 不然它就会舞起锅铲，任你是三头六臂也挡不住它四面八方朝你扔鱼丸。</p><hr><p>　　我听说有种虎鲸，很温柔，喜欢光，不潜游，但又怕晒。你在它背上铺沙子，张阳伞，它便喜欢你，任你在它背上住下，钓鱼、睡午觉、接吻、喝果汁。每天它张嘴吞许多小鱼，自己吃些，剩下的喷水送给你，于是你天天有新鲜刺身吃。偶然它也馋，愿意吃熟的，就会张嘴，要你抛给吃章鱼烧。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://picsum.photos/800/200&quot; alt&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;&lt;p&gt;　　我听说，有一种猫叫做雨猫。天气温暖时，它就变得蓬松毛绒绒的，像白云一样上浮，你可以拴着它，像放风筝一样走，它会变透明，阳光透得过它的身体。天气晦暗时它会变黑，坠在地上，满地乱跑，毛变得硬硬的，像刚刮过的胡茬一样。你得抱着它，等天气晴朗时，再把它放出去，就像风筝末梢放着一团棉花糖。&lt;/p&gt;&lt;hr&gt;&lt;p&gt;
    
    </summary>
    
    
    
  </entry>
  
</feed>
