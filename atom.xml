<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>HQP的个人博客</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="ayjcsgm.github.io/"/>
  <updated>2019-12-14T11:34:18.825Z</updated>
  <id>ayjcsgm.github.io/</id>
  
  <author>
    <name>Huangqiuping</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>简述TreeSet排序机制</title>
    <link href="ayjcsgm.github.io/2019/12/11/%E7%AE%80%E8%BF%B0TreeSet%E6%8E%92%E5%BA%8F%E6%9C%BA%E5%88%B6/"/>
    <id>ayjcsgm.github.io/2019/12/11/简述TreeSet排序机制/</id>
    <published>2019-12-11T12:29:46.000Z</published>
    <updated>2019-12-14T11:34:18.825Z</updated>
    
    <content type="html"><![CDATA[<h1 id="TreeSet简介"><a href="#TreeSet简介" class="headerlink" title="TreeSet简介"></a>TreeSet简介</h1><p>此集合的实现和树结构有关。与HashSet集合类似，TreeSet也是基于Map来实现，具体实现TreeMap，其底层结构为红黑树（特殊的二叉查找树）；<br>与HashSet不同的是，TreeSet具有排序功能，分为自然排序(123456)和自定义排序两类，默认是自然排序；在程序中，我们可以按照任意顺序将元素插入到集合中，等到遍历时TreeSet会按照一定顺序输出（倒序/升序）；<br>它继承AbstractSet，实现NavigableSet, Cloneable, Serializable接口。<br>（1）与HashSet同理，TreeSet继承AbstractSet类，获得了Set集合基础实现操作；</p><a id="more"></a> <p>（2）TreeSet实现NavigableSet接口，而NavigableSet又扩展了SortedSet接口。实现NavigableSet接口使得TreeSet具备了元素搜索功能；<br>（3）TreeSet实现Cloneable接口，可以被克隆；<br>（4）TreeSet实现了Serializable接口，可以被序列化；<br>具有如下特点：</p><ul><li>对插入的元素进行排序，是一个有序的集合（主要与HashSet的区别）;</li><li>底层使用红黑树结构，而不是哈希表结构；</li><li>允许插入Null值；</li><li>不允许插入重复元素；</li><li>线程不安全；</li></ul><h1 id="TreeSet元素排序"><a href="#TreeSet元素排序" class="headerlink" title="TreeSet元素排序"></a>TreeSet元素排序</h1><p>TreeSet是一个有序集合，可以对集合元素排序，其中分为自然排序和自定义排序。<br>使用String、Intege类型：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public class TreeSetTest &#123;</span><br><span class="line">    public static void main(String[] agrs)&#123;</span><br><span class="line">        naturalSort();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //自然排序顺序：升序</span><br><span class="line">    public static void naturalSort()&#123;</span><br><span class="line">        TreeSet&lt;String&gt; treeSetString = new TreeSet&lt;String&gt;();</span><br><span class="line">        treeSetString.add(&quot;a&quot;);</span><br><span class="line">        treeSetString.add(&quot;z&quot;);</span><br><span class="line">        treeSetString.add(&quot;d&quot;);</span><br><span class="line">        treeSetString.add(&quot;b&quot;);</span><br><span class="line">        System.out.println(&quot;字母顺序：&quot; + treeSetString.toString());</span><br><span class="line"></span><br><span class="line">        TreeSet&lt;Integer&gt; treeSetInteger = new TreeSet&lt;Integer&gt;();</span><br><span class="line">        treeSetInteger.add(1);</span><br><span class="line">        treeSetInteger.add(24);</span><br><span class="line">        treeSetInteger.add(23);</span><br><span class="line">        treeSetInteger.add(6);</span><br><span class="line">        System.out.println(treeSetInteger.toString());</span><br><span class="line">        System.out.println(&quot;数字顺序：&quot; + treeSetString.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试结果：<br>字母顺序：[a, b, d, z]<br>数字顺序：[1, 6, 23, 24]</p><p>使用对象类型：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">public class App&#123;</span><br><span class="line"></span><br><span class="line">    private String name;</span><br><span class="line"></span><br><span class="line">    private Integer age;</span><br><span class="line"></span><br><span class="line">    public App()&#123;&#125;</span><br><span class="line"></span><br><span class="line">    public App(String name,Integer age)&#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Integer getAge() &#123;</span><br><span class="line">        return age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setAge(Integer age) &#123;</span><br><span class="line">        this.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args )&#123;</span><br><span class="line">        System.out.println( &quot;Hello World!&quot; );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class TreeSetTest &#123;</span><br><span class="line">    public static void main(String[] agrs)&#123;</span><br><span class="line">        customSort();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">     //自定义排序顺序：升序</span><br><span class="line">    public static void customSort()&#123;</span><br><span class="line">        TreeSet&lt;App&gt; treeSet = new TreeSet&lt;App&gt;();</span><br><span class="line"></span><br><span class="line">        //排序对象：</span><br><span class="line">        App app1 = new App(&quot;hello&quot;,10);</span><br><span class="line">        App app2 = new App(&quot;world&quot;,20);</span><br><span class="line">        App app3 = new App(&quot;my&quot;,15);</span><br><span class="line">        App app4 = new App(&quot;name&quot;,25);</span><br><span class="line"></span><br><span class="line">        //添加到集合：</span><br><span class="line">        treeSet.add(app1);</span><br><span class="line">        treeSet.add(app2);</span><br><span class="line">        treeSet.add(app3);</span><br><span class="line">        treeSet.add(app4);</span><br><span class="line">        System.out.println(&quot;TreeSet集合顺序为：&quot;+treeSet);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试结果：<br>抛出异常：提示类App不能转换为Comparable对象：<br>Exception in thread “main” java.lang.ClassCastException: com.huangqiuping.collection.App cannot be cast to java.lang.Comparable</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">compare(key, key); // type (and possibly null) check</span><br><span class="line"></span><br><span class="line">final int compare(Object k1, Object k2) &#123;</span><br><span class="line">    return comparator==null ? ((Comparable&lt;? super K&gt;)k1).compareTo((K)k2)</span><br><span class="line">        : comparator.compare((K)k1, (K)k2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过查看源码，在TreeSet调用add方法时，会调用到底层TreeMap的put方法，在put方法中会调用到compare(key, key)方法，进行key大小的比较；<br>在比较的时候，会将传入的key进行类型强转，所以当我们自定义的App类进行比较的时候，自然就会抛出异常，因为App类并没有实现Comparable接口；<br>将App实现Comparable接口，在做比较:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">public class App implements Comparable&lt;App&gt;&#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private Integer age;</span><br><span class="line">    public App()&#123;&#125;</span><br><span class="line">    public App(String name,Integer age)&#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    public Integer getAge() &#123;</span><br><span class="line">        return age;</span><br><span class="line">    &#125;</span><br><span class="line">    public void setAge(Integer age) &#123;</span><br><span class="line">        this.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    //自定义比较：先比较name的长度，在比较age的大小；</span><br><span class="line">    public int compareTo(App app) &#123;</span><br><span class="line">        //比较name的长度：</span><br><span class="line">        int num = this.name.length() - app.name.length();</span><br><span class="line">        //如果name长度一样，则比较年龄的大小：</span><br><span class="line">        return num == 0 ? this.age - app.age : num;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;App&#123;&quot; +</span><br><span class="line">                &quot;name=&apos;&quot; + name + &apos;\&apos;&apos; +</span><br><span class="line">                &quot;, age=&quot; + age +</span><br><span class="line">                &apos;&#125;&apos;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试结果如下：<br>TreeSet集合顺序为：[App{name=’my’, age=15}, App{name=’name’, age=25}, App{name=’hello’, age=10}, App{name=’world’, age=20}]</p><p>此外，还有另一种方式，那就是实现Comparetor<t>接口，并重写compare方法；</t></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//自定义App类的比较器：</span><br><span class="line">public class AppComparator implements Comparator&lt;App&gt; &#123;</span><br><span class="line"></span><br><span class="line">    //比较方法：先比较年龄，年龄若相同在比较名字长度；</span><br><span class="line">    public int compare(App app1, App app2) &#123;</span><br><span class="line">        int num = app1.getAge() - app2.getAge();</span><br><span class="line">        return num == 0 ? app1.getName().length() - app2.getName().length() : num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时，App不用在实现Comparerable接口了，单纯的定义一个类即可；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">public class App&#123;</span><br><span class="line"></span><br><span class="line">    private String name;</span><br><span class="line"></span><br><span class="line">    private Integer age;</span><br><span class="line"></span><br><span class="line">    public App()&#123;&#125;</span><br><span class="line"></span><br><span class="line">    public App(String name,Integer age)&#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Integer getAge() &#123;</span><br><span class="line">        return age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setAge(Integer age) &#123;</span><br><span class="line">        this.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args )&#123;</span><br><span class="line">        System.out.println( &quot;Hello World!&quot; );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class TreeSetTest &#123;</span><br><span class="line">    public static void main(String[] agrs)&#123;</span><br><span class="line">        customSort();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //自定义比较器：升序</span><br><span class="line">    public static void customComparatorSort()&#123;</span><br><span class="line">        TreeSet&lt;App&gt; treeSet = new TreeSet&lt;App&gt;(new AppComparator());</span><br><span class="line">        </span><br><span class="line">        //排序对象：</span><br><span class="line">        App app1 = new App(&quot;hello&quot;,10);</span><br><span class="line">        App app2 = new App(&quot;world&quot;,20);</span><br><span class="line">        App app3 = new App(&quot;my&quot;,15);</span><br><span class="line">        App app4 = new App(&quot;name&quot;,25);</span><br><span class="line">        </span><br><span class="line">        //添加到集合：</span><br><span class="line">        treeSet.add(app1);</span><br><span class="line">        treeSet.add(app2);</span><br><span class="line">        treeSet.add(app3);</span><br><span class="line">        treeSet.add(app4);</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;TreeSet集合顺序为：&quot;+treeSet);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试结果：<br>TreeSet集合顺序为：[App{name=’hello’, age=10}, App{name=’my’, age=15}, App{name=’world’, age=20}, App{name=’name’, age=25}]</p><p>关于compareTo()、compare()方法：<br>结果返回大于0时，方法前面的值大于方法中的值；<br>结果返回等于0时，方法前面的值等于方法中的值；<br>结果返回小于0时，方法前面的值小于方法中的值；</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;TreeSet简介&quot;&gt;&lt;a href=&quot;#TreeSet简介&quot; class=&quot;headerlink&quot; title=&quot;TreeSet简介&quot;&gt;&lt;/a&gt;TreeSet简介&lt;/h1&gt;&lt;p&gt;此集合的实现和树结构有关。与HashSet集合类似，TreeSet也是基于Map来实现，具体实现TreeMap，其底层结构为红黑树（特殊的二叉查找树）；&lt;br&gt;与HashSet不同的是，TreeSet具有排序功能，分为自然排序(123456)和自定义排序两类，默认是自然排序；在程序中，我们可以按照任意顺序将元素插入到集合中，等到遍历时TreeSet会按照一定顺序输出（倒序/升序）；&lt;br&gt;它继承AbstractSet，实现NavigableSet, Cloneable, Serializable接口。&lt;br&gt;（1）与HashSet同理，TreeSet继承AbstractSet类，获得了Set集合基础实现操作；&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="Java" scheme="ayjcsgm.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>简述HashSet的元素唯一机制</title>
    <link href="ayjcsgm.github.io/2019/12/11/%E7%AE%80%E8%BF%B0HashSet%E7%9A%84%E5%85%83%E7%B4%A0%E5%94%AF%E4%B8%80%E6%9C%BA%E5%88%B6/"/>
    <id>ayjcsgm.github.io/2019/12/11/简述HashSet的元素唯一机制/</id>
    <published>2019-12-11T12:29:26.000Z</published>
    <updated>2019-12-14T11:33:49.321Z</updated>
    
    <content type="html"><![CDATA[<h1 id="HashSet简介"><a href="#HashSet简介" class="headerlink" title="HashSet简介"></a>HashSet简介</h1><p>HashSet实现Set接口，底层由HashMap来实现，为哈希表结构，新增元素相当于HashMap的key，value默认为一个固定的Object。<br>当有元素插入的时候，会计算元素的hashCode值，将元素插入到哈希表对应的位置中来；<br>它继承于AbstractSet，实现了Set, Cloneable, Serializable接口。<br>(1)HashSet继承AbstractSet类，获得了Set接口大部分的实现，减少了实现此接口所需的工作，实际上是又继承了AbstractCollection类；<br>(2)HashSet实现了Set接口，获取Set接口的方法，可以自定义具体实现，也可以继承AbstractSet类中的实现；</p><a id="more"></a> <p>(3)HashSet实现Cloneable，得到了clone()方法，可以实现克隆功能；<br>(4)HashSet实现Serializable，表示可以被序列化。<br>具有如下特点：  </p><ul><li>不允许出现重复因素；</li><li>允许插入Null值；</li><li>元素无序（添加顺序和遍历顺序不一致）；</li><li>线程不安全，若2个线程同时操作HashSet，必须通过代码实现同步；<h1 id="HashSet基本操作"><a href="#HashSet基本操作" class="headerlink" title="HashSet基本操作"></a>HashSet基本操作</h1>HashSet底层由HashMap实现，插入的元素被当做是HashMap的key，根据hashCode值来确定集合中的位置，由于Set集合中并没有角标的概念，所以并没有像List一样提供get（）方法。当获取HashSet中某个元素时，只能通过遍历集合的方式进行equals()比较来实现；<h1 id="HashSet元素添加分析"><a href="#HashSet元素添加分析" class="headerlink" title="HashSet元素添加分析"></a>HashSet元素添加分析</h1>Set集合不允许添加重复元素，实际上是调用了HashMap中的put方法。<br>简单事例：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">public class HashSetTest &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] agrs)&#123;</span><br><span class="line">        //hashCode() 和 equals()测试：</span><br><span class="line">        hashCodeAndEquals();</span><br><span class="line">    &#125;</span><br><span class="line">    public static void hashCodeAndEquals()&#123;</span><br><span class="line">        //第一个 Set集合：</span><br><span class="line">        Set&lt;String&gt; set1 = new HashSet&lt;String&gt;();</span><br><span class="line">        String str1 = new String(&quot;huangqiuping&quot;);</span><br><span class="line">        String str2 = new String(&quot;huangqiuping&quot;);</span><br><span class="line">        set1.add(str1);</span><br><span class="line">        set1.add(str2);</span><br><span class="line">        System.out.println(&quot;长度：&quot;+set1.size()+&quot;,内容为：&quot;+set1);</span><br><span class="line"></span><br><span class="line">        //第二个 Set集合：</span><br><span class="line">        Set&lt;App&gt; set2 = new HashSet&lt;App&gt;();</span><br><span class="line">        App app1 = new App();</span><br><span class="line">        app1.setName(&quot;huangqiuping&quot;);</span><br><span class="line"></span><br><span class="line">        App app2 = new App();</span><br><span class="line">        app2.setName(&quot;huangqiuping&quot;);</span><br><span class="line"></span><br><span class="line">        set2.add(app1);</span><br><span class="line">        set2.add(app2);</span><br><span class="line">        System.out.println(&quot;长度：&quot;+set2.size()+&quot;,内容为：&quot;+set2);</span><br><span class="line"></span><br><span class="line">        //第三个 Set集合：</span><br><span class="line">        Set&lt;App&gt; set3 = new HashSet&lt;App&gt;();</span><br><span class="line">        App app3 = new App();</span><br><span class="line">        app3.setName(&quot;huangqiuping&quot;);</span><br><span class="line">        set3.add(app3);</span><br><span class="line">        set3.add(app3);</span><br><span class="line">        System.out.println(&quot;长度：&quot;+set3.size()+&quot;,内容为：&quot;+set3);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试结果：<br>长度：1,内容为：[huangqiuping]<br>长度：2,内容为：[com.huangqiuping.collection.App@efb78af, com.huangqiuping.collection.App@5f3306ad]<br>长度：1,内容为：[com.huangqiuping.collection.App@1fb030d8]</p><p>可以看到，第一个Set集合中最终只有一个元素；第二个Set集合保留了2个元素；第三个集合也只有1个元素；<br>来看看HashSet的add(E e)方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public boolean add(E e) &#123;</span><br><span class="line">    return map.put(e, PRESENT)==null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在底层HashSet调用了HashMap的put(K key, V value)方法:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public V put(K key, V value) &#123;</span><br><span class="line">    if (table == EMPTY_TABLE) &#123;</span><br><span class="line">        inflateTable(threshold);</span><br><span class="line">    &#125;</span><br><span class="line">    if (key == null)</span><br><span class="line">        return putForNullKey(value);</span><br><span class="line">    int hash = hash(key);</span><br><span class="line">    int i = indexFor(hash, table.length);</span><br><span class="line">    for (Entry&lt;K,V&gt; e = table[i]; e != null; e = e.next) &#123;</span><br><span class="line">        Object k;</span><br><span class="line">        if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;</span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            e.value = value;</span><br><span class="line">            e.recordAccess(this);</span><br><span class="line">            return oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    modCount++;</span><br><span class="line">    addEntry(hash, key, value, i);</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过查看以上的源码，可以了解到：实际的逻辑都是在 <strong>HashMap的put()</strong> 方法中。<br><strong>int hash = hash(key)</strong> 对传入的key计算hash值；<br><strong>int i = indexFor(hash, table.length)</strong> 对hash值进行转换，转换成数组的index(HashMap中底层存储使用了Entry&lt;K,V&gt;[]数组)；<br>for (Entry&lt;K,V&gt; e = table[i]; e != null; e = e.next) 判断对应index下是否存在元素；<br>如果存在，则if(e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k)))判断；<br>如果不存在，则addEntry(hash, key, value, i)直接添加；<br>简单概括如下：<br><strong>在向HashMap中添加元素时，先判断key的hashCode值是否相同，如果相同，则调用equals()、==进行判断，若相同则覆盖原有元素；如果不同，则直接向Map中添加元素</strong>；<br>通过上面的例子可以知道：<br>1、在第一个Set集合中，我们new了两个String对象，赋了相同的值。当传入到HashMap中时，key均为“huangqiuping”，所以hash和i的值都相同。进行if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k)))判断，由于String对象重写了equals()方法，所以在((k = e.key) == key || key.equals(k))判断时，返回了true，所以第二次的插入并不会增加Set集合的长度；<br>2、第二个Set集合中，也是new了两个对象，但没有重写equals()方法（底层调用的Object的equals()，也就是==判断），所以会增加2个元素；<br>3、第三个Set集合中，只new了一个对象，调用的两次add方法都添加的这个新new的对象，所以也只是保留了1个元素；</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;HashSet简介&quot;&gt;&lt;a href=&quot;#HashSet简介&quot; class=&quot;headerlink&quot; title=&quot;HashSet简介&quot;&gt;&lt;/a&gt;HashSet简介&lt;/h1&gt;&lt;p&gt;HashSet实现Set接口，底层由HashMap来实现，为哈希表结构，新增元素相当于HashMap的key，value默认为一个固定的Object。&lt;br&gt;当有元素插入的时候，会计算元素的hashCode值，将元素插入到哈希表对应的位置中来；&lt;br&gt;它继承于AbstractSet，实现了Set, Cloneable, Serializable接口。&lt;br&gt;(1)HashSet继承AbstractSet类，获得了Set接口大部分的实现，减少了实现此接口所需的工作，实际上是又继承了AbstractCollection类；&lt;br&gt;(2)HashSet实现了Set接口，获取Set接口的方法，可以自定义具体实现，也可以继承AbstractSet类中的实现；&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="Java" scheme="ayjcsgm.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>简单明了的介绍下TreeMap</title>
    <link href="ayjcsgm.github.io/2019/12/11/%E7%AE%80%E5%8D%95%E6%98%8E%E4%BA%86%E7%9A%84%E4%BB%8B%E7%BB%8D%E4%B8%8BTreeMap/"/>
    <id>ayjcsgm.github.io/2019/12/11/简单明了的介绍下TreeMap/</id>
    <published>2019-12-11T12:29:02.000Z</published>
    <updated>2019-12-14T11:34:09.883Z</updated>
    
    <content type="html"><![CDATA[<h1 id="TreeMap简介"><a href="#TreeMap简介" class="headerlink" title="TreeMap简介"></a>TreeMap简介</h1><p>在Map集合框架中，除了HashMap以外，TreeMap也是常用到的集合对象之一。<br>与HashMap相比，TreeMap是一个能比较元素大小的Map集合，会对传入的key进行了大小排序。其中，可以使用元素的自然顺序，也可以使用集合中自定义的比较器来进行排序；<br>不同于HashMap的哈希映射，TreeMap实现了红黑树的结构，形成了一颗二叉树。</p><a id="more"></a> <p><img src="https://img-blog.csdnimg.cn/20191211103308557.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzY2NDQxOA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>TreeMap继承于AbstractMap，实现了Map, Cloneable, NavigableMap, Serializable接口。<br>(1)TreeMap 继承于AbstractMap，而AbstractMap实现了Map接口，并实现了Map接口中定义的方法，减少了其子类继承的复杂度；<br>(2)TreeMap 实现了Map接口，成为Map框架中的一员，可以包含着key-value形式的元素；<br>(3)TreeMap 实现了NavigableMap接口，意味着拥有了更强的元素搜索能力；<br>(4)TreeMap 实现了Cloneable接口，实现了clone()方法，可以被克隆；<br>(5)TreeMap 实现了Java.io.Serializable接口，支持序列化操作；<br>TreeMap具有如下特点：</p><ul><li>不允许出现重复的key；</li><li>可以插入null键，null值；</li><li>可以对元素进行排序；</li><li>无序集合（插入和遍历顺序不一致）；</li></ul><h1 id="TreeMap基本操作"><a href="#TreeMap基本操作" class="headerlink" title="TreeMap基本操作"></a>TreeMap基本操作</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">public class TreeMapTest &#123;</span><br><span class="line">    public static void main(String[] agrs)&#123;</span><br><span class="line">        //创建TreeMap对象：</span><br><span class="line">        TreeMap&lt;String,Integer&gt; treeMap = new TreeMap&lt;String,Integer&gt;();</span><br><span class="line">        System.out.println(&quot;初始化后,TreeMap元素个数为：&quot; + treeMap.size());</span><br><span class="line"></span><br><span class="line">        //新增元素:</span><br><span class="line">        treeMap.put(&quot;hello&quot;,1);</span><br><span class="line">        treeMap.put(&quot;world&quot;,2);</span><br><span class="line">        treeMap.put(&quot;my&quot;,3);</span><br><span class="line">        treeMap.put(&quot;name&quot;,4);</span><br><span class="line">        treeMap.put(&quot;is&quot;,5);</span><br><span class="line">        treeMap.put(&quot;huangqiuping&quot;,6);</span><br><span class="line">        treeMap.put(&quot;i&quot;,6);</span><br><span class="line">        treeMap.put(&quot;am&quot;,6);</span><br><span class="line">        treeMap.put(&quot;a&quot;,6);</span><br><span class="line">        treeMap.put(&quot;developer&quot;,6);</span><br><span class="line">        System.out.println(&quot;添加元素后,TreeMap元素个数为：&quot; + treeMap.size());</span><br><span class="line"></span><br><span class="line">        //遍历元素：</span><br><span class="line">        Set&lt;Map.Entry&lt;String,Integer&gt;&gt; entrySet = treeMap.entrySet();</span><br><span class="line">        for(Map.Entry&lt;String,Integer&gt; entry : entrySet)&#123;</span><br><span class="line">            String key = entry.getKey();</span><br><span class="line">            Integer value = entry.getValue();</span><br><span class="line">            System.out.println(&quot;TreeMap元素的key:&quot;+key+&quot;,value:&quot;+value);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //获取所有的key：</span><br><span class="line">        Set&lt;String&gt; keySet = treeMap.keySet();</span><br><span class="line">        for(String strKey:keySet)&#123;</span><br><span class="line">            System.out.println(&quot;TreeMap集合中的key:&quot;+strKey);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //获取所有的value:</span><br><span class="line">        Collection&lt;Integer&gt; valueList = treeMap.values();</span><br><span class="line">        for(Integer intValue:valueList)&#123;</span><br><span class="line">            System.out.println(&quot;TreeMap集合中的value:&quot; + intValue);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //获取元素：</span><br><span class="line">        //获取集合内元素key为&quot;huangqiuping&quot;的值</span><br><span class="line">        Integer getValue = treeMap.get(&quot;huangqiuping&quot;);</span><br><span class="line">        //获取集合内第一个元素</span><br><span class="line">        String firstKey = treeMap.firstKey();</span><br><span class="line">        //获取集合内最后一个元素</span><br><span class="line">        String lastKey =treeMap.lastKey();</span><br><span class="line">        //获取集合内的key小于&quot;huangqiuping&quot;的key</span><br><span class="line">        String lowerKey =treeMap.lowerKey(&quot;huangqiuping&quot;);</span><br><span class="line">        //获取集合内的key大于等于&quot;huangqiuping&quot;的key</span><br><span class="line">        String ceilingKey =treeMap.ceilingKey(&quot;huangqiuping&quot;);</span><br><span class="line">        //获取集合的key从&quot;a&quot;到&quot;huangqiuping&quot;的元素</span><br><span class="line">        SortedMap&lt;String,Integer&gt; sortedMap =treeMap.subMap(&quot;a&quot;,&quot;my&quot;);</span><br><span class="line"></span><br><span class="line">        //删除元素：</span><br><span class="line">        //删除集合中key为&quot;huangqiuping&quot;的元素</span><br><span class="line">        Integer removeValue = treeMap.remove(&quot;huangqiuping&quot;);</span><br><span class="line">        //清空集合元素：</span><br><span class="line">        treeMap.clear(); </span><br><span class="line"></span><br><span class="line">        //判断方法：</span><br><span class="line">        //判断集合是否为空</span><br><span class="line">        boolean isEmpty = treeMap.isEmpty();</span><br><span class="line">        //判断集合的key中是否包含&quot;huangqiuping&quot;</span><br><span class="line">        boolean isContain = treeMap.containsKey(&quot;huangqiuping&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="TreeMap排序"><a href="#TreeMap排序" class="headerlink" title="TreeMap排序"></a>TreeMap排序</h1><p>（1）使用元素自然排序<br>在使用自然顺序排序时候，需要区分两种情况：一种是Jdk定义的对象，一种是自己定义的对象；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">public class SortedTest implements Comparable&lt;SortedTest&gt; &#123;</span><br><span class="line">    private int age;</span><br><span class="line">    public SortedTest(int age)&#123;</span><br><span class="line">        this.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    public int getAge() &#123;</span><br><span class="line">        return age;</span><br><span class="line">    &#125;</span><br><span class="line">    public void setAge(int age) &#123;</span><br><span class="line">        this.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    //自定义对象，实现compareTo(T o)方法：</span><br><span class="line">    public int compareTo(SortedTest sortedTest) &#123;</span><br><span class="line">        int num = this.age - sortedTest.getAge();</span><br><span class="line">        //为0时候，两者相同：</span><br><span class="line">        if(num==0)&#123;</span><br><span class="line">            return 0;</span><br><span class="line">        //大于0时，传入的参数小：</span><br><span class="line">        &#125;else if(num&gt;0)&#123;</span><br><span class="line">            return 1;</span><br><span class="line">        //小于0时，传入的参数大：</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            return -1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class TreeMapTest &#123;</span><br><span class="line">    public static void main(String[] agrs)&#123;</span><br><span class="line">        //自然顺序比较</span><br><span class="line">        naturalSort();</span><br><span class="line">    &#125;</span><br><span class="line">     //自然排序顺序：</span><br><span class="line">    public static void naturalSort()&#123;</span><br><span class="line">        //第一种情况：Integer对象</span><br><span class="line">        TreeMap&lt;Integer,String&gt; treeMapFirst = new TreeMap&lt;Integer, String&gt;();</span><br><span class="line">        treeMapFirst.put(1,&quot;huangqiuping&quot;);</span><br><span class="line">        treeMapFirst.put(6,&quot;huangqiuping&quot;);</span><br><span class="line">        treeMapFirst.put(3,&quot;huangqiuping&quot;);</span><br><span class="line">        treeMapFirst.put(10,&quot;huangqiuping&quot;);</span><br><span class="line">        treeMapFirst.put(7,&quot;huangqiuping&quot;);</span><br><span class="line">        treeMapFirst.put(13,&quot;huangqiuping&quot;);</span><br><span class="line">        System.out.println(treeMapFirst.toString());</span><br><span class="line"></span><br><span class="line">        //第二种情况:SortedTest对象</span><br><span class="line">        TreeMap&lt;SortedTest,String&gt; treeMapSecond = new TreeMap&lt;SortedTest, String&gt;();</span><br><span class="line">        treeMapSecond.put(new SortedTest(10),&quot;huangqiuping&quot;);</span><br><span class="line">        treeMapSecond.put(new SortedTest(1),&quot;huangqiuping&quot;);</span><br><span class="line">        treeMapSecond.put(new SortedTest(13),&quot;huangqiuping&quot;);</span><br><span class="line">        treeMapSecond.put(new SortedTest(4),&quot;huangqiuping&quot;);</span><br><span class="line">        treeMapSecond.put(new SortedTest(0),&quot;huangqiuping&quot;);</span><br><span class="line">        treeMapSecond.put(new SortedTest(9),&quot;huangqiuping&quot;);</span><br><span class="line">        System.out.println(treeMapSecond.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在自然顺序比较中，需要让被比较的元素实现Comparable接口，否则在向集合里添加元素时报：”java.lang.ClassCastException: com.huangqiuping.collection.map.SortedTest cannot be cast to java.lang.Comparable”异常；<br>这是因为在调用put()方法时，会将传入的元素转化成Comparable类型对象，所以当你传入的元素没有实现Comparable接口时，就无法转换，遍会报错；<br>（2）使用自定义比较器排序<br>使用自定义比较器排序，需要在创建TreeMap对象时，将自定义比较器对象传入到TreeMap构造方法中；<br>自定义比较器对象，需要实现Comparator接口，并实现比较方法compare(To1,To2)；<br>使用自定义比较器排序的话，被比较的对象无需再实现Comparable接口了；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">public class SortedTest &#123;</span><br><span class="line">    private int age;</span><br><span class="line">    public SortedTest(int age)&#123;</span><br><span class="line">        this.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    public int getAge() &#123;</span><br><span class="line">        return age;</span><br><span class="line">    &#125;</span><br><span class="line">    public void setAge(int age) &#123;</span><br><span class="line">        this.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class SortedTestComparator implements Comparator&lt;SortedTest&gt; &#123;</span><br><span class="line">    //自定义比较器：实现compare(To1,To2)方法：</span><br><span class="line">    public int compare(SortedTest sortedTest1, SortedTest sortedTest2) &#123;</span><br><span class="line">        int num = sortedTest1.getAge() - sortedTest2.getAge();</span><br><span class="line">        if(num==0)&#123;//为0时候，两者相同：</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;else if(num&gt;0)&#123;//大于0时，后面的参数小：</span><br><span class="line">            return 1;</span><br><span class="line">        &#125;else&#123;//小于0时，前面的参数小：</span><br><span class="line">            return -1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class TreeMapTest &#123;</span><br><span class="line">    public static void main(String[] agrs)&#123;</span><br><span class="line">        //自定义顺序比较</span><br><span class="line">        customSort();</span><br><span class="line">    &#125;</span><br><span class="line">    //自定义排序顺序:</span><br><span class="line">    public static void customSort()&#123;</span><br><span class="line">        TreeMap&lt;SortedTest,String&gt; treeMap = new TreeMap&lt;SortedTest, String&gt;(new SortedTestComparator());</span><br><span class="line">        treeMap.put(new SortedTest(10),&quot;hello&quot;);</span><br><span class="line">        treeMap.put(new SortedTest(21),&quot;my&quot;);</span><br><span class="line">        treeMap.put(new SortedTest(15),&quot;name&quot;);</span><br><span class="line">        treeMap.put(new SortedTest(2),&quot;is&quot;);</span><br><span class="line">        treeMap.put(new SortedTest(1),&quot;huangqiuping&quot;);</span><br><span class="line">        treeMap.put(new SortedTest(7),&quot;world&quot;);</span><br><span class="line">        System.out.println(treeMap.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;TreeMap简介&quot;&gt;&lt;a href=&quot;#TreeMap简介&quot; class=&quot;headerlink&quot; title=&quot;TreeMap简介&quot;&gt;&lt;/a&gt;TreeMap简介&lt;/h1&gt;&lt;p&gt;在Map集合框架中，除了HashMap以外，TreeMap也是常用到的集合对象之一。&lt;br&gt;与HashMap相比，TreeMap是一个能比较元素大小的Map集合，会对传入的key进行了大小排序。其中，可以使用元素的自然顺序，也可以使用集合中自定义的比较器来进行排序；&lt;br&gt;不同于HashMap的哈希映射，TreeMap实现了红黑树的结构，形成了一颗二叉树。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="Java" scheme="ayjcsgm.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>解析JDK8中Arrays.sort底层原理及其排序算法的选择</title>
    <link href="ayjcsgm.github.io/2019/12/11/%E8%A7%A3%E6%9E%90JDK8%E4%B8%ADArrays-sort%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E5%8F%8A%E5%85%B6%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%9A%84%E9%80%89%E6%8B%A9/"/>
    <id>ayjcsgm.github.io/2019/12/11/解析JDK8中Arrays-sort底层原理及其排序算法的选择/</id>
    <published>2019-12-11T12:26:13.000Z</published>
    <updated>2019-12-14T11:34:35.715Z</updated>
    
    <content type="html"><![CDATA[<p>暂时网上看过很多JDK8中Arrays.sort的底层原理，有些说是插入排序，有些说是归并排序，也有说大于域值用计数排序法，否则就使用插入排序。。。其实不全对。让我们对着源码分析个究竟：</p><a id="more"></a> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> // Use Quicksort on small arrays</span><br><span class="line"> if (right - left &lt; QUICKSORT_THRESHOLD) &#123;//QUICKSORT_THRESHOLD = 286</span><br><span class="line">    sort(a, left, right, true);</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>数组一进来，会碰到第一个阀值QUICKSORT_THRESHOLD（286），注解上说，小过这个阀值的进入Quicksort （快速排序），其实并不全是，点进去sort(a, left, right, true);方法能看见：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// Use insertion sort on tiny arrays</span><br><span class="line">       if (length &lt; INSERTION_SORT_THRESHOLD) &#123;//INSERTION_SORT_THRESHOLD=47</span><br><span class="line">           if (leftmost) ……</span><br></pre></td></tr></table></figure><p>我们看到第二个阀值INSERTION_SORT_THRESHOLD（47），如果元素少于47这个阀值，就用插入排序，往下看确实如此：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">            * Traditional (without sentinel) insertion sort,</span><br><span class="line">            * optimized for server VM, is used in case of</span><br><span class="line">            * the leftmost part.</span><br><span class="line">            */</span><br><span class="line">           for (int i = left, j = i; i &lt; right; j = ++i) &#123;</span><br><span class="line">               int ai = a[i + 1];</span><br><span class="line">               while (ai &lt; a[j]) &#123;</span><br><span class="line">                   a[j + 1] = a[j];</span><br><span class="line">                   if (j-- == left) &#123;</span><br><span class="line">                       break;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">               a[j + 1] = ai;</span><br><span class="line">           &#125;</span><br></pre></td></tr></table></figure><p>插入排序动图演示：<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X2dpZi9mRXNXa1ZyU2s1NHB6ZTRjUWRYd002aWJmR3p5cGRwR2hEZmQ3TjZwSlJpY1R6ZmljTlZMSHJUTDJoNjdRNmgyQjk4R2ljMWZyOTZ5Nm50R2liYkRrajMza2lhQS82NDA?x-oss-process=image/format,png" alt="在这里插入图片描述"><br>元素少于47用插入排序</p><p>至于大过INSERTION_SORT_THRESHOLD（47）的，用一种快速排序的方法：<br>1.从数列中挑出五个元素，称为 “基准”（pivot）；<br>2.重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；<br>3.递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。</p><p>快速排序动图演示：<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X2dpZi9mRXNXa1ZyU2s1NHB6ZTRjUWRYd002aWJmR3p5cGRwR2hwMnNubkZiR0pIZEJvUTJYTEdyTVE5cFZTanZPUE1jOWliQUgxWmh6VXhUZWtjQ0J1U2hOdUR3LzY0MA?x-oss-process=image/format,png" alt="在这里插入图片描述"></p><p>这是少于阀值QUICKSORT_THRESHOLD（286）的两种情况，至于大于286的，它会进入归并排序（Merge Sort），但在此之前，它有个小动作：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">// Check if the array is nearly sorted</span><br><span class="line">for (int k = left; k &lt; right; run[count] = k) &#123;</span><br><span class="line">    if (a[k] &lt; a[k + 1]) &#123; // ascending</span><br><span class="line">        while (++k &lt;= right &amp;&amp; a[k - 1] &lt;= a[k]);</span><br><span class="line">    &#125; else if (a[k] &gt; a[k + 1]) &#123; // descending</span><br><span class="line">        while (++k &lt;= right &amp;&amp; a[k - 1] &gt;= a[k]);</span><br><span class="line">        for (int lo = run[count] - 1, hi = k; ++lo &lt; --hi; ) &#123;</span><br><span class="line">            int t = a[lo]; a[lo] = a[hi]; a[hi] = t;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123; // equal</span><br><span class="line">        for (int m = MAX_RUN_LENGTH; ++k &lt;= right &amp;&amp; a[k - 1] == a[k]; ) &#123;</span><br><span class="line">            if (--m == 0) &#123;</span><br><span class="line">                sort(a, left, right, true);</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /*</span><br><span class="line">     * The array is not highly structured,</span><br><span class="line">     * use Quicksort instead of merge sort.</span><br><span class="line">     */</span><br><span class="line">    if (++count == MAX_RUN_COUNT) &#123;</span><br><span class="line">        sort(a, left, right, true);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里主要作用是看他数组具不具备结构：实际逻辑是分组排序，每降序为一个组，像1,9,8,7,6,8。9到6是降序，为一个组，然后把降序的一组排成升序：1,6,7,8,9,8。然后最后的8后面继续往后面找。。。</p><p>每遇到这样一个降序组，++count，当count大于MAX_RUN_COUNT（67），被判断为这个数组不具备结构（也就是这数据时而升时而降），然后送给之前的sort(里面的快速排序)的方法（The array is not highly structured,use Quicksort instead of merge sort.）。</p><p>如果count少于MAX_RUN_COUNT（67）的，说明这个数组还有点结构，就继续往下走下面的归并排序：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// Determine alternation base for merge</span><br><span class="line">byte odd = 0;    </span><br><span class="line">for (int n = 1; (n &lt;&lt;= 1) &lt; count;odd ^= 1);</span><br></pre></td></tr></table></figure><p>从这里开始，正式进入归并排序（Merge Sort）！</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">// Merging</span><br><span class="line">for (int last; count &gt; 1; count = last) &#123;</span><br><span class="line">    for (int k = (last = 0) + 2; k &lt;= count; k += 2) &#123;</span><br><span class="line">        int hi = run[k], mi = run[k - 1];</span><br><span class="line">        for (int i = run[k - 2], p = i, q = mi; i &lt; hi; ++i) &#123;</span><br><span class="line">            if (q &gt;= hi || p &lt; mi &amp;&amp; a[p + ao] &lt;= a[q + ao]) &#123;</span><br><span class="line">                b[i + bo] = a[p++ + ao];</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                b[i + bo] = a[q++ + ao];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        run[++last] = hi;</span><br><span class="line">    &#125;</span><br><span class="line">    if ((count &amp; 1) != 0) &#123;</span><br><span class="line">        for (int i = right, lo = run[count - 1]; --i &gt;= lo;</span><br><span class="line">            b[i + bo] = a[i + ao]</span><br><span class="line">        );</span><br><span class="line">        run[++last] = right;</span><br><span class="line">    &#125;</span><br><span class="line">    int[] t = a; a = b; b = t;</span><br><span class="line">    int o = ao; ao = bo; bo = o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>归并排序动图演示：<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X2dpZi9mRXNXa1ZyU2s1NHB6ZTRjUWRYd002aWJmR3p5cGRwR2h4WUtndlFEcVhMbFVTdmZQbE5CQW1saWJkOVRPUkZkY0hhbmRSQ2RYWWF5aWFKeWliYUpBMldybXcvNjQw?x-oss-process=image/format,png" alt="在这里插入图片描述"><br>总结：<br>从上面分析，Arrays.sort并不是单一的排序，而是插入排序，快速排序，归并排序三种排序的组合，为此我画了个流程图：<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWcyLm11a2V3YW5nLmNvbS81ZDVkZmMwYTAwMDEwNDcyMDUwMDA1OTMucG5n?x-oss-process=image/format,png" alt="在这里插入图片描述"></p><p>算法的选择：</p><p>PS：关于排序算法的文章，推荐这两篇，个人觉得写得挺好，容易入门：<br><a href="https://mp.weixin.qq.com/s/t0dsJeN397wO41pwBWPeTg" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/t0dsJeN397wO41pwBWPeTg</a><br><a href="https://www.cnblogs.com/huangbw/p/7398418.html" target="_blank" rel="noopener">https://www.cnblogs.com/huangbw/p/7398418.html</a></p><p>稳定：如果a原本在b前面，而a=b，排序之后a仍然在b的前面；</p><p>不稳定：如果a原本在b的前面，而a=b，排序之后a可能会出现在b的后面；</p><p>时间复杂度按n越大算法越复杂来排的话：常数阶O(1)、对数阶O(logn)、线性阶O(n)、线性对数阶O(nlogn)、平方阶O(n²)、立方阶O(n³)、……k次方阶O(n的k次方)、指数阶O(2的n次方)。</p><p>O(nlogn)只代表增长量级，同一个量级前面的常数也可以不一样，不同数量下面的实际运算时间也可以不一样。数量非常小的情况下（就像上面说到的，少于47的），插入排序等可能会比快速排序更快。<br>所以数组少于47的会进入插入排序。</p><p>快排数据越无序越快（加入随机化后基本不会退化），平均常数最小，不需要额外空间，不稳定排序。<br>归排速度稳定，常数比快排略大，需要额外空间，稳定排序。<br>所以大于或等于47或少于286会进入快排，而在大于或等于286后，会有个小动作：“// Check if the array is nearly sorted”。<br>这里第一个作用是先梳理一下数据方便后续的归并排序，第二个作用就是即便大于286，但在降序组太多的时候（被判断为没有结构的数据，The array is not highly structured,use Quicksort instead of merge sort.），要转回快速排序。</p><hr>这就是jdk8中Arrays.sort的底层原理，自己在研究和分析中学到很多，希望能给各位工作中或面试中一些启发和帮助！Thanks for watching！]]></content>
    
    <summary type="html">
    
      &lt;p&gt;暂时网上看过很多JDK8中Arrays.sort的底层原理，有些说是插入排序，有些说是归并排序，也有说大于域值用计数排序法，否则就使用插入排序。。。其实不全对。让我们对着源码分析个究竟：&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="Java" scheme="ayjcsgm.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>为什么 String 的 hashCode 选择 31 作为乘子</title>
    <link href="ayjcsgm.github.io/2019/12/11/%E4%B8%BA%E4%BB%80%E4%B9%88-String-%E7%9A%84-hashCode-%E9%80%89%E6%8B%A9-31-%E4%BD%9C%E4%B8%BA%E4%B9%98%E5%AD%90/"/>
    <id>ayjcsgm.github.io/2019/12/11/为什么-String-的-hashCode-选择-31-作为乘子/</id>
    <published>2019-12-11T12:25:54.000Z</published>
    <updated>2019-12-14T11:35:04.141Z</updated>
    
    <content type="html"><![CDATA[<p>某天，我在写代码的时候，无意中点开了 String hashCode 方法。然后大致看了一下 hashCode 的实现，发现并不是很复杂。但是我从源码中发现了一个奇怪的数字，也就是本文的主角31。这个数字居然不是用常量声明的，所以没法从字面意思上推断这个数字的用途。后来带着疑问和好奇心，到网上去找资料查询一下。在看完资料后，默默的感叹了一句，原来是这样啊。那么到底是哪样呢？在接下来章节里，请大家带着好奇心和我揭开数字31的用途之谜。</p><a id="more"></a> <h4 id="选择31的原因"><a href="#选择31的原因" class="headerlink" title="选择31的原因"></a>选择31的原因</h4><p>在详细说明 String hashCode 方法选择数字31的作为乘子的原因之前，我们先来看看 String hashCode 方法是怎样实现的，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public int hashCode() &#123;</span><br><span class="line">    int h = hash;</span><br><span class="line">    if (h == 0 &amp;&amp; value.length &gt; 0) &#123;</span><br><span class="line">        char val[] = value;</span><br><span class="line"></span><br><span class="line">        for (int i = 0; i &lt; value.length; i++) &#123;</span><br><span class="line">            h = 31 * h + val[i];</span><br><span class="line">        &#125;</span><br><span class="line">        hash = h;</span><br><span class="line">    &#125;</span><br><span class="line">    return h;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码就是 String hashCode 方法的实现，是不是很简单。实际上 hashCode 方法核心的计算逻辑只有三行，也就是代码中的 for 循环。我们可以由上面的 for 循环推导出一个计算公式，hashCode 方法注释中已经给出。如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s[0]*31^(n-1) + s[1]*31^(n-2) + ... + s[n-1]</span><br></pre></td></tr></table></figure><p>这里说明一下，上面的 s 数组即源码中的 val 数组，是 String 内部维护的一个 char 类型数组。这里我来简单推导一下这个公式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">假设 n=3</span><br><span class="line">i=0 -&gt; h = 31 * 0 + val[0]</span><br><span class="line">i=1 -&gt; h = 31 * (31 * 0 + val[0]) + val[1]</span><br><span class="line">i=2 -&gt; h = 31 * (31 * (31 * 0 + val[0]) + val[1]) + val[2]</span><br><span class="line">       h = 31*31*31*0 + 31*31*val[0] + 31*val[1] + val[2]</span><br><span class="line">       h = 31^(n-1)*val[0] + 31^(n-2)*val[1] + val[2]</span><br></pre></td></tr></table></figure><p>上面的公式包括公式的推导并不是本文的重点，大家了解了解即可。接下来来说说本文的重点，即选择31的理由。从网上的资料来看，一般有如下两个原因：</p><p>第一 31是一个不大不小的质数，是作为 hashCode 乘子的优选质数之一。另外一些相近的质数，比如37、41、43等等，也都是不错的选择。那么为啥偏偏选中了31呢？请看第二个原因。</p><p>第二 31可以被 JVM 优化，<strong>31 * i = (i &lt;&lt; 5) - i</strong>。</p><p>上面两个原因中，第一个需要解释一下，第二个比较简单，就不说了。下面我来解释第一个理由。一般在设计哈希算法时，会选择一个特殊的质数。至于为啥选择质数，我想应该是可以降低哈希算法的冲突率。至于原因，这个就要问数学家了，我几乎可以忽略的数学水平解释不了这个原因。上面说到，31是一个不大不小的质数，是优选乘子。那为啥同是质数的2和101（或者更大的质数）就不是优选乘子呢，分析如下。</p><p>这里先分析质数2。首先，假设<strong>n = 6</strong>，然后把质数2和 n 带入上面的计算公式。并仅计算公式中次数最高的那一项，结果是<strong>2^5 = 32</strong>，是不是很小。所以这里可以断定，当字符串长度不是很长时，用质数2做为乘子算出的哈希值，数值不会很大。也就是说，哈希值会分布在一个较小的数值区间内，分布性不佳，最终可能会导致冲突率上升。</p><p>上面说了，质数2做为乘子会导致哈希值分布在一个较小区间内，那么如果用一个较大的大质数101会产生什么样的结果呢？根据上面的分析，我想大家应该可以猜出结果了。就是不用再担心哈希值会分布在一个小的区间内了，因为<strong>101^5 = 10,510,100,501</strong>。但是要注意的是，这个计算结果太大了。如果用 int 类型表示哈希值，结果会溢出，最终导致数值信息丢失。尽管数值信息丢失并不一定会导致冲突率上升，但是我们暂且先认为质数101（或者更大的质数）也不是很好的选择。最后，我们再来看看质数31的计算结果：<strong>31^5 = 28629151</strong>，结果值相对于<strong>32和10,510,100,501</strong>来说。是不是很nice，不大不小。</p><p>上面用了比较简陋的数学手段证明了数字31是一个不大不小的质数，是作为 hashCode 乘子的优选质数之一。</p><p>接下来我会用详细的实验来验证上面的结论，不过在验证前，我们先看看 Stack Overflow 上关于这个问题的讨论，<a href="https://stackoverflow.com/questions/299304/why-does-javas-hashcode-in-string-use-31-as-a-multiplier" target="_blank" rel="noopener">Why does Java’s hashCode() in String use 31 as a multiplier?</a> 。其中排名第一的答案引用了《Effective Java》中的一段话，这里也引用一下：</p><blockquote><p>The value 31 was chosen because it is an odd prime. If it were even and the multiplication overflowed, information would be lost, as multiplication by 2 is equivalent to shifting. The advantage of using a prime is less clear, but it is traditional. A nice property of 31 is that the multiplication can be replaced by a shift and a subtraction for better performance: 31 * i == (i &lt;&lt; 5) - i. Modern VMs do this sort of optimization automatically.</p></blockquote><p>简单翻译一下：</p><blockquote><p>选择数字31是因为它是一个奇质数，如果选择一个偶数会在乘法运算中产生溢出，导致数值信息丢失，因为乘二相当于移位运算。选择质数的优势并不是特别的明显，但这是一个传统。同时，数字31有一个很好的特性，即乘法运算可以被移位和减法运算取代，来获取更好的性能：31 * i == (i &lt;&lt; 5) - i，现代的 Java 虚拟机可以自动的完成这个优化。</p></blockquote><p>排名第二的答案设这样说的：</p><blockquote><p>As Goodrich and Tamassia point out, If you take over 50,000 English<br>words (formed as the union of the word lists provided in two variants<br>of Unix), using the constants 31, 33, 37, 39, and 41 will produce less<br>than 7 collisions in each case. Knowing this, it should come as no<br>surprise that many Java implementations choose one of these constants.</p></blockquote><p>这段话也翻译一下：</p><blockquote><p>正如 Goodrich 和 Tamassia 指出的那样，如果你对超过 50,000 个英文单词（由两个不同版本的 Unix<br>字典合并而成）进行 hash code 运算，并使用常数 31, 33, 37, 39 和 41<br>作为乘子，每个常数算出的哈希值冲突数都小于7个，所以在上面几个常数中，常数 31 被 Java 实现所选用也就不足为奇了。</p></blockquote><p>上面的两个答案完美的解释了 Java 源码中选用数字 31 的原因。接下来，我将针对第二个答案就行验证，请大家继续往下看。</p><h5 id="实验及数据可视化"><a href="#实验及数据可视化" class="headerlink" title="实验及数据可视化"></a>实验及数据可视化</h5><p>本节，我将使用不同的数字作为乘子，对超过23万个英文单词进行哈希运算，并计算哈希算法的冲突率。同时，我也将针对不同乘子算出的哈希值分布情况进行可视化处理，让大家可以直观的看到数据分布情况。本次实验所使用的数据是 Unix/Linux 平台中的英文字典文件，文件路径为 <strong>/usr/share/dict/words</strong>。</p><p><strong>哈希值冲突率计算</strong></p><p>计算哈希算法冲突率并不难，比如可以一次性将所有单词的 hash code 算出，并放入 Set 中去除重复值。之后拿单词数减去 set.size() 即可得出冲突数，有了冲突数，冲突率就可以算出来了。当然，如果使用 JDK8 提供的流式计算 API，则可更方便算出，代码片段如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public static Integer hashCode(String str, Integer multiplier) &#123;</span><br><span class="line">    int hash = 0;</span><br><span class="line">    for (int i = 0; i &lt; str.length(); i++) &#123;</span><br><span class="line">        hash = multiplier * hash + str.charAt(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return hash;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 计算 hash code 冲突率，顺便分析一下 hash code 最大值和最小值，并输出</span><br><span class="line"> * @param multiplier</span><br><span class="line"> * @param hashs</span><br><span class="line"> */</span><br><span class="line">public static void calculateConflictRate(Integer multiplier, List&lt;Integer&gt; hashs) &#123;</span><br><span class="line">    Comparator&lt;Integer&gt; cp = (x, y) -&gt; x &gt; y ? 1 : (x &lt; y ? -1 : 0);</span><br><span class="line">    int maxHash = hashs.stream().max(cp).get();</span><br><span class="line">    int minHash = hashs.stream().min(cp).get();</span><br><span class="line"></span><br><span class="line">    // 计算冲突数及冲突率</span><br><span class="line">    int uniqueHashNum = (int) hashs.stream().distinct().count();</span><br><span class="line">    int conflictNum = hashs.size() - uniqueHashNum;</span><br><span class="line">    double conflictRate = (conflictNum * 1.0) / hashs.size();</span><br><span class="line"></span><br><span class="line">    System.out.println(String.format(&quot;multiplier=%4d, minHash=%11d, maxHash=%10d, conflictNum=%6d, conflictRate=%.4f%%&quot;,</span><br><span class="line">                multiplier, minHash, maxHash, conflictNum, conflictRate * 100));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果如下：<br><img src="https://img-blog.csdnimg.cn/20191211161427272.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzY2NDQxOA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>从上图可以看出，使用较小的质数做为乘子时，冲突率会很高。尤其是质数2，冲突率达到了 55.14%。同时我们注意观察质数2作为乘子时，哈希值的分布情况。可以看得出来，哈希值分布并不是很广，仅仅分布在了整个哈希空间的正半轴部分，即 0 ~ 231-1。而负半轴 -231 ~ -1，则无分布。</p><p>这也证明了我们上面断言，即质数2作为乘子时，对于短字符串，生成的哈希值分布性不佳。然后再来看看我们之前所说的 31、37、41 这三个不大不小的质数，表现都不错，冲突数都低于7个。而质数 101 和 199 表现的也很不错，冲突率很低，这也说明哈希值溢出并不一定会导致冲突率上升。但是这两个家伙一言不合就溢出，我们认为他们不是哈希算法的优选乘子。最后我们再来看看 32 和 36 这两个偶数的表现，结果并不好，尤其是 32，冲突率超过了了50%。尽管 36 表现的要好一点，不过和 31，37相比，冲突率还是比较高的。当然并非所有的偶数作为乘子时，冲突率都会比较高，大家有兴趣可以自己验证。</p><p><strong>哈希值分布可视化</strong></p><p>上一节分析了不同数字作为乘子时的冲突率情况，这一节来分析一下不同数字作为乘子时，哈希值的分布情况。在详细分析之前，我先说说哈希值可视化的过程。我原本是打算将所有的哈希值用一维散点图进行可视化，但是后来找了一圈，也没找到合适的画图工具。加之后来想了想，一维散点图可能不合适做哈希值可视化，因为这里有超过23万个哈希值。也就意味着会在图上显示超过23万个散点，如果不出意外的话，这23万个散点会聚集的很密，有可能会变成一个大黑块，就失去了可视化的意义了。</p><p>所以这里选择了另一种可视化效果更好的图表，也就是 excel 中的平滑曲线的二维散点图（下面简称散点曲线图）。当然这里同样没有把23万散点都显示在图表上，太多了。所以在实际绘图过程中，我将哈希空间等分成了64个子区间，并统计每个区间内的哈希值数量。最后将分区编号做为X轴，哈希值数量为Y轴，就绘制出了我想要的二维散点曲线图了。</p><p>这里举个例子说明一下吧，以第0分区为例。第0分区数值区间是[-2147483648, -2080374784)，我们统计落在该数值区间内哈希值的数量，得到 &lt;分区编号, 哈希值数量&gt; 数值对，这样就可以绘图了。分区代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 将整个哈希空间等分成64份，统计每个空间内的哈希值数量</span><br><span class="line"> * @param hashs</span><br><span class="line"> */</span><br><span class="line">public static Map&lt;Integer, Integer&gt; partition(List&lt;Integer&gt; hashs) &#123;</span><br><span class="line">    // step = 2^32 / 64 = 2^26</span><br><span class="line">    final int step = 67108864;</span><br><span class="line">    List&lt;Integer&gt; nums = new ArrayList&lt;&gt;();</span><br><span class="line">    Map&lt;Integer, Integer&gt; statistics = new LinkedHashMap&lt;&gt;();</span><br><span class="line">    int start = 0;</span><br><span class="line">    for (long i = Integer.MIN_VALUE; i &lt;= Integer.MAX_VALUE; i += step) &#123;</span><br><span class="line">        final long min = i;</span><br><span class="line">        final long max = min + step;</span><br><span class="line">        int num = (int) hashs.parallelStream()</span><br><span class="line">                .filter(x -&gt; x &gt;= min &amp;&amp; x &lt; max).count();</span><br><span class="line"></span><br><span class="line">        statistics.put(start++, num);</span><br><span class="line">        nums.add(num);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 为了防止计算出错，这里验证一下</span><br><span class="line">    int hashNum = nums.stream().reduce((x, y) -&gt; x + y).get();</span><br><span class="line">    assert hashNum == hashs.size();</span><br><span class="line"></span><br><span class="line">    return statistics;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>本文中的哈希值是用整形表示的，整形的数值区间是 [-2147483648, 2147483647]，区间大小为 2^32。所以这里可以将区间等分成64个子区间，每个自子区间大小为 2^26。详细的分区对照表如下：<br><img src="https://img-blog.csdnimg.cn/20191211161648353.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzY2NDQxOA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>接下来，让我们按照分区，对数字2、3、17、31、101的散点曲线图进行简单的分析。先从数字2开始，数字2对于的散点曲线图如下：<br><img src="https://img-blog.csdnimg.cn/20191211161923556.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzY2NDQxOA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>上面的图还是很一目了然的，乘子2算出的哈希值几乎全部落在第32分区，也就是 [0, 67108864)数值区间内，落在其他区间内的哈希值数量几乎可以忽略不计。这也就不难解释为什么数字2作为乘子时，算出哈希值的冲突率如此之高的原因了。所以这样的哈希算法要它有何用啊，拖出去斩了吧。接下来看看数字3作为乘子时的表现：</p><p><img src="https://img-blog.csdnimg.cn/20191211161934784.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzY2NDQxOA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>3作为乘子时，算出的哈希值分布情况和2很像，只不过稍微好了那么一点点。从图中可以看出绝大部分的哈希值最终都落在了第32分区里，哈希值的分布性很差。这个也没啥用，拖出去枪毙5分钟吧。在看看数字17的情况怎么样：<br><img src="https://img-blog.csdnimg.cn/2019121116194580.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzY2NDQxOA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>数字17作为乘子时的表现，明显比上面两个数字好点了。虽然哈希值在第32分区和第34分区有一定的聚集，但是相比较上面2和3，情况明显好好了很多。除此之外，17作为乘子算出的哈希值在其他区也均有分布，且较为均匀，还算是一个不错的乘子吧。<br><img src="https://img-blog.csdnimg.cn/20191211162026276.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzY2NDQxOA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>接下来来看看我们本文的主角31了，31作为乘子算出的哈希值在第33分区有一定的小聚集。不过相比于数字17，主角31的表现又好了一些。首先是哈希值的聚集程度没有17那么严重，其次哈希值在其他区分布的情况也要好于17。总之，选31，准没错啊。<br><img src="https://img-blog.csdnimg.cn/20191211162041824.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzY2NDQxOA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>最后再来看看大质数101的表现，不难看出，质数101作为乘子时，算出的哈希值分布情况要好于主角31，有点喧宾夺主的意思。不过不可否认的是，质数101的作为乘子时，哈希值的分布性确实更加均匀。所以如果不在意质数101容易导致数据信息丢失问题，或许其是一个更好的选择。</p><p><strong>写在最后</strong></p><p>经过上面的分析与实践，我想大家应该明白了 String hashCode 方法中选择使用数字31作为乘子的原因了。本文本质是一篇简单的科普文而已，并没有银弹。如果大家读完后觉得又涨知识了，那这篇文章的目的就达到了。最后，本篇文章的配图画的还是很辛苦的，所以如果大家觉得文章不错，不妨就给个赞吧，就当是对我的鼓励了。</p><p>另外，如果文章中有不妥或者错误的地方，也欢迎指出来。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;某天，我在写代码的时候，无意中点开了 String hashCode 方法。然后大致看了一下 hashCode 的实现，发现并不是很复杂。但是我从源码中发现了一个奇怪的数字，也就是本文的主角31。这个数字居然不是用常量声明的，所以没法从字面意思上推断这个数字的用途。后来带着疑问和好奇心，到网上去找资料查询一下。在看完资料后，默默的感叹了一句，原来是这样啊。那么到底是哪样呢？在接下来章节里，请大家带着好奇心和我揭开数字31的用途之谜。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="Java" scheme="ayjcsgm.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Spring面试常见问题</title>
    <link href="ayjcsgm.github.io/2019/12/11/Spring%E9%9D%A2%E8%AF%95%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/"/>
    <id>ayjcsgm.github.io/2019/12/11/Spring面试常见问题/</id>
    <published>2019-12-11T02:45:43.000Z</published>
    <updated>2019-12-14T11:34:14.226Z</updated>
    
    <content type="html"><![CDATA[<p><strong>1、Spring是什么?</strong></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Spring是一个轻量级的IoC和AOP容器框架。是为Java应用程序提供基础性服务的一套框架，目的是用于简化企业应用程序的开发，它使得开发者只需要关心业务需求。常见的配置方式有三种：基于XML的配置、基于注解的配置、基于Java的配置。</p><a id="more"></a> <p>主要由以下几个模块组成：</p><p style="text-indent:50px;">Spring Core：核心类库，提供IOC服务；</p><p style="text-indent:50px;">Spring Context：提供框架式的Bean访问方式，以及企业级功能（JNDI、定时任务等）；</p><p style="text-indent:50px;">Spring AOP：AOP服务；</p><p style="text-indent:50px;">Spring DAO：对JDBC的抽象，简化了数据访问异常的处理；</p><p style="text-indent:50px;">Spring ORM：对现有的ORM框架的支持；</p><p style="text-indent:50px;">Spring Web：提供了基本的面向Web的综合特性，例如多方文件上传；</p><p style="text-indent:50px;">Spring MVC：提供面向Web应用的Model-View-Controller实现。</p><p style="text-indent:50px;">&nbsp;</p><p><strong>2、Spring 的优点？</strong></p><p>（1）spring属于低侵入式设计，代码的污染极低；</p><p>（2）spring的DI机制将对象之间的依赖关系交由框架处理，减低组件的耦合性；</p><p>（3）Spring提供了AOP技术，支持将一些通用任务，如安全、事务、日志、权限等进行集中式管理，从而提供更好的复用。</p><p>（4）spring对于主流的应用框架提供了集成支持。</p><p>&nbsp;</p><p><strong>3、Spring的AOP理解：</strong></p><p style="text-indent:50px;">OOP面向对象，允许开发者定义纵向的关系，但并适用于定义横向的关系，导致了大量代码的重复，而不利于各个模块的重用。</p><p style="text-indent:50px;">AOP，一般称为面向切面，作为面向对象的一种补充，<span style="color:#f33b45;">用于将那些与业务无关，但却对多个对象产生影响的公共行为和逻辑，抽取并封装为一个可重用的模块，</span>这个模块被命名为“切面”（Aspect），减少系统中的重复代码，降低了模块间的耦合度，同时提高了系统的可维护性。可用于权限认证、日志、事务处理。</p><p style="text-indent:50px;">AOP实现的关键在于 代理模式，AOP代理主要分为静态代理和动态代理。静态代理的代表为AspectJ；动态代理则以Spring AOP为代表。</p><p>（1）AspectJ是静态代理的增强，所谓静态代理，就是AOP框架会在编译阶段生成AOP代理类，因此也称为编译时增强，他会在编译阶段将AspectJ(切面)织入到Java字节码中，运行的时候就是增强之后的AOP对象。</p><p>（2）Spring AOP使用的动态代理，所谓的动态代理就是说AOP框架不会去修改字节码，而是每次运行时在内存中临时为方法生成一个AOP对象，这个AOP对象包含了目标对象的全部方法，并且在特定的切点做了增强处理，并回调原对象的方法。</p><p><span style="color:#f33b45;">Spring AOP中的动态代理主要有两种方式，JDK动态代理和CGLIB动态代理：</span></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;①JDK动态代理只提供接口的代理，不支持类的代理。核心InvocationHandler接口和Proxy类，InvocationHandler&nbsp;通过invoke()方法反射来调用目标类中的代码，动态地将横切逻辑和业务编织在一起；接着，Proxy利用 InvocationHandler动态创建一个符合某一接口的的实例,&nbsp; 生成目标类的代理对象。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;②如果代理类没有实现 InvocationHandler 接口，那么Spring AOP会选择使用CGLIB来动态代理目标类。CGLIB（Code Generation Library），是一个代码生成的类库，可以在运行时动态的生成指定类的一个子类对象，并覆盖其中特定方法并添加增强代码，从而实现AOP。CGLIB是通过继承的方式做的动态代理，因此如果某个类被标记为final，那么它是无法使用CGLIB做动态代理的。</p><p>（3）静态代理与动态代理区别在于生成AOP代理对象的时机不同，相对来说AspectJ的静态代理方式具有更好的性能，但是AspectJ需要特定的编译器进行处理，而Spring AOP则无需特定的编译器处理。</p><blockquote><p>&nbsp;InvocationHandler 的 invoke(Object&nbsp;&nbsp;proxy,Method&nbsp;&nbsp;method,Object[] args)：proxy是最终生成的代理实例;&nbsp;&nbsp;method 是被代理目标实例的某个具体方法;&nbsp;&nbsp;args 是被代理目标实例某个方法的具体入参, 在方法反射调用时使用。</p></blockquote><p>&nbsp;</p><p><strong>4、Spring的IoC理解：</strong></p><p>（1）IOC就是控制反转，是指创建对象的控制权的转移，以前创建对象的主动权和时机是由自己把控的，而现在这种权力转移到Spring容器中，并由容器根据配置文件去创建实例和管理各个实例之间的依赖关系，对象与对象之间松散耦合，也利于功能的复用。DI依赖注入，和控制反转是同一个概念的不同角度的描述，即 应用程序在运行时依赖IoC容器来动态注入对象需要的外部资源。</p><p>（2）最直观的表达就是，IOC让对象的创建不用去new了，可以由spring自动生产，使用java的反射机制，根据配置文件在运行时动态的去创建对象以及管理对象，并调用对象的方法的。</p><p>（3）Spring的IOC有三种注入方式 ：构造器注入、setter方法注入、根据注解注入。</p><blockquote><p>IoC让相互协作的组件保持松散的耦合，而AOP编程允许你把遍布于应用各层的功能分离出来形成可重用的功能组件。</p></blockquote><p>&nbsp;</p><p><strong>5、BeanFactory和ApplicationContext有什么区别？</strong></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;BeanFactory和ApplicationContext是Spring的两大核心接口，都可以当做Spring的容器。其中ApplicationContext是BeanFactory的子接口。</p><p>（1）BeanFactory：是Spring里面最底层的接口，包含了各种Bean的定义，读取bean配置文档，管理bean的加载、实例化，控制bean的生命周期，维护bean之间的依赖关系。ApplicationContext接口作为BeanFactory的派生，除了提供BeanFactory所具有的功能外，还提供了更完整的框架功能：</p><p style="text-indent:50px;">①继承MessageSource，因此支持国际化。</p><p style="text-indent:50px;">②统一的资源文件访问方式。</p><p style="text-indent:50px;">③提供在监听器中注册bean的事件。</p><p style="text-indent:50px;">④同时加载多个配置文件。</p><p style="text-indent:50px;">⑤载入多个（有继承关系）上下文 ，使得每一个上下文都专注于一个特定的层次，比如应用的web层。</p><p>（2）<span style="color:#3399ea;">①BeanFactroy采用的是延迟加载形式来注入Bean的，即只有在使用到某个Bean时(调用getBean())，才对该Bean进行加载实例化。</span>这样，我们就不能发现一些存在的Spring的配置问题。如果Bean的某一个属性没有注入，BeanFacotry加载后，直至第一次使用调用getBean方法才会抛出异常。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:#3399ea;">②ApplicationContext，它是在容器启动时，一次性创建了所有的Bean。</span>这样，在容器启动时，我们就可以发现Spring中存在的配置错误，这样有利于检查所依赖属性是否注入。&nbsp;ApplicationContext启动后预载入所有的单实例Bean，通过预载入单实例bean ,确保当你需要的时候，你就不用等待，因为它们已经创建好了。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;③相对于基本的BeanFactory，ApplicationContext 唯一的不足是占用内存空间。当应用程序配置Bean较多时，程序启动较慢。</p><p>（3）BeanFactory通常以编程的方式被创建，ApplicationContext还能以声明的方式创建，如使用ContextLoader。</p><p>（4）BeanFactory和ApplicationContext都支持BeanPostProcessor、BeanFactoryPostProcessor的使用，但两者之间的区别是：BeanFactory需要手动注册，而ApplicationContext则是自动注册。</p><p>&nbsp;</p><p><strong>6、请解释Spring Bean的生命周期？</strong></p><p>&nbsp;首先说一下Servlet的生命周期：实例化，初始init，接收请求service，销毁destroy；</p><p>&nbsp;Spring上下文中的Bean生命周期也类似，如下：</p><p><span style="color:#3399ea;">（1）实例化Bean：</span></p><p>对于BeanFactory容器，当客户向容器请求一个尚未初始化的bean时，或初始化bean的时候需要注入另一个尚未初始化的依赖时，容器就会调用createBean进行实例化。对于ApplicationContext容器，当容器启动结束后，通过获取BeanDefinition对象中的信息，实例化所有的bean。</p><p><span style="color:#3399ea;">（2）设置对象属性（依赖注入）：</span></p><p>实例化后的对象被封装在BeanWrapper对象中，紧接着，Spring根据BeanDefinition中的信息 以及 通过BeanWrapper提供的设置属性的接口完成依赖注入。</p><p><span style="color:#3399ea;">（3）处理Aware接口：</span></p><p>接着，Spring会检测该对象是否实现了xxxAware接口，并将相关的xxxAware实例注入给Bean：</p><p style="text-indent:50px;">①如果这个Bean已经实现了BeanNameAware接口，会调用它实现的setBeanName(String beanId)方法，此处传递的就是Spring配置文件中Bean的id值；</p><p style="text-indent:50px;">②如果这个Bean已经实现了BeanFactoryAware接口，会调用它实现的setBeanFactory()方法，传递的是Spring工厂自身。</p><p style="text-indent:50px;">③如果这个Bean已经实现了ApplicationContextAware接口，会调用setApplicationContext(ApplicationContext)方法，传入Spring上下文；</p><p><span style="color:#3399ea;">（4）BeanPostProcessor：</span></p><p>如果想对Bean进行一些自定义的处理，那么可以让Bean实现了BeanPostProcessor接口，那将会调用postProcessBeforeInitialization(Object obj, String s)方法。</p><p><span style="color:#3399ea;">（5）InitializingBean&nbsp;与&nbsp;init-method：</span></p><p>如果Bean在Spring配置文件中配置了 init-method 属性，则会自动调用其配置的初始化方法。</p><p>（6）如果这个Bean实现了BeanPostProcessor接口，将会调用postProcessAfterInitialization(Object obj, String s)方法；由于这个方法是在Bean初始化结束时调用的，所以可以被应用于内存或缓存技术；</p><blockquote><p>以上几个步骤完成后，Bean就已经被正确创建了，之后就可以使用这个Bean了。</p></blockquote><p><span style="color:#3399ea;">（7）DisposableBean：</span></p><p>当Bean不再需要时，会经过清理阶段，如果Bean实现了DisposableBean这个接口，会调用其实现的destroy()方法；</p><p>（8）<span style="color:#3399ea;">destroy-method：</span></p><p>最后，如果这个Bean的Spring配置中配置了destroy-method属性，会自动调用其配置的销毁方法。</p><p>&nbsp;</p><p><strong>7、&nbsp;解释Spring支持的几种bean的作用域。</strong></p><p>Spring容器中的bean可以分为5个范围：</p><p>（1）singleton：默认，每个容器中只有一个bean的实例，单例的模式由BeanFactory自身来维护。</p><p>（2）prototype：为每一个bean请求提供一个实例。</p><p>（3）request：为每一个网络请求创建一个实例，在请求完成以后，bean会失效并被垃圾回收器回收。</p><p>（4）session：与request范围类似，确保每个session中有一个bean的实例，在session过期后，bean会随之失效。</p><p>（5）global-session：全局作用域，global-session和Portlet应用相关。当你的应用部署在Portlet容器中工作时，它包含很多portlet。如果你想要声明让所有的portlet共用全局的存储变量的话，那么这全局变量需要存储在global-session中。全局作用域与Servlet中的session作用域效果相同。</p><p>&nbsp;</p><p><strong>8、Spring框架中的单例Beans是线程安全的么？</strong></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Spring框架并没有对单例bean进行任何多线程的封装处理。关于单例bean的线程安全和并发问题需要开发者自行去搞定。但实际上，大部分的Spring bean并没有可变的状态(比如Serview类和DAO类)，所以在某种程度上说Spring的单例bean是线程安全的。如果你的bean有多种状态的话（比如 View Model 对象），就需要自行保证线程安全。最浅显的解决办法就是将多态bean的作用域由“singleton”变更为“prototype”。</p><p><strong>9、Spring如何处理线程并发问题？</strong></p><p style="text-indent:50px;">在一般情况下，只有无状态的Bean才可以在多线程环境下共享，在Spring中，绝大部分Bean都可以声明为singleton作用域，因为Spring对一些Bean中非线程安全状态<span style="color:#3399ea;">采用ThreadLocal进行处理，解决线程安全问题。</span></p><p style="text-indent:50px;">ThreadLocal和线程同步机制都是为了解决多线程中相同变量的访问冲突问题。同步机制采用了“时间换空间”的方式，仅提供一份变量，不同的线程在访问前需要获取锁，没获得锁的线程则需要排队。而ThreadLocal采用了“空间换时间”的方式。</p><p style="text-indent:50px;">ThreadLocal会为每一个线程提供一个独立的变量副本，从而隔离了多个线程对数据的访问冲突。因为每一个线程都拥有自己的变量副本，从而也就没有必要对该变量进行同步了。ThreadLocal提供了线程安全的共享对象，在编写多线程代码时，可以把不安全的变量封装进ThreadLocal。</p><p>&nbsp;</p><p><strong>10-1、Spring基于xml注入bean的几种方式：</strong></p><p>（1）Set方法注入；</p><p>（2）构造器注入：①通过index设置参数的位置；②通过type设置参数类型；</p><p>（3）静态工厂注入；</p><p>（4）实例工厂；</p><p>详细内容可以阅读：<a href="https://www.iteye.com/blog/blessht-1162131" rel="noopener" target="_blank">https://www.iteye.com/blog/blessht-1162131</a></p><p><strong>10-2、Spring的自动装配：</strong></p><p>在spring中，对象无需自己查找或创建与其关联的其他对象，由容器负责把需要相互协作的对象引用赋予各个对象，<span style="color:#3399ea;">使用autowire来配置自动装载模式。</span></p><p>在Spring框架xml配置中共有5种自动装配：</p><p>（1）no：默认的方式是不进行自动装配的，通过手工设置ref属性来进行装配bean。</p><p>（2）byName：通过bean的名称进行自动装配，如果一个bean的 property 与另一bean 的name 相同，就进行自动装配。&nbsp;</p><p>（3）byType：通过参数的数据类型进行自动装配。</p><p>（4）constructor：利用构造函数进行装配，并且构造函数的参数通过byType进行装配。</p><p>（5）autodetect：自动探测，如果有构造方法，通过 construct的方式自动装配，否则使用 byType的方式自动装配。</p><p>基于注解的方式：</p><p style="text-indent:50px;">使用@Autowired注解来自动装配指定的bean。在使用@Autowired注解之前需要在Spring配置文件进行配置，&lt;context:annotation-config /&gt;。在启动spring IoC时，容器自动装载了一个AutowiredAnnotationBeanPostProcessor后置处理器，当容器扫描到@Autowied、@Resource或@Inject时，就会在IoC容器自动查找需要的bean，并装配给该对象的属性。在使用@Autowired时，首先在容器中查询对应类型的bean：</p><p style="text-indent:50px;">如果查询结果刚好为一个，就将该bean装配给@Autowired指定的数据；</p><p style="text-indent:50px;">如果查询的结果不止一个，那么@Autowired会根据名称来查找；</p><p style="text-indent:50px;">如果上述查找的结果为空，那么会抛出异常。解决方法时，使用required=false。</p><blockquote><p>@Autowired可用于：构造函数、成员变量、Setter方法</p><p>注：@Autowired和@Resource之间的区别</p><p>(1) @Autowired默认是按照类型装配注入的，默认情况下它要求依赖对象必须存在（可以设置它required属性为false）。</p><p>(2) @Resource默认是按照名称来装配注入的，只有当找不到与名称匹配的bean才会按照类型来装配注入。</p></blockquote><p>&nbsp;</p><p><strong>11、Spring 框架中都用到了哪些设计模式？</strong></p><p>（1）工厂模式：BeanFactory就是简单工厂模式的体现，用来创建对象的实例；</p><p>（2）单例模式：Bean默认为单例模式。</p><p>（3）代理模式：Spring的AOP功能用到了JDK的动态代理和CGLIB字节码生成技术；</p><p>（4）模板方法：用来解决代码重复的问题。比如.&nbsp;RestTemplate,&nbsp;JmsTemplate,&nbsp;JpaTemplate。</p><p>（5）观察者模式：定义对象键一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都会得到通知被制动更新，如Spring中listener的实现--ApplicationListener。</p><p>&nbsp;</p><p><strong>12、Spring事务的实现方式和实现原理：</strong></p><p>Spring事务的本质其实就是数据库对事务的支持，没有数据库的事务支持，spring是无法提供事务功能的。真正的数据库层的事务提交和回滚是通过binlog或者redo log实现的。</p><p><strong>（1）Spring事务的种类：</strong></p><p>spring支持编程式事务管理和声明式事务管理两种方式：</p><p style="text-indent:50px;">①编程式事务管理使用TransactionTemplate。</p><p style="text-indent:50px;">②声明式事务管理建立在AOP之上的。其本质是通过AOP功能，对方法前后进行拦截，将事务处理的功能编织到拦截的方法中，也就是在目标方法开始之前加入一个事务，在执行完目标方法之后根据执行情况提交或者回滚事务。</p><blockquote><p style="text-indent:50px;">声明式事务最大的优点就是不需要在业务逻辑代码中掺杂事务管理的代码，只需在配置文件中做相关的事务规则声明或通过@Transactional注解的方式，便可以将事务规则应用到业务逻辑中。</p><p style="text-indent:50px;">声明式事务管理要优于编程式事务管理，这正是spring倡导的非侵入式的开发方式，使业务代码不受污染，只要加上注解就可以获得完全的事务支持。唯一不足地方是，最细粒度只能作用到方法级别，无法做到像编程式事务那样可以作用到代码块级别。</p></blockquote><p><strong>（2）spring的事务传播行为：</strong></p><p>spring事务的传播行为说的是，当多个事务同时存在的时候，spring如何处理这些事务的行为。</p><blockquote><p>① PROPAGATION_REQUIRED：如果当前没有事务，就创建一个新事务，如果当前存在事务，就加入该事务，该设置是最常用的设置。</p><p>② PROPAGATION_SUPPORTS：支持当前事务，如果当前存在事务，就加入该事务，如果当前不存在事务，就以非事务执行。‘</p><p>③ PROPAGATION_MANDATORY：支持当前事务，如果当前存在事务，就加入该事务，如果当前不存在事务，就抛出异常。</p><p>④ PROPAGATION_REQUIRES_NEW：创建新事务，无论当前存不存在事务，都创建新事务。</p><p>⑤ PROPAGATION_NOT_SUPPORTED：以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。</p><p>⑥ PROPAGATION_NEVER：以非事务方式执行，如果当前存在事务，则抛出异常。</p><p>⑦ PROPAGATION_NESTED：如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则按REQUIRED属性执行。</p></blockquote><p><strong>（3）Spring中的隔离级别：</strong></p><blockquote><p>①&nbsp;ISOLATION_DEFAULT：这是个&nbsp;PlatfromTransactionManager&nbsp;默认的隔离级别，使用数据库默认的事务隔离级别。</p><p>②&nbsp;ISOLATION_READ_UNCOMMITTED：读未提交，允许另外一个事务可以看到这个事务未提交的数据。</p><p>③&nbsp;ISOLATION_READ_COMMITTED：读已提交，保证一个事务修改的数据提交后才能被另一事务读取，而且能看到该事务对已有记录的更新。</p><p>④&nbsp;ISOLATION_REPEATABLE_READ：可重复读，保证一个事务修改的数据提交后才能被另一事务读取，但是不能看到该事务对已有记录的更新。</p><p>⑤&nbsp;ISOLATION_SERIALIZABLE：一个事务在执行的过程中完全看不到其他事务对数据库所做的更新。</p></blockquote><p>&nbsp;</p><p><strong>13、Spring框架中有哪些不同类型的事件？</strong></p><p>Spring 提供了以下5种标准的事件：</p><p>（1）上下文更新事件（ContextRefreshedEvent）：在调用ConfigurableApplicationContext 接口中的refresh()方法时被触发。</p><p>（2）上下文开始事件（ContextStartedEvent）：当容器调用ConfigurableApplicationContext的Start()方法开始/重新开始容器时触发该事件。</p><p>（3）上下文停止事件（ContextStoppedEvent）：当容器调用ConfigurableApplicationContext的Stop()方法停止容器时触发该事件。</p><p>（4）上下文关闭事件（ContextClosedEvent）：当ApplicationContext被关闭时触发该事件。容器被关闭时，其管理的所有单例Bean都被销毁。</p><p>（5）请求处理事件（RequestHandledEvent）：在Web应用中，当一个http请求（request）结束触发该事件。</p><p>如果一个bean实现了ApplicationListener接口，当一个ApplicationEvent 被发布以后，bean会自动被通知。</p><p>&nbsp;</p><p><strong>14、解释一下Spring AOP里面的几个名词：</strong></p><p>（1）切面（Aspect）：被抽取的公共模块，可能会横切多个对象。&nbsp;在Spring AOP中，切面可以使用通用类（基于模式的风格）&nbsp;或者在普通类中以&nbsp;@AspectJ&nbsp;注解来实现。</p><p>（2）连接点（Join point）：指方法，在Spring AOP中，一个连接点&nbsp;总是&nbsp;代表一个方法的执行。&nbsp;</p><p>（3）通知（Advice）：在切面的某个特定的连接点（Join point）上执行的动作。通知有各种类型，其中包括“around”、“before”和“after”等通知。许多AOP框架，包括Spring，都是以拦截器做通知模型，&nbsp;并维护一个以连接点为中心的拦截器链。</p><p>（4）切入点（Pointcut）：切入点是指 我们要对哪些Join point进行拦截的定义。通过切入点表达式，指定拦截的方法，比如指定拦截add*、search*。</p><p>（5）引入（Introduction）：（也被称为内部类型声明（inter-type declaration））。声明额外的方法或者某个类型的字段。Spring允许引入新的接口（以及一个对应的实现）到任何被代理的对象。例如，你可以使用一个引入来使bean实现&nbsp;IsModified&nbsp;接口，以便简化缓存机制。</p><p>（6）目标对象（Target Object）：&nbsp;被一个或者多个切面（aspect）所通知（advise）的对象。也有人把它叫做&nbsp;被通知（adviced）&nbsp;对象。&nbsp;既然Spring AOP是通过运行时代理实现的，这个对象永远是一个&nbsp;被代理（proxied）&nbsp;对象。</p><p>（7）织入（Weaving）：指把增强应用到目标对象来创建新的代理对象的过程。Spring是在运行时完成织入。</p><p>切入点（pointcut）和连接点（join point）匹配的概念是AOP的关键，这使得AOP不同于其它仅仅提供拦截功能的旧技术。&nbsp;切入点使得定位通知（advice）可独立于OO层次。&nbsp;例如，一个提供声明式事务管理的around通知可以被应用到一组横跨多个对象中的方法上（例如服务层的所有业务操作）。</p><p><img alt class="has" src="https://img-blog.csdn.net/20180708154818891"></p><p><strong>15、Spring通知有哪些类型？</strong></p><p><a href="https://blog.csdn.net/qq_32331073/article/details/80596084" rel="noopener" target="_blank">https://blog.csdn.net/qq_32331073/article/details/80596084</a></p><p>（1）前置通知（Before advice）：在某连接点（join point）之前执行的通知，但这个通知不能阻止连接点前的执行（除非它抛出一个异常）。</p><p>（2）返回后通知（After returning advice）：在某连接点（join point）正常完成后执行的通知：例如，一个方法没有抛出任何异常，正常返回。&nbsp;</p><p>（3）抛出异常后通知（After throwing advice）：在方法抛出异常退出时执行的通知。&nbsp;</p><p>（4）后通知（After (finally) advice）：当某连接点退出的时候执行的通知（不论是正常返回还是异常退出）。&nbsp;</p><p>（5）环绕通知（Around Advice）：包围一个连接点（join point）的通知，如方法调用。这是最强大的一种通知类型。&nbsp;环绕通知可以在方法调用前后完成自定义的行为。<span style="color:#3399ea;">它也会选择是否继续执行连接点或直接返回它们自己的返回值或抛出异常来结束执行</span>。&nbsp;环绕通知是最常用的一种通知类型。大部分基于拦截的AOP框架，例如Nanning和JBoss4，都只提供环绕通知。&nbsp;</p><blockquote><p>同一个aspect，不同advice的执行顺序：</p><p>①没有异常情况下的执行顺序：</p><p>around before advice<br>before advice<br>target method 执行<br>around after advice<br>after advice<br>afterReturning</p><p>②有异常情况下的执行顺序：</p><p>around before advice<br>before advice<br>target method 执行<br>around after advice<br>after advice<br>afterThrowing:异常发生<br>java.lang.RuntimeException: 异常发生</p></blockquote><p>&nbsp;</p><hr>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;1、Spring是什么?&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Spring是一个轻量级的IoC和AOP容器框架。是为Java应用程序提供基础性服务的一套框架，目的是用于简化企业应用程序的开发，它使得开发者只需要关心业务需求。常见的配置方式有三种：基于XML的配置、基于注解的配置、基于Java的配置。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="Spring" scheme="ayjcsgm.github.io/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>Java学习路线</title>
    <link href="ayjcsgm.github.io/2019/12/11/Java%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"/>
    <id>ayjcsgm.github.io/2019/12/11/Java学习路线/</id>
    <published>2019-12-11T02:41:58.000Z</published>
    <updated>2019-12-14T11:31:49.216Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>推荐几本Java的书来学习<br>1.《Java编程思想》</p><p>2.《大话设计模式》</p><p>3.《effective java》</p><p>4.《深入理解Java虚拟机》</p><p>5.《Java并发编程实战》</p><p>6.《数据结构与算法》</p></blockquote><a id="more"></a> <pre><code> JVM1. 内存模型 内存分为几部分？ 堆溢出、栈溢出原因及实例？线上如何排查？ 1、 类加载机制 2、垃圾回收 Java基础什么是接口？什么是抽象类？区别是什么？什么是序列化？网络通信过程及实践什么是线程？java线程池运行过程及实践（Executors）    java反射机制实践设计模式    单例模式、原型模式、动态代理模式Spring     什么是IOC 什么是AOP 事务管理：模板事务跟标注事务的区别及运理原理，什么是事务的传播机制数据库    锁机制：锁的作用是什么，什么是乐观锁，什么是悲观锁，怎么实现 ？索引：熟悉联合索引及sql执行计划</code></pre><pre class="prettyprint" name="code"><code class="hljs markdown has-numbering" onclick="mdcp.copyCode(event)" style="position: unset;"><span class="hljs-bullet">1. </span>java内存模型学习内容：学习java内存模型实验方法：写一段代码触发内存溢出，分别触发栈内存和堆内存溢出，写一段代码导致持久代溢出。使用工具查看内存占用情况，学会如何分析内存溢出。<span class="hljs-bullet">2. </span>多线程学习内容：多线程的NIO实现，IO实现（两种实现，阻塞，非阻塞）试验方法：写一段代码实现多人聊天室，包括双人聊天和多人聊天。<span class="hljs-bullet">3. </span>动态代理（工厂模式）（1）学习内容：JDK动态代理实现，试验方法：一个方法的前置拦截，后置拦截，前置打印获取类名，方法名字，调用参数打印。后置打印返回结果（返回的结果是一个复杂的类）。（2）学习内容：spring框架试验方法：对某一包下，所有类的方法做切面，打印日志。<span class="hljs-bullet">4. </span>反射机制学习内容：java的反射机制试验方法：写一段程序，调用一个Bean下实现了标注（“autocall”）的方法<span class="hljs-bullet">5. </span>配置数据源学习内容：配置数据源实验方法：自己建一张表，引入数据库连接池，自动插入20万条数据，创建联合索引，验证走索引和不走索引的耗时，查看sql是否走索引，学会查看查询，计划实验，用标注式事务，编程式事务（查看编程式事务源码实现）；用乐观锁和悲观锁实现数据更新。<p><img src="https://img-blog.csdn.net/20160620115227065" alt="这里写图片描述" title></p><p><img src="https://img-blog.csdn.net/20160620115325816" alt="这里写图片描述" title></p><p><img src="https://img-blog.csdn.net/20160621200523990" alt="这里写图片描述" title></p><blockquote>  <p>学习需要知道： <br>  1、是什么 <br>  2、解决了什么问题 <br>  3、怎么实现的<br>  </p></blockquote>                                    </code></pre>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;推荐几本Java的书来学习&lt;br&gt;1.《Java编程思想》&lt;/p&gt;
&lt;p&gt;2.《大话设计模式》&lt;/p&gt;
&lt;p&gt;3.《effective java》&lt;/p&gt;
&lt;p&gt;4.《深入理解Java虚拟机》&lt;/p&gt;
&lt;p&gt;5.《Java并发编程实战》&lt;/p&gt;
&lt;p&gt;6.《数据结构与算法》&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
    
      <category term="Java" scheme="ayjcsgm.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java集合框架</title>
    <link href="ayjcsgm.github.io/2019/12/11/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/"/>
    <id>ayjcsgm.github.io/2019/12/11/Java集合框架/</id>
    <published>2019-12-11T02:41:43.000Z</published>
    <updated>2019-12-14T11:31:40.445Z</updated>
    
    <content type="html"><![CDATA[<h1>Java 集合框架</h1><p><strong>思维导图</strong>：</p><a id="more"></a> <p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2Fzc2V0cy5wcm9jZXNzb24uY29tL2NoYXJ0X2ltYWdlLzVkY2E1MTZjZTRiMGE2MDIxNzMzZjBhNC5wbmc?x-oss-process=image/format,png" alt="在这里插入图片描述"></p><p>集合类存放于Java.util包中，主要有3种：set(集）、list(列表包含Queue）和map(映射)。 </p><ol><li>Collection：Collection是集合List、Set、Queue的最基本的接口。 </li><li>Iterator：迭代器，可以通过迭代器遍历集合中的数据 </li><li>Map：是映射表的基础接口 </li></ol><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly93d3cucnVub29iLmNvbS93cC1jb250ZW50L3VwbG9hZHMvMjAxNC8wMS8yMjQzNjkwLTljZDljODk2ZTBkNTEyZWQuZ2lm" alt="image"></p><p>从上面的集合框架图可以看到，Java 集合框架主要包括两种类型的容器，一种是集合（Collection），存储一个元素集合，另一种是图（Map），存储键/值对映射。Collection 接口又有 3 种子类型，List、Set 和 Queue，再下面是一些抽象类，最后是具体实现类，常用的有 ArrayList、LinkedList、HashSet、LinkedHashSet、HashMap、LinkedHashMap 等等。</p><p>集合框架是一个用来代表和操纵集合的统一架构。所有的集合框架都包含如下内容：</p><ul><li><strong></strong><p><strong>接口：</strong>是代表集合的抽象数据类型。例如 Collection、List、Set、Map 等。之所以定义多个接口，是为了以不同的方式操作集合对象</p></li>    <li>        <p><strong>实现（类）：</strong>是集合接口的具体实现。从本质上讲，它们是可重复使用的数据结构，例如：ArrayList、LinkedList、HashSet、HashMap。</p></li>    <li>        <p><strong>算法：</strong>是实现集合接口的对象里的方法执行的一些有用的计算，例如：搜索和排序。这些算法被称为多态，那是因为相同的方法可以在相似的接口上有着不同的实现。</p></li></ul><p>除了集合，该框架也定义了几个 Map 接口和类。Map 里存储的是键/值对。尽管 Map 不是集合，但是它们完全整合在集合中。</p><h3>集合框架体系如图所示</h3><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly93d3cucnVub29iLmNvbS93cC1jb250ZW50L3VwbG9hZHMvMjAxNC8wMS9qYXZhLWNvbGwucG5n?x-oss-process=image/format,png" alt="image"></p><p>Java 集合框架提供了一套性能优良，使用方便的接口和类，java集合框架位于java.util包中， 所以当使用集合框架的时候需要进行导包。</p><p>Collections是针对集合类的一个帮助类，它提供了一系列静态方法实现了对各种集合的排序，搜索和线程安全等操作。</p><hr><h2 id="List"><a href="#List" class="headerlink" title="List"></a>List</h2><h3 id="ArrayList（数组）"><a href="#ArrayList（数组）" class="headerlink" title="ArrayList（数组）"></a>ArrayList（数组）</h3><p>ArrayList 是最常用的 List 实现类，内部是通过数组实现的，它允许对元素进行快速随机访问。数 组的缺点是每个元素之间不能有间隔，当数组大小不满足时需要增加存储能力，就要将已经有数 组的数据复制到新的存储空间中。当从 ArrayList 的中间位置插入或者删除元素时，需要对数组进 行复制、移动、代价比较高。因此，它适合随机查找和遍历，不适合插入和删除。 详细讲解可以查看我写的《<a href="https://blog.csdn.net/weixin_43664418/article/details/103464783" target="_blank" rel="noopener">学习ArrayList看这篇就够了（源码分析）</a>》。</p><h3 id="Vector（数组实现、线程同步）"><a href="#Vector（数组实现、线程同步）" class="headerlink" title="Vector（数组实现、线程同步）"></a>Vector（数组实现、线程同步）</h3><p>Vector与ArrayList一样，也是通过数组实现的，不同的是它支持线程的同步，即某一时刻只有一 个线程能够写 Vector，避免多线程同时写而引起的不一致性，但实现同步需要很高的花费，因此，访问它比访问ArrayList慢。</p><h3 id="LinkedList（链表）"><a href="#LinkedList（链表）" class="headerlink" title="LinkedList（链表）"></a>LinkedList（链表）</h3><p>LinkedList是用链表结构存储数据的，很适合数据的动态插入和删除，随机访问和遍历速度比较 慢。另外，他还提供了List接口中没有定义的方法，专门用于操作表头和表尾元素，可以当作堆 栈、队列和双向队列使用。 详细讲解可以查看我写的《<a href="https://blog.csdn.net/weixin_43664418/article/details/101934256" target="_blank" rel="noopener">学习LinkedList看这篇就够了（源码分析）</a>》。</p> <hr><h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><p>Set注重独一无二的性质,该体系集合用于存储无序(存入和取出的顺序不一定相同)元素，值不能重 复。对象的相等性本质是对象hashCode值（java是依据对象的内存地址计算出的此序号）判断 的，如果想要让两个不同的对象视为相等的，就必须覆盖Object的hashCode方法和equals方 法。 </p><h3 id="HashSet（Hash-表）"><a href="#HashSet（Hash-表）" class="headerlink" title="HashSet（Hash 表）"></a>HashSet（Hash 表）</h3><p>哈希表边存放的是哈希值。HashSet存储元素的顺序并不是按照存入时的顺序（和List显然不 同） 而是按照哈希值来存的所以取数据也是按照哈希值取得。元素的哈希值是通过元素的 hashcode方法来获取的, HashSet首先判断两个元素的哈希值，如果哈希值一样，接着会比较 equals方法 如果 equls结果为true ，HashSet就视为同一个元素。如果equals 为false就不是 同一个元素。<br>哈希值相同equals为false的元素是怎么存储呢,就是在同样的哈希值下顺延（可以认为哈希值相 同的元素放在一个哈希桶中）。也就是哈希一样的存一列，表示hashCode值不相同的情 况；存一竖表示hashCode值相同，但equals不相同的情况。 </p><p>HashSet通过hashCode值来确定元素在内存中的位置。一个hashCode位置上可以存放多个元素。 更多详细介绍可以查看我写的《<a href="https://blog.csdn.net/weixin_43664418/article/details/103477399" target="_blank" rel="noopener">简述HashSet的元素唯一机制</a>》。</p><h3 id="TreeSet（二叉树）"><a href="#TreeSet（二叉树）" class="headerlink" title="TreeSet（二叉树）"></a>TreeSet（二叉树）</h3><ol><li>TreeSet()是使用二叉树的原理对新add()的对象按照指定的顺序排序（升序、降序），每增 加一个对象都会进行排序，将对象插入的二叉树指定的位置。 </li><li>Integer和String对象都可以进行默认的TreeSet排序，而自定义类的对象是不可以的，自 己定义的类必须实现Comparable接口，并且覆写相应的compareTo()函数，才可以正常使 用。 </li><li>在覆写compare()函数时，要返回相应的值才能使TreeSet按照一定的规则来排序 </li><li>比较此对象与指定对象的顺序。如果该对象小于、等于或大于指定对象，则分别返回负整 数、零或正整数。</li></ol><p>更多详细介绍可以查看我写的《<a href="https://blog.csdn.net/weixin_43664418/article/details/103487109" target="_blank" rel="noopener">简述TreeSet排序机制</a>》。</p><h3 id="LinkHashSet（HashSet-LinkedHashMap）"><a href="#LinkHashSet（HashSet-LinkedHashMap）" class="headerlink" title="LinkHashSet（HashSet+LinkedHashMap）"></a>LinkHashSet（HashSet+LinkedHashMap）</h3><p>  对于 LinkedHashSet 而言，它继承与 HashSet、又基于 LinkedHashMap 来实现的。 LinkedHashSet 底层使用 LinkedHashMap 来保存所有元素，它继承与 HashSet，其所有的方法 操作上又与HashSet相同，因此LinkedHashSet 的实现上非常简单，只提供了四个构造方法，并 通过传递一个标识参数，调用父类的构造器，底层构造一个 LinkedHashMap 来实现，在相关操 作上与父类HashSet的操作相同，直接调用父类HashSet的方法即可。 </p><hr><h2 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h2><p>Queue是Java集合框架中的一员，继承于Collection接口。<br>与List、Set相同的是，Queue也实现了一种数据结构，这就是队列。</p><p>队列是计算机中的一种数据结构，保存在其中的数据具有“先进先出（FIFO,First In First Out）”的特性。<br>在数据结构中，队列不支持从队伍的中间插入和离开，只能从头尾进行。</p><p>详细讲解可以查看我写的《<a href="https://blog.csdn.net/weixin_43664418/article/details/103465317" target="_blank" rel="noopener">学习Queue看这篇就够了（源码分析）</a>》。</p><hr><h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><h3 id="HashMap（数组-链表-红黑树）"><a href="#HashMap（数组-链表-红黑树）" class="headerlink" title="HashMap（数组+链表+红黑树）"></a>HashMap（数组+链表+红黑树）</h3><p>HashMap根据键的hashCode值存储数据，大多数情况下可以直接定位到它的值，因而具有很快 的访问速度，但遍历顺序却是不确定的。 HashMap最多只允许一条记录的键为null，允许多条记 录的值为 null。HashMap 非线程安全，即任一时刻可以有多个线程同时写 HashMap，可能会导 致数据的不一致。如果需要满足线程安全，可以用 Collections 的 synchronizedMap 方法使 HashMap 具有线程安全的能力，或者使用 ConcurrentHashMap。</p><h5 id="JAVA7-实现"><a href="#JAVA7-实现" class="headerlink" title="JAVA7 实现"></a>JAVA7 实现</h5><p>HashMap 里面是一个数组，然后数组中每个元素是一个单向链表。每个实体是嵌套类 Entry 的实例，Entry 包含四个属性：key, value, hash 值和用于单向链表的 next。 </p><ol><li>capacity：当前数组容量，始终保持 2^n，可以扩容，扩容后数组大小为当前的 2 倍。 2. loadFactor：负载因子，默认为 0.75。 </li></ol><ol start="2"><li>threshold：扩容的阈值，等于 capacity * loadFactor </li></ol><p>可以看看这篇博客《<a href="https://blog.csdn.net/weixin_43664418/article/details/102164483" target="_blank" rel="noopener">重新认识HashMap（JDK1.7与1.8相比较）</a>》介绍7与8的不同。</p><h5 id="JAVA8-实现"><a href="#JAVA8-实现" class="headerlink" title="JAVA8 实现"></a>JAVA8 实现</h5><p>Java8 对 HashMap 进行了一些修改，最大的不同就是利用了红黑树，所以其由 数组+链表+红黑 树 组成。<br>根据 Java7 HashMap 的介绍，我们知道，查找的时候，根据 hash 值我们能够快速定位到数组的 具体下标，但是之后的话，需要顺着链表一个个比较下去才能找到我们需要的，时间复杂度取决 于链表的长度，为 O(n)。为了降低这部分的开销，在 Java8 中，当链表中的元素超过了 8 个以后， 会将链表转换为红黑树，在这些位置进行查找的时候可以降低时间复杂度为 O(logN)。 可以查看我写的这篇博客《<a href="https://blog.csdn.net/weixin_43664418/article/details/101999910" target="_blank" rel="noopener">HashMap源码分析（JDK1.8）</a>》。</p><h3 id="HashTable（线程安全）"><a href="#HashTable（线程安全）" class="headerlink" title="HashTable（线程安全）"></a>HashTable（线程安全）</h3><p>Hashtable 是遗留类，很多映射的常用功能与 HashMap 类似，不同的是它承自 Dictionary 类， 并且是线程安全的，任一时间只有一个线程能写 Hashtable，并发性不如 ConcurrentHashMap， 因为 ConcurrentHashMap 引入了分段锁。Hashtable 不建议在新代码中使用，不需要线程安全 的场合可以用HashMap替换，需要线程安全的场合可以用ConcurrentHashMap替换。 </p><h3 id="TreeMap（可排序）"><a href="#TreeMap（可排序）" class="headerlink" title="TreeMap（可排序）"></a>TreeMap（可排序）</h3><p>TreeMap 实现 SortedMap 接口，能够把它保存的记录根据键排序，默认是按键值的升序排序， 也可以指定排序的比较器，当用Iterator遍历TreeMap时，得到的记录是排过序的。<br>如果使用排序的映射，建议使用TreeMap。<br>在使用 TreeMap 时，key 必须实现 Comparable 接口或者在构造 TreeMap 传入自定义的 Comparator，否则会在运行时抛出java.lang.ClassCastException类型的异常。 详情可以查看我写的《<a href="https://blog.csdn.net/weixin_43664418/article/details/103488053" target="_blank" rel="noopener">TreeMap</a>》。</p><h3 id="LinkHashMap（记录插入顺序）"><a href="#LinkHashMap（记录插入顺序）" class="headerlink" title="LinkHashMap（记录插入顺序）"></a>LinkHashMap（记录插入顺序）</h3><p>LinkedHashMap 是 HashMap 的一个子类，保存了记录的插入顺序，在用 Iterator 遍历 LinkedHashMap时，先得到的记录肯定是先插入的，也可以在构造时带参数，按照访问次序排序。 </p><hr><h2 id="Iterator"><a href="#Iterator" class="headerlink" title="Iterator"></a>Iterator</h2><p>Iterator是一个接口，它是集合的迭代器。集合可以通过Iterator去遍历集合中的元素。Iterator只能单向移动。hasNext()：如果迭代器中还有元素，则返回true。next()：返回迭代器中的下一个元素。Iterator.remove()是唯一安全的方式来在迭代过程中修改集合；如果在迭代过程中以任何其它的方式修改了基本集合将会产生未知的行为。而且每调用一次next()方法，remove()方法只能被调用一次。</p><h3 id="ListIterator"><a href="#ListIterator" class="headerlink" title="ListIterator"></a>ListIterator</h3><p>ListIterator是一个功能更加强大的, 它继承于Iterator接口,只能用于各种List类型的访问。可以通过调用listIterator()方法产生一个指向List开始处的ListIterator, 还可以调用listIterator(n)方法创建一个一开始就指向列表索引为n的元素处的ListIterator。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1&gt;Java 集合框架&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;思维导图&lt;/strong&gt;：&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="Java" scheme="ayjcsgm.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>学习Queue看这篇就够了</title>
    <link href="ayjcsgm.github.io/2019/12/09/%E5%AD%A6%E4%B9%A0Queue%E7%9C%8B%E8%BF%99%E7%AF%87%E5%B0%B1%E5%A4%9F%E4%BA%86/"/>
    <id>ayjcsgm.github.io/2019/12/09/学习Queue看这篇就够了/</id>
    <published>2019-12-09T13:15:27.000Z</published>
    <updated>2019-12-14T11:35:11.919Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h1><p>Queue是Java集合框架中的一员，继承于Collection接口。<br>与List、Set相同的是，Queue也实现了一种数据结构，这就是队列。</p><p>队列是计算机中的一种数据结构，保存在其中的数据具有“先进先出（FIFO,First In First Out）”的特性。<br>在数据结构中，队列不支持从队伍的中间插入和离开，只能从头尾进行。</p><a id="more"></a> <h3 id="队列的两种形式"><a href="#队列的两种形式" class="headerlink" title="队列的两种形式"></a>队列的两种形式</h3><p>在Java中，队列分为2种形式，一种是单队列，一种是循环队列；<br>通常，都是使用数组来实现队列。假定数组的长度为6，也就是队列的长度为6；</p><ul><li><p>单队列：<br>第一步，创建一个空数组，有两个变量，分别为front、rear，代表着头指针、尾指针；<br><img src="https://img-blog.csdnimg.cn/20191209210739255.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzY2NDQxOA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>第二步，向队列中插入数据；<br><img src="https://img-blog.csdnimg.cn/20191209210759101.png" alt="在这里插入图片描述"><br>第三步，移除队头中的数据；<br><img src="https://img-blog.csdnimg.cn/20191209210819593.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzY2NDQxOA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>第四步，再次向队列中插数据（此时rear指针指向了一个不存在的角标）；<br><img src="https://img-blog.csdnimg.cn/2019120921084136.png" alt="在这里插入图片描述"><br>此时，单队列发生了“假溢出”情况，尾指针指向了一个不存在的数组角标。<br>如果，要解决该情况的发生，有两种方式—–一，无限扩充数组大小；二，引入循环队列；</p><ul><li>循环队列：<br>当尾指针超过了数组角标大小，此时我们会判断队列的头部是否有剩余的空间，如果有就把尾指针指向队列的头部；<br><img src="https://img-blog.csdnimg.cn/20191209210921181.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzY2NDQxOA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>此时，循环队列就产生了。<br>其实，循环队列就是将单队列的首位进行相连，形成了一个圆圈，这样就不会发生角标越界的情况了。<br>在Java中，ArrayDeque、LinkedList、PriorityQueue等类实现了Queue接口，模拟了队列的数据结构。<br>其中，PriorityQueue是Queue直接子类实现，在原有基础上实现了元素的排序功能。<br>除此之外，Queue还有一个子接口–Deque，对Queue进行了扩展，定义了头尾操作功能，既可在队头添加(删除)元素，也可在队尾添加(删除)元素，俗称“双端队列”。<br><img src="https://img-blog.csdnimg.cn/20191209210945340.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzY2NDQxOA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><h3 id="Queue源码"><a href="#Queue源码" class="headerlink" title="Queue源码"></a>Queue源码</h3></li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">//接口Queue：</span><br><span class="line">public interface Queue&lt;E&gt; extends Collection&lt;E&gt; &#123;</span><br><span class="line">    //将指定元素插入到队列的尾部（队列满了话，会抛出异常）</span><br><span class="line">    boolean add(E e);</span><br><span class="line"></span><br><span class="line">    //将指定元素插入此队列的尾部(队列满了话，会返回false)</span><br><span class="line">    boolean offer(E e);</span><br><span class="line"></span><br><span class="line">    /返回取队列头部的元素，并删除该元素(如果队列为空，则抛出异常)</span><br><span class="line">    E remove();</span><br><span class="line"></span><br><span class="line">    //返回队列头部的元素，并删除该元素(如果队列为空，则返回null)</span><br><span class="line">    E poll();</span><br><span class="line"></span><br><span class="line">    //返回队列头部的元素,不删除该元素(如果队列为空，则抛出异常)</span><br><span class="line">    E element();</span><br><span class="line"></span><br><span class="line">    //返回队列头部的元素，不删除该元素(如果队列为空，则返回null)</span><br><span class="line">    E peek();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="PriorityQueue源码"><a href="#PriorityQueue源码" class="headerlink" title="PriorityQueue源码"></a>PriorityQueue源码</h3><p>作为Queue的直接子类，PriorityQueue实现了Queue定义的方法。<br>不过，又与传统的队列不相。传统队列实现了“先进先出”数据模型，而PriorityQueue则实现了最小的元素优先出队，剩余元素依次按照大小顺序出队。<br>这就是所谓的“优先级队列”—元素按照任意的顺序插入，却总是按照顺序进行输出；每次从优先队列中取出来的元素要么是最大值，要么是最小值。接下来，我们来看下PriorityQueue具体是如何实现的：</p><p>PriorityQueue成员变量和构造方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">public class PriorityQueue&lt;E&gt; extends AbstractQueue&lt;E&gt;</span><br><span class="line">        implements java.io.Serializable &#123;</span><br><span class="line"></span><br><span class="line">    private static final long serialVersionUID = -7720805057305804111L;</span><br><span class="line"></span><br><span class="line">    //默认初始化数组大小：</span><br><span class="line">    private static final int DEFAULT_INITIAL_CAPACITY = 11;</span><br><span class="line"></span><br><span class="line">    //队列底层数据结构：数组</span><br><span class="line">    private transient Object[] queue;</span><br><span class="line"></span><br><span class="line">    //队列长度：</span><br><span class="line">    private int size = 0;</span><br><span class="line"></span><br><span class="line">    //实现元素排序的比较器：</span><br><span class="line">    private final Comparator&lt;? super E&gt; comparator;</span><br><span class="line"></span><br><span class="line">    //对queue的操作次数：</span><br><span class="line">    private transient int modCount = 0;</span><br><span class="line"></span><br><span class="line">    //默认构造函数：</span><br><span class="line">    public PriorityQueue() &#123;</span><br><span class="line">        this(DEFAULT_INITIAL_CAPACITY, null);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //可设置队列长度的构造函数：</span><br><span class="line">    public PriorityQueue(int initialCapacity) &#123;</span><br><span class="line">        this(initialCapacity, null);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //可设置队列长度、元素比较器的构造函数：</span><br><span class="line">    public PriorityQueue(int initialCapacity,</span><br><span class="line">                         Comparator&lt;? super E&gt; comparator) &#123;</span><br><span class="line">        if (initialCapacity &lt; 1)</span><br><span class="line">            throw new IllegalArgumentException();</span><br><span class="line">        this.queue = new Object[initialCapacity];</span><br><span class="line">        this.comparator = comparator;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>PriorityQueue新增元素：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">//队列添加元素，底层调用offer:插入失败抛出异常</span><br><span class="line">public boolean add(E e) &#123;</span><br><span class="line">    return offer(e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//队列添加元素: 插入失败返回false</span><br><span class="line">public boolean offer(E e) &#123;</span><br><span class="line">    //不支持添加为null的元素：</span><br><span class="line">    if (e == null)</span><br><span class="line">        throw new NullPointerException();</span><br><span class="line"></span><br><span class="line">    //队列操作数+1：</span><br><span class="line">    modCount++;</span><br><span class="line">    int i = size;</span><br><span class="line"></span><br><span class="line">    //队列长度 &gt;= 数组长度时，扩容：</span><br><span class="line">    if (i &gt;= queue.length)</span><br><span class="line">        grow(i + 1);</span><br><span class="line"></span><br><span class="line">    //队列长度+1</span><br><span class="line">    size = i + 1;</span><br><span class="line"></span><br><span class="line">    //i==0，在数组角标为0处插入第一个元素：</span><br><span class="line">    if (i == 0)</span><br><span class="line">        queue[0] = e;</span><br><span class="line">    else</span><br><span class="line">        //插入的不是第一个元素：</span><br><span class="line">        siftUp(i, e);</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//对队列底层数组扩容：</span><br><span class="line">private void grow(int minCapacity) &#123;</span><br><span class="line">    //现阶段数组长度：</span><br><span class="line">    int oldCapacity = queue.length;</span><br><span class="line">    </span><br><span class="line">    //计算新数组的长度：</span><br><span class="line">    // 如果 现阶段数组长度&lt;64，则扩容为现阶段长度的2倍+2；</span><br><span class="line">    // 如果 现阶段数组&gt;=64，则扩容为现阶段长度的2倍+5；</span><br><span class="line">    int newCapacity = oldCapacity + ((oldCapacity &lt; 64) ?</span><br><span class="line">            (oldCapacity + 2) :</span><br><span class="line">            (oldCapacity &gt;&gt; 1));</span><br><span class="line">    if (newCapacity - MAX_ARRAY_SIZE &gt; 0)</span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    </span><br><span class="line">    //数组复制：得到新数组</span><br><span class="line">    queue = Arrays.copyOf(queue, newCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static int hugeCapacity(int minCapacity) &#123;</span><br><span class="line">    if (minCapacity &lt; 0)</span><br><span class="line">        throw new OutOfMemoryError();</span><br><span class="line">    return (minCapacity &gt; MAX_ARRAY_SIZE) ?</span><br><span class="line">            Integer.MAX_VALUE :</span><br><span class="line">            MAX_ARRAY_SIZE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>PriorityQueue获取队列头部元素：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">//返回队列头部的元素，不删除该元素(如果队列为空，则返回null)</span><br><span class="line">public E peek() &#123;</span><br><span class="line">    if (size == 0)</span><br><span class="line">        return null;</span><br><span class="line">    return (E) queue[0];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//返回队列头部的元素，并删除该元素(如果队列为空，则返回null)</span><br><span class="line">public E poll() &#123;</span><br><span class="line">    if (size == 0)</span><br><span class="line">        return null;</span><br><span class="line">    int s = --size;</span><br><span class="line">    modCount++;</span><br><span class="line">    E result = (E) queue[0];</span><br><span class="line">    E x = (E) queue[s];</span><br><span class="line">    queue[s] = null;</span><br><span class="line">    if (s != 0)</span><br><span class="line">        siftDown(0, x);</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>PriorityQueue中核心方法：使用了比较器进行元素比较，当插入或者删除的元素后，对PriorityQueue中树的结构进行调整；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line">    private void siftUp(int k, E x) &#123;</span><br><span class="line">        //元素比较器不为null：</span><br><span class="line">        if (comparator != null)</span><br><span class="line">            siftUpUsingComparator(k, x);</span><br><span class="line">        else</span><br><span class="line">            //元素比较器为null：</span><br><span class="line">            siftUpComparable(k, x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //进行堆结构的siftUp运算：使用元素比较器</span><br><span class="line">    private void siftUpComparable(int k, E x) &#123;</span><br><span class="line">        Comparable&lt;? super E&gt; key = (Comparable&lt;? super E&gt;) x;</span><br><span class="line">        while (k &gt; 0) &#123;</span><br><span class="line">            int parent = (k - 1) &gt;&gt;&gt; 1;</span><br><span class="line">            Object e = queue[parent];</span><br><span class="line">            if (key.compareTo((E) e) &gt;= 0)</span><br><span class="line">                break;</span><br><span class="line">            queue[k] = e;</span><br><span class="line">            k = parent;</span><br><span class="line">        &#125;</span><br><span class="line">        queue[k] = key;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //进行堆结构的siftUp运算：使用自定义元素比较器</span><br><span class="line">    private void siftUpUsingComparator(int k, E x) &#123;</span><br><span class="line">        while (k &gt; 0) &#123;</span><br><span class="line">            int parent = (k - 1) &gt;&gt;&gt; 1;</span><br><span class="line">            Object e = queue[parent];</span><br><span class="line">            if (comparator.compare(x, (E) e) &gt;= 0)</span><br><span class="line">                break;</span><br><span class="line">            queue[k] = e;</span><br><span class="line">            k = parent;</span><br><span class="line">        &#125;</span><br><span class="line">        queue[k] = x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void siftDown(int k, E x) &#123;</span><br><span class="line">        //元素比较器不为null:</span><br><span class="line">        if (comparator != null)</span><br><span class="line">            siftDownUsingComparator(k, x);</span><br><span class="line">        else</span><br><span class="line">            //元素比较器为null：</span><br><span class="line">            siftDownComparable(k, x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //进行堆结构的siftDown运算：使用元素比较器</span><br><span class="line">    private void siftDownComparable(int k, E x) &#123;</span><br><span class="line">        Comparable&lt;? super E&gt; key = (Comparable&lt;? super E&gt;)x;</span><br><span class="line">        int half = size &gt;&gt;&gt; 1; </span><br><span class="line">        while (k &lt; half) &#123;</span><br><span class="line">            int child = (k &lt;&lt; 1) + 1; </span><br><span class="line">            Object c = queue[child];</span><br><span class="line">            int right = child + 1;</span><br><span class="line">            if (right &lt; size &amp;&amp;</span><br><span class="line">                    ((Comparable&lt;? super E&gt;) c).compareTo((E) queue[right]) &gt; 0)</span><br><span class="line">                c = queue[child = right];</span><br><span class="line">            if (key.compareTo((E) c) &lt;= 0)</span><br><span class="line">                break;</span><br><span class="line">            queue[k] = c;</span><br><span class="line">            k = child;</span><br><span class="line">        &#125;</span><br><span class="line">        queue[k] = key;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //进行堆结构的siftDown运算：使用自定义元素比较器</span><br><span class="line">    private void siftDownUsingComparator(int k, E x) &#123;</span><br><span class="line">        int half = size &gt;&gt;&gt; 1;</span><br><span class="line">        while (k &lt; half) &#123;</span><br><span class="line">            int child = (k &lt;&lt; 1) + 1;</span><br><span class="line">            Object c = queue[child];</span><br><span class="line">            int right = child + 1;</span><br><span class="line">            if (right &lt; size &amp;&amp;</span><br><span class="line">                    comparator.compare((E) c, (E) queue[right]) &gt; 0)</span><br><span class="line">                c = queue[child = right];</span><br><span class="line">            if (comparator.compare(x, (E) c) &lt;= 0)</span><br><span class="line">                break;</span><br><span class="line">            queue[k] = c;</span><br><span class="line">            k = child;</span><br><span class="line">        &#125;</span><br><span class="line">        queue[k] = x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //返回队列中的比较器：</span><br><span class="line">    public Comparator&lt;? super E&gt; comparator() &#123;</span><br><span class="line">        return comparator;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面的源码中，可以看出，PriorityQueue是由“堆结构”来实现的队列。而“堆结构”又是通过数组形成的一颗完全二叉树。所以，我们在代码中可以看到PriorityQueue最底层数据结构就是数组。<br>经过上面的源码的分析，对PriorityQueue的总结如下：<br>1、<strong>PriorityQueue是线程不安全的队列</strong>；<br>2、<strong>PriorityQueue中不允许插入null元素</strong>；<br>3、<strong>PriorityQueue是一个用“堆结构”来实现的队列</strong>；</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Queue&quot;&gt;&lt;a href=&quot;#Queue&quot; class=&quot;headerlink&quot; title=&quot;Queue&quot;&gt;&lt;/a&gt;Queue&lt;/h1&gt;&lt;p&gt;Queue是Java集合框架中的一员，继承于Collection接口。&lt;br&gt;与List、Set相同的是，Queue也实现了一种数据结构，这就是队列。&lt;/p&gt;
&lt;p&gt;队列是计算机中的一种数据结构，保存在其中的数据具有“先进先出（FIFO,First In First Out）”的特性。&lt;br&gt;在数据结构中，队列不支持从队伍的中间插入和离开，只能从头尾进行。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="Java" scheme="ayjcsgm.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>学习ArrayList看这篇就够了</title>
    <link href="ayjcsgm.github.io/2019/12/09/%E5%AD%A6%E4%B9%A0ArrayList%E7%9C%8B%E8%BF%99%E7%AF%87%E5%B0%B1%E5%A4%9F%E4%BA%86/"/>
    <id>ayjcsgm.github.io/2019/12/09/学习ArrayList看这篇就够了/</id>
    <published>2019-12-09T12:58:34.000Z</published>
    <updated>2019-12-14T11:34:56.095Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ArrayList简介"><a href="#ArrayList简介" class="headerlink" title="ArrayList简介"></a>ArrayList简介</h1><p>1、ArrayList是一个数组队列，相当于动态数组。与Java中的数组相比，它的容量能动态增长。它继承于AbstractList，实现了List，RandomAccess，Cloneable，java.io.Serializable这些接口。<br>2、ArrayList与Collection的关系如下图，实现代表继承，虚线代表实现接口：</p><a id="more"></a> 　<p><img src="https://img-blog.csdnimg.cn/20191209203735109.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzY2NDQxOA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>3、ArrayList实现了RandmoAccess接口，即提供了随机访问的功能。RandmoAccess是java中用来被List实现，为List提供快速访问功能的。在ArrayList中，我们即可以通过元素的序号快速获取元素对象；这就是快速随机访问。<br>4、ArrayList实现了Cloneable接口，即覆盖了函数clone()，能被克隆。<br>5、ArrayList实现了java.io.Serializable接口，这意味着ArrayList支持序列化，能通过序列化去传输。<br>6、ArrayList中的操作不是线程安全的，可以选择CopyOnWriteArrayList或者使用Collections中的synchronizedList方法将其包装成一个线程安全的List。</p><h1 id="ArrayList的API"><a href="#ArrayList的API" class="headerlink" title="ArrayList的API"></a>ArrayList的API</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">// Collection中定义的API</span><br><span class="line">boolean             add(E object)</span><br><span class="line">boolean             addAll(Collection&lt;? extends E&gt; collection)</span><br><span class="line">void                clear()</span><br><span class="line">boolean             contains(Object object)</span><br><span class="line">boolean             containsAll(Collection&lt;?&gt; collection)</span><br><span class="line">boolean             equals(Object object)</span><br><span class="line">int                 hashCode()</span><br><span class="line">boolean             isEmpty()</span><br><span class="line">Iterator&lt;E&gt;         iterator()</span><br><span class="line">boolean             remove(Object object)</span><br><span class="line">boolean             removeAll(Collection&lt;?&gt; collection)</span><br><span class="line">boolean             retainAll(Collection&lt;?&gt; collection)</span><br><span class="line">int                 size()</span><br><span class="line">&lt;T&gt; T[]             toArray(T[] array)</span><br><span class="line">Object[]            toArray()</span><br><span class="line">// AbstractCollection中定义的API</span><br><span class="line">void                add(int location, E object)</span><br><span class="line">boolean             addAll(int location, Collection&lt;? extends E&gt; collection)</span><br><span class="line">E                   get(int location)</span><br><span class="line">int                 indexOf(Object object)</span><br><span class="line">int                 lastIndexOf(Object object)</span><br><span class="line">ListIterator&lt;E&gt;     listIterator(int location)</span><br><span class="line">ListIterator&lt;E&gt;     listIterator()</span><br><span class="line">E                   remove(int location)</span><br><span class="line">E                   set(int location, E object)</span><br><span class="line">List&lt;E&gt;             subList(int start, int end)</span><br><span class="line">// ArrayList新增的API</span><br><span class="line">Object               clone()</span><br><span class="line">void                 ensureCapacity(int minimumCapacity)//增加容量</span><br><span class="line">void                 trimToSize()//修改容量是列表当前大小</span><br><span class="line">void                 removeRange(int fromIndex, int toIndex)//删除所有索引在 fromIndex （含）和 toIndex之间的元素</span><br></pre></td></tr></table></figure><h1 id="ArrayList源码分析"><a href="#ArrayList源码分析" class="headerlink" title="ArrayList源码分析"></a>ArrayList源码分析</h1><h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><p>ArrayList的主要属性如下代码所示:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">//序列化id</span><br><span class="line">private static final long serialVersionUID = 8683452581122892189L;</span><br><span class="line">//容器默认初始化大小</span><br><span class="line">private static final int DEFAULT_CAPACITY = 10;</span><br><span class="line">//一个空对象</span><br><span class="line">private static final Object[] EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line">//一个空对象，如果使用默认构造函数创建ArrayList，则默认对象内容是该值</span><br><span class="line">private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line">//ArrayList存放对象的容器，后面的添加、删除等操作都是基于该属性来进行操作</span><br><span class="line">transient Object[] elementData;</span><br><span class="line">//当前列表已使用的长度</span><br><span class="line">private int size;</span><br><span class="line">//数组最大长度（2147483639），这里为什么是Integer.MAX_VALUE - 8是因为有些虚拟机在数组中保留了一些头部信息，防止内存溢出</span><br><span class="line">private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;</span><br><span class="line">//这个是从AbstractList继承过来的，代表ArrayList集合修改的次数</span><br><span class="line">protected transient int modCount = 0;</span><br></pre></td></tr></table></figure><p>关于Java中<strong>transient</strong>关键字的解释：<br> 我们都知道一个对象只要实现了Serilizable接口，这个对象就可以被序列化，java的这种序列化模式为开发者提供了很多便利，我们可以不必关系具体序列化的过程，只要这个类实现了Serilizable接口，这个类的所有属性和方法都会自动序列化。<br> 然而在实际开发过程中，我们常常会遇到这样的问题，这个类的有些属性需要序列化，而其他属性不需要被序列化，打个比方，如果一个用户有一些敏感信息（如密码，银行卡号等），为了安全起见，不希望在网络操作（主要涉及到序列化操作，本地序列化缓存也适用）中被传输，这些信息对应的变量就可以加上transient关键字。换句话说，这个字段的生命周期仅存于调用者的内存中而不会写到磁盘里持久化。<br> 总之，java 的transient关键字为我们提供了便利，你只需要实现Serilizable接口，将不需要序列化的属性前添加关键字transient，序列化对象的时候，这个属性就不会序列化到指定的目的地中。</p><h1 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h1><p><strong>1、无参构造函数</strong><br>如果不传入参数，则使用默认无参构造方法创建ArrayLisy对象，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public ArrayList() &#123;</span><br><span class="line">        this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>注意：<strong>此时我们创建的ArrayList对象中的elementData中的长度是0，size是0，当进行第一次add的时候，elementDate将会变成默认的长度：10</strong>。</p><p><strong>2、带int类型的构造函数</strong><br>如果传入参数，则代表指定ArrayList的初始数组长度；传入参数如果是大于0，则使用用户的参数初始化；如果参数等于0，则用内部的空对象EMPTY_ELEMENTDATA的地址直接赋值给elementData；否则抛出异常，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public ArrayList(int initialCapacity) &#123;</span><br><span class="line">        if (initialCapacity &gt; 0) &#123;</span><br><span class="line">            this.elementData = new Object[initialCapacity];</span><br><span class="line">        &#125; else if (initialCapacity == 0) &#123;</span><br><span class="line">            this.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            throw new IllegalArgumentException(&quot;Illegal Capacity: &quot;+</span><br><span class="line">                                               initialCapacity);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>3、带Collection对象的构造函数</strong><br>1.将Collection对象转换成数组，然后将数组的地址赋值给elementData。<br>2.更新size的值，如果size的值等于0直接将内部空对象EMPTY_ELEMENTDATA的地址赋值给elementData。<br>3.如果size的值大于0，则执行Arrays.copy方法，把Collection对象的内容copy(可以理解为深拷贝)到elementData中，并且这些元素是按照该collection的迭代器返回它们的顺序排列的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public ArrayList(Collection&lt;? extends E&gt; c) &#123;</span><br><span class="line">       elementData = c.toArray();</span><br><span class="line">       if ((size = elementData.length) != 0) &#123;</span><br><span class="line">           // c.toArray might (incorrectly) not return Object[] (see 6260652)</span><br><span class="line">           if (elementData.getClass() != Object[].class)</span><br><span class="line">               elementData = Arrays.copyOf(elementData, size, Object[].class);</span><br><span class="line">       &#125; else &#123;</span><br><span class="line">           // replace with empty array.</span><br><span class="line">           this.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>介绍下<strong>System.arraycopy</strong>和<strong>Arrays.copy</strong>方法，分析源码时会经常用到。</p><p><strong>System.arraycopy</strong>方法：它就是从指定的源数组将元素中复制到目标数组，复制从指定的位置开始，到设定的复制长度结束，然后从目标数组的指定起始位置依次插入。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// src 源数组</span><br><span class="line">  // srcPos 源数组要复制的起始位置</span><br><span class="line">  // dest 要赋值到的目标数组</span><br><span class="line">  // destPos 目标数组放置的起始位置</span><br><span class="line">  // length 复制的长度</span><br><span class="line">  // 使用了native关键字，说明调用的是其他语言写的底层函数</span><br><span class="line">  public static native void arraycopy(Object src,  int  srcPos,</span><br><span class="line">                                      Object dest, int destPos,</span><br><span class="line">                                      int length);</span><br></pre></td></tr></table></figure><p><strong>Arrays.copy</strong>方法：它新建了一个数组并且将原数组的内容拷贝到长度为newLength的新数组中，并且返回该新数组。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// original 要复制的数组</span><br><span class="line">   // newLength 要返回副本的长度</span><br><span class="line">   // newwType 要返回的副本类型</span><br><span class="line">   // 内部调用了System.arraycopy方法</span><br><span class="line">   public static &lt;T,U&gt; T[] copyOf(U[] original, int newLength, Class&lt;? extends T[]&gt; newType) &#123;</span><br><span class="line">       @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">       T[] copy = ((Object)newType == (Object)Object[].class)</span><br><span class="line">           ? (T[]) new Object[newLength]</span><br><span class="line">           : (T[]) Array.newInstance(newType.getComponentType(), newLength);</span><br><span class="line">       System.arraycopy(original, 0, copy, 0,</span><br><span class="line">                        Math.min(original.length, newLength));</span><br><span class="line">       return copy;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>两者的区别：<br>1、System.arraycopy需要目标数组，将原数组拷贝到你自己定义的数值里，而且可以选择拷贝的起点和长度以及放入新数组中的位置。<br>2、Arrays.copyof是系统自动在内部新建一个数组，调用System.arraycopy将原数组的内容拷贝到长度为newLength的新数组中，并返回新建的数组。</p><h1 id="添加元素"><a href="#添加元素" class="headerlink" title="添加元素"></a>添加元素</h1><p>ArrayList提供了add(E e)、add(int index, E element)、addAll(Collection&lt;? extends E&gt; c)、addAll(int index, Collection&lt;? extends E&gt; c)、set(int index, E element)这个五个方法来实现ArrayList增加。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//官方解释：将指定的元素追加到列表（elementData）的末尾</span><br><span class="line">    public boolean add(E e) &#123;</span><br><span class="line">        ensureCapacityInternal(size + 1);  // Increments modCount!!</span><br><span class="line">        elementData[size++] = e;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>看下ensureCapacityInternal方法，以及它内部调用的方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">看下ensureCapacityInternal方法，以及它内部调用的方法。</span><br><span class="line">    //参数值实际是size+1</span><br><span class="line">    private void ensureCapacityInternal(int minCapacity) &#123;</span><br><span class="line">        ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//这个方式是判断当前数组是否是个空数组，如果是就返回默认长度10，否则就返回size+1;也就是说如果你是用无参构造函数初始化ArrayList，那么在第一次调用add方法时，默认长度会变成10</span><br><span class="line"> private static int calculateCapacity(Object[] elementData, int minCapacity) &#123;</span><br><span class="line">       if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">           return Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">       &#125;</span><br><span class="line">       return minCapacity;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//这个方法首先将集合修改次数加1，然后判断数组的长度是否可以存入下一个元素，如果长度不够会调用grow方法进行扩容</span><br><span class="line">  private void ensureExplicitCapacity(int minCapacity) &#123;</span><br><span class="line">      modCount++;</span><br><span class="line"></span><br><span class="line">      // overflow-conscious code</span><br><span class="line">      if (minCapacity - elementData.length &gt; 0)</span><br><span class="line">          grow(minCapacity);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//这个方法首先定义数组新的长度为原来数组长度的1.5倍，如果新长度减去所需数组的最小长度小于0，那么新长度就等于所需数组最小长度；再下面的判断是如果新长度大于MAX_ARRAY_SIZE(ArrayList内部定义MAX_ARRAY_SIZE的值是：2147483639)就调用hugeCapacity方法，最后调用Arrays.copyOf将扩容后的新数组地址赋值给elementData</span><br><span class="line">   private void grow(int minCapacity) &#123;</span><br><span class="line">       // overflow-conscious code</span><br><span class="line">       int oldCapacity = elementData.length;</span><br><span class="line">       int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1);</span><br><span class="line">       if (newCapacity - minCapacity &lt; 0)</span><br><span class="line">           newCapacity = minCapacity;</span><br><span class="line">       if (newCapacity - MAX_ARRAY_SIZE &gt; 0)</span><br><span class="line">           newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">       // minCapacity is usually close to size, so this is a win:</span><br><span class="line">       elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//如果扩容长度超过MAX_ARRAY_SIZE，则设置长度为Integer.MAX_VALUE，但不是能百分百成功的，这取决于虚拟机。（如果我们可以在某些虚拟机上可以避免OutOfMemory，我们将另外分配Integer.MAX_VALUE，如果你很幸运（取决于虚拟机），我们将成功）</span><br><span class="line">   private static int hugeCapacity(int minCapacity) &#123;</span><br><span class="line">       if (minCapacity &lt; 0) // overflow</span><br><span class="line">           throw new OutOfMemoryError();</span><br><span class="line">       return (minCapacity &gt; MAX_ARRAY_SIZE) ?</span><br><span class="line">           Integer.MAX_VALUE :</span><br><span class="line">           MAX_ARRAY_SIZE;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>最后总结一下add方法的逻辑：</p><ul><li>确保数组已使用长度（size）加1后可以存入下一个元素。</li><li>修改次数modCount标识自增1，如果当前数组已使用长度+1后大于当前数组长度，则调用grow方法，扩容数组，grow方法会将当前数组的长度变为原来容量的1.5倍。</li><li>确保新加的元素有地方存储后，则将新元素添加到位于size++的位置上。</li><li>返回添加成功的布尔值。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">add(int index, E element)</span><br></pre></td></tr></table></figure><p>这个方法和上面的add类型，该方法可以按照元素的位置，指定新元素位置插入。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public void add(int index, E element) &#123;</span><br><span class="line">       //判断索引位置是否正确</span><br><span class="line">       rangeCheckForAdd(index);</span><br><span class="line">       //扩容检测</span><br><span class="line">       ensureCapacityInternal(size + 1);  // Increments modCount!!</span><br><span class="line">       //对源数组进行复制处理（位移），从index + 1到size - index</span><br><span class="line">       //即向后移动位于当前位置和后面的元素</span><br><span class="line">       System.arraycopy(elementData, index, elementData, index + 1,</span><br><span class="line">                        size - index);</span><br><span class="line">       //在指定的位置赋值</span><br><span class="line">       elementData[index] = element;</span><br><span class="line">       size++;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>该方法首先调用rangeCheckForAdd方法判断指定的位置小于当前数组的长度并且大于0，否则抛出异常。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">private void rangeCheckForAdd(int index) &#123;</span><br><span class="line">       if (index &gt; size || index &lt; 0)</span><br><span class="line">           throw new IndexOutOfBoundsException(outOfBoundsMsg(index));</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>第二步调用的<strong>ensureCapacityInternal</strong>方法和上面的add方法逻辑一样。<br>第三步调用<strong>System.arraycopy</strong>方法把<strong>指定下标以及后面的元素全部往后移一位</strong>。<br>最后将新的元素放到指定位置（index）上，并将size+1。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">addAll(Collection&lt;? extends E&gt; c)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//按照指定的Collection迭代器所返回的顺序，依次插入到列表尾部。</span><br><span class="line">   public boolean addAll(Collection&lt;? extends E&gt; c) &#123;</span><br><span class="line">       // 将c转换为数组</span><br><span class="line">       Object[] a = c.toArray();</span><br><span class="line">       int numNew = a.length;</span><br><span class="line">       //扩容处理，大小为size + numNew</span><br><span class="line">       ensureCapacityInternal(size + numNew);  // Increments modCount</span><br><span class="line">       System.arraycopy(a, 0, elementData, size, numNew);</span><br><span class="line">       size += numNew;</span><br><span class="line">       return numNew != 0;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>该方法首先传过来的Collection集合转换为数组，然后做扩容处理，接着使用System.arraycopy把转换后的数组复制到列表尾部。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">addAll(int index, Collection&lt;? extends E&gt; c)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">//将指定集合中的所有元素插入到此列表中，从指定的位置开始</span><br><span class="line">public boolean addAll(int index, Collection&lt;? extends E&gt; c) &#123;</span><br><span class="line">       //判断索引位置是否正确</span><br><span class="line">       rangeCheckForAdd(index);</span><br><span class="line">       // 将c转换为数组</span><br><span class="line">       Object[] a = c.toArray();</span><br><span class="line">       int numNew = a.length;</span><br><span class="line">       //扩容处理，大小为size + numNew</span><br><span class="line">       ensureCapacityInternal(size + numNew);  // Increments modCount</span><br><span class="line">       //如果插入索引小于列表长度，则将当前索引等于index和大于index的元素往后移numMoved个位置</span><br><span class="line">       int numMoved = size - index;</span><br><span class="line">       if (numMoved &gt; 0)</span><br><span class="line">           System.arraycopy(elementData, index, elementData, index + numNew,</span><br><span class="line">                            numMoved);</span><br><span class="line">       //将数组添加到列表尾部</span><br><span class="line">       System.arraycopy(a, 0, elementData, index, numNew);</span><br><span class="line">       //更新列表长度</span><br><span class="line">       size += numNew;</span><br><span class="line">       return numNew != 80;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//set(int index, E element)用指定的元素替换此列表中指定位置的元素</span><br><span class="line">   public E set(int index, E element) &#123;</span><br><span class="line">       //判断插入位置是否正确，如果大于列表长度会抛出异常</span><br><span class="line">       rangeCheck(index);</span><br><span class="line">       //获取插入位置的当前元素</span><br><span class="line">       E oldValue = elementData(index);</span><br><span class="line">       //将新的元素替换当前插入位置的元素</span><br><span class="line">       elementData[index] = element;</span><br><span class="line">       //返回插入位置老的值</span><br><span class="line">       return oldValue;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h1 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h1><p>ArrayList提供了外界remove(int index)、remove(Object o)、removeAll(Collection&lt;?&gt; c)、clear()四个方法进行元素的删除。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">//remove(int index)移除指定位置上的元素</span><br><span class="line">    public E remove(int index) &#123;</span><br><span class="line">        //判断删除位置是否正确，如果大于列表长度会抛出异常</span><br><span class="line">        rangeCheck(index);</span><br><span class="line">        //将集合修改次数加1</span><br><span class="line">        modCount++;</span><br><span class="line">        //获取当前删除位置上的元素</span><br><span class="line">        E oldValue = elementData(index);</span><br><span class="line">        //判断是否删除的是最后一个元素，如果不是将删除位置后的元素向左移numMoved个位置</span><br><span class="line">        int numMoved = size - index - 1;</span><br><span class="line">        if (numMoved &gt; 0)</span><br><span class="line">            System.arraycopy(elementData, index+1, elementData, index,</span><br><span class="line">                             numMoved);</span><br><span class="line">        //将列表最后的元素置为null，等待垃圾收集器收集</span><br><span class="line">        elementData[--size] = null; // clear to let GC do its work</span><br><span class="line">        //返回删除位置老的值</span><br><span class="line">        return oldValue;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">// remove(Object o)移除指定元素</span><br><span class="line">    public boolean remove(Object o) &#123;</span><br><span class="line">        //因为ArrayList允许存在null，所以需要进行null判断</span><br><span class="line">        if (o == null) &#123;</span><br><span class="line">            for (int index = 0; index &lt; size; index++)</span><br><span class="line">                if (elementData[index] == null) &#123;</span><br><span class="line">                    //移除这个位置的元素</span><br><span class="line">                    fastRemove(index);</span><br><span class="line">                    return true;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            for (int index = 0; index &lt; size; index++)</span><br><span class="line">                if (o.equals(elementData[index])) &#123;</span><br><span class="line">                    fastRemove(index);</span><br><span class="line">                    return true;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    private void fastRemove(int index) &#123;</span><br><span class="line">        //将集合修改次数加1      </span><br><span class="line">        modCount++;</span><br><span class="line">        //判断是否删除的是最后一个元素，如果不是将删除位置后的元素向左移numMoved个位置</span><br><span class="line">        int numMoved = size - index - 1;</span><br><span class="line">        if (numMoved &gt; 0)</span><br><span class="line">            System.arraycopy(elementData, index+1, elementData, index,</span><br><span class="line">                             numMoved);</span><br><span class="line">        //将列表最后的元素置为null，等待垃圾收集器收集</span><br><span class="line">        elementData[--size] = null; // clear to let GC do its work</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">// removeAll(Collection&lt;?&gt; c)从此列表中删除指定集合中包含的所有元素</span><br><span class="line"> public boolean removeAll(Collection&lt;?&gt; c) &#123;</span><br><span class="line">     //进行判断，如果c为null抛出异常</span><br><span class="line">     Objects.requireNonNull(c);</span><br><span class="line">     return batchRemove(c, false);</span><br><span class="line"> &#125;</span><br><span class="line"> private boolean batchRemove(Collection&lt;?&gt; c, boolean complement) &#123;</span><br><span class="line">     final Object[] elementData = this.elementData;</span><br><span class="line">     int r = 0, w = 0;</span><br><span class="line">     boolean modified = false;</span><br><span class="line">     try &#123;</span><br><span class="line">         //遍历数组，并检查这个集合是否包含对应的值，移动要保留的值到数组前面，w最后值为要保留的元素的数量</span><br><span class="line">         //若保留，就将相同的元素移动到前段；不删除，就将不同元素移动到前段</span><br><span class="line">         for (; r &lt; size; r++)</span><br><span class="line">             if (c.contains(elementData[r]) == complement)</span><br><span class="line">                 elementData[w++] = elementData[r];</span><br><span class="line">     &#125; finally &#123;</span><br><span class="line">         // 确保异常抛出前的部分可以完成期望的操作，而被遍历的部分会被接到后面</span><br><span class="line">         //r不等于size表示可能出错了</span><br><span class="line">         if (r != size) &#123;</span><br><span class="line">             System.arraycopy(elementData, r,</span><br><span class="line">                              elementData, w,</span><br><span class="line">                              size - r);</span><br><span class="line">             w += size - r;</span><br><span class="line">         &#125;</span><br><span class="line">         //如果w等于size，表示全部元素都保留了，所以也就没有删除操作发生，所以会返回false；反之，返回true，并更改数组</span><br><span class="line">         //而w不等于size的时候，即使try块抛出异常，也能正确处理异常抛出前的操作，因为w始终为要保留的前段部分的长度，数组也不会因此乱序</span><br><span class="line">         if (w != size) &#123;</span><br><span class="line">             // clear to let GC do its work</span><br><span class="line">             for (int i = w; i &lt; size; i++)</span><br><span class="line">                 elementData[i] = null;</span><br><span class="line">             modCount += size - w;</span><br><span class="line">             size = w;</span><br><span class="line">             modified = true;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     return modified;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//clear() 清空ArrayList内的所有元素，不减小数组容量</span><br><span class="line"> public void clear() &#123;</span><br><span class="line">     //将集合修改次数加1  </span><br><span class="line">     modCount++;</span><br><span class="line">     //循环将列表中的所有元素置为null，等待垃圾收集器收集</span><br><span class="line">     // clear to let GC do its work</span><br><span class="line">     for (int i = 0; i &lt; size; i++)</span><br><span class="line">         elementData[i] = null;</span><br><span class="line">     //将列表长度设为0</span><br><span class="line">     size = 0;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h1 id="查找元素"><a href="#查找元素" class="headerlink" title="查找元素"></a>查找元素</h1><p>ArrayList提供了get(int index)用读取ArrayList中的元素。由于ArrayList是动态数组，所以我们完全可以根据下标来获取ArrayList中的元素，而且速度还比较快。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public E get(int index) &#123;</span><br><span class="line">      //判断删除位置是否正确，如果大于列表长度会抛出异常</span><br><span class="line">      rangeCheck(index);</span><br><span class="line">      //直接返回列表中下标等于index的元素</span><br><span class="line">      return elementData(index);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h1 id="判断元素是否存在列表中"><a href="#判断元素是否存在列表中" class="headerlink" title="判断元素是否存在列表中"></a>判断元素是否存在列表中</h1><p>ArrayList提供了contains(Object o)用于判断元素是否存在于列表中。<br>注意：contains方法会遍历ArrayList。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public boolean contains(Object o) &#123;</span><br><span class="line">        //调用indexOf方法判断需要查找的元素在列表中的下标是否大于等于0，小于0则不存在</span><br><span class="line">        return indexOf(o) &gt;= 0;</span><br><span class="line">    &#125;</span><br><span class="line">    public int indexOf(Object o) &#123;</span><br><span class="line">        //因为ArrayList允许存在null，所以需要进行null判断</span><br><span class="line">        if (o == null) &#123;</span><br><span class="line">            //遍历列表，如果列表存在null值的元素，直接返回其下标位置</span><br><span class="line">            for (int i = 0; i &lt; size; i++)</span><br><span class="line">                if (elementData[i]==null)</span><br><span class="line">                    return i;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            //遍历列表，使用equals判断是否有相等的元素，有的话直接返回其下标位置</span><br><span class="line">            for (int i = 0; i &lt; size; i++)</span><br><span class="line">                if (o.equals(elementData[i]))</span><br><span class="line">                    return i;</span><br><span class="line">        &#125;</span><br><span class="line">        //列表中不能存在传进来的元素，返回-1</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="最小化ArrayList的实际存储量"><a href="#最小化ArrayList的实际存储量" class="headerlink" title="最小化ArrayList的实际存储量"></a>最小化ArrayList的实际存储量</h1><p>ArrayList提供了trimToSize()方法用于将底层数组的容量调整为当前列表保存的实际元素的大小</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public void trimToSize() &#123;</span><br><span class="line">      //将集合修改次数加1</span><br><span class="line">      modCount++;</span><br><span class="line">      //如果当前ArrayList的实际长度小于列表的长度，将列表超过size后的空余的空间（包括null值）去除，调用Arrays.cppyof方法拷贝elementData，长度为size</span><br><span class="line">      if (size &lt; elementData.length) &#123;</span><br><span class="line">          elementData = (size == 0)</span><br><span class="line">            ? EMPTY_ELEMENTDATA</span><br><span class="line">            : Arrays.copyOf(elementData, size);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h1 id="截取ArrayList部分内容"><a href="#截取ArrayList部分内容" class="headerlink" title="截取ArrayList部分内容"></a>截取ArrayList部分内容</h1><p>ArrayList提供了subList(int fromIndex, int toIndex)方法来实现部分数据的截取。<br>可以从源码中看到其实是创建了一个SubList的内部对象，可以理解为是返回当前ArrayList的部分视图，其实指向的存放数据的还是一个地方。如果修改了subList返回的内容的话，原来的内容也会被修改。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public List&lt;E&gt; subList(int fromIndex, int toIndex) &#123;</span><br><span class="line">    //检查需要截取的下标位置是否正确</span><br><span class="line">    subListRangeCheck(fromIndex, toIndex, size);</span><br><span class="line">    return new SubList(this, 0, fromIndex, toIndex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="其它方法"><a href="#其它方法" class="headerlink" title="其它方法"></a>其它方法</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//判断ArrayList是否为空</span><br><span class="line">  public boolean isEmpty() &#123;</span><br><span class="line">      return size == 0;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//反向查找元素位置，与上述的indexOf相反</span><br><span class="line"> public int lastIndexOf(Object o) &#123;</span><br><span class="line">     if (o == null) &#123;</span><br><span class="line">         for (int i = size-1; i &gt;= 0; i--)</span><br><span class="line">             if (elementData[i]==null)</span><br><span class="line">                 return i;</span><br><span class="line">     &#125; else &#123;</span><br><span class="line">         for (int i = size-1; i &gt;= 0; i--)</span><br><span class="line">             if (o.equals(elementData[i]))</span><br><span class="line">                 return i;</span><br><span class="line">     &#125;</span><br><span class="line">     return -1;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//将元素全部拷贝到v中</span><br><span class="line">   public Object clone() &#123;</span><br><span class="line">       try &#123;</span><br><span class="line">           ArrayList&lt;?&gt; v = (ArrayList&lt;?&gt;) super.clone();</span><br><span class="line">           v.elementData = Arrays.copyOf(elementData, size);</span><br><span class="line">           v.modCount = 0;</span><br><span class="line">           return v;</span><br><span class="line">       &#125; catch (CloneNotSupportedException e) &#123;</span><br><span class="line">           // this shouldn&apos;t happen, since we are Cloneable</span><br><span class="line">           throw new InternalError(e);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//返回ArrayList拷贝后的Object数组</span><br><span class="line">  public Object[] toArray() &#123;</span><br><span class="line">      return Arrays.copyOf(elementData, size);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//返回ArrayList的模板数组。所谓模板数组，即可将T设置为任意数据类型</span><br><span class="line"> public &lt;T&gt; T[] toArray(T[] a) &#123;</span><br><span class="line">     //若a的长度小于ArrayList中的元素个数，返回拷贝了ArrayList中全部元素的新数组</span><br><span class="line">     if (a.length &lt; size)</span><br><span class="line">         // Make a new array of a&apos;s runtime type, but my contents:</span><br><span class="line">         return (T[]) Arrays.copyOf(elementData, size, a.getClass());</span><br><span class="line">     //若a的长度大于等于ArrayList中的元素个数，则将ArrayList中的元素全部拷贝到a中</span><br><span class="line">     System.arraycopy(elementData, 0, a, 0, size);</span><br><span class="line">     if (a.length &gt; size)</span><br><span class="line">         a[size] = null;</span><br><span class="line">     return a;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">//将ArrayList中的元素写入到输入流中，先写容量，在写元素</span><br><span class="line"> private void writeObject(java.io.ObjectOutputStream s)</span><br><span class="line">     throws java.io.IOException&#123;</span><br><span class="line">     // Write out element count, and any hidden stuff</span><br><span class="line">     int expectedModCount = modCount;</span><br><span class="line">     s.defaultWriteObject();</span><br><span class="line"></span><br><span class="line">     // Write out size as capacity for behavioural compatibility with clone()</span><br><span class="line">     s.writeInt(size);</span><br><span class="line"></span><br><span class="line">     // Write out all elements in the proper order.</span><br><span class="line">     for (int i=0; i&lt;size; i++) &#123;</span><br><span class="line">         s.writeObject(elementData[i]);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     if (modCount != expectedModCount) &#123;</span><br><span class="line">         throw new ConcurrentModificationException();</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">//从输入流中读取数据到elementData中，一样是先读容量，再读数据</span><br><span class="line">private void readObject(java.io.ObjectInputStream s)</span><br><span class="line">    throws java.io.IOException, ClassNotFoundException &#123;</span><br><span class="line">    elementData = EMPTY_ELEMENTDATA;</span><br><span class="line"></span><br><span class="line">    // Read in size, and any hidden stuff</span><br><span class="line">    s.defaultReadObject();</span><br><span class="line"></span><br><span class="line">    // Read in capacity</span><br><span class="line">    s.readInt(); // ignored</span><br><span class="line"></span><br><span class="line">    if (size &gt; 0) &#123;</span><br><span class="line">        // be like clone(), allocate array based upon size not capacity</span><br><span class="line">        int capacity = calculateCapacity(elementData, size);</span><br><span class="line">        SharedSecrets.getJavaOISAccess().checkArray(s, Object[].class, capacity);</span><br><span class="line">        ensureCapacityInternal(size);</span><br><span class="line"></span><br><span class="line">        Object[] a = elementData;</span><br><span class="line">        // Read in all elements in the proper order.</span><br><span class="line">        for (int i=0; i&lt;size; i++) &#123;</span><br><span class="line">            a[i] = s.readObject();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><ul><li>ArrayList自己实现了序列化和反序列化，因为它实现了writeObject和readObject方法。</li><li>ArrayList基于数组实现，会自动扩容。</li><li>添加元素时会自己判断是否需要扩容，最好指定一个大概的大小，防止后面多次扩容带来的内存消耗；删除元素时不会减少容量，删除元素时，将删除掉的位置元素置为null，下次gc就会自动回收这些元素所占的空间。</li><li>ArrayList是线程不安全的。</li><li>使用iterator遍历可能会引发多线程异常。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;ArrayList简介&quot;&gt;&lt;a href=&quot;#ArrayList简介&quot; class=&quot;headerlink&quot; title=&quot;ArrayList简介&quot;&gt;&lt;/a&gt;ArrayList简介&lt;/h1&gt;&lt;p&gt;1、ArrayList是一个数组队列，相当于动态数组。与Java中的数组相比，它的容量能动态增长。它继承于AbstractList，实现了List，RandomAccess，Cloneable，java.io.Serializable这些接口。&lt;br&gt;2、ArrayList与Collection的关系如下图，实现代表继承，虚线代表实现接口：&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="Java" scheme="ayjcsgm.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java 8 新特性</title>
    <link href="ayjcsgm.github.io/2019/11/15/Java-8-%E6%96%B0%E7%89%B9%E6%80%A7/"/>
    <id>ayjcsgm.github.io/2019/11/15/Java-8-新特性/</id>
    <published>2019-11-15T12:09:27.000Z</published>
    <updated>2019-12-14T11:31:52.911Z</updated>
    
    <content type="html"><![CDATA[<p>Java 8 (又称为 jdk 1.8) 是 Java 语言开发的一个主要版本。 Oracle 公司于 2014 年 3 月 18 日发布 Java 8 ，它支持函数式编程，新的 JavaScript 引擎，新的日期 API，新的Stream API 等。</p><a id="more"></a><h2 id="新特性"><a href="#新特性" class="headerlink" title="新特性"></a>新特性</h2><p>Java8 新增了非常多的特性，我们主要讨论以下几个：</p><ul><li><p>Lambda 表达式 − Lambda 允许把函数作为一个方法的参数（函数作为参数传递到方法中）。</p></li><li><p>方法引用 − 方法引用提供了非常有用的语法，可以直接引用已有Java类或对象（实例）的方法或构造器。与lambda联合使用，方法引用可以使语言的构造更紧凑简洁，减少冗余代码。</p></li><li><p>默认方法 − 默认方法就是一个在接口里面有了一个实现的方法。</p></li><li><p>新工具 − 新的编译工具，如：Nashorn引擎 jjs、 类依赖分析器jdeps。</p></li><li><p>Stream API −新添加的Stream API（java.util.stream） 把真正的函数式编程风格引入到Java中。</p></li><li><p>Date Time API − 加强对日期与时间的处理。</p></li><li><p>Optional 类 − Optional 类已经成为 Java 8 类库的一部分，用来解决空指针异常。</p></li><li><p>Nashorn, JavaScript 引擎 − Java 8提供了一个新的Nashorn javascript引擎，它允许我们在JVM上运行特定的javascript应用。</p></li></ul><p>更多的新特性可以参阅官网：<a href="https://www.oracle.com/technetwork/java/javase/8-whats-new-2157071.html" target="_blank" rel="noopener">What’s New in JDK 8</a></p><p>在关于 Java 8 文章的实例，我们均使用 jdk 1.8 环境，你可以使用以下命令查看当前 jdk 的版本：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ java -version</span><br><span class="line">java version <span class="string">"1.8.0_31"</span></span><br><span class="line">Java(TM) <span class="function">SE Runtime <span class="title">Environment</span> <span class="params">(build <span class="number">1.8</span><span class="number">.0</span>_31-b13)</span></span></span><br><span class="line"><span class="function">Java <span class="title">HotSpot</span><span class="params">(TM)</span> 64-Bit Server <span class="title">VM</span> <span class="params">(build <span class="number">25.31</span>-b07, mixed mode)</span></span></span><br></pre></td></tr></table></figure><h2 id="编程风格"><a href="#编程风格" class="headerlink" title="编程风格"></a>编程风格</h2><p>Java 8 希望有自己的编程风格，并与 Java 7 区别开，以下实例展示了 Java 7 和 Java 8 的编程格式：</p><p>Java8Tester.java 文件代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Comparator;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Java8Tester</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line">   </span><br><span class="line">      List&lt;String&gt; names1 = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">      names1.add(<span class="string">"Google "</span>);</span><br><span class="line">      names1.add(<span class="string">"Runoob "</span>);</span><br><span class="line">      names1.add(<span class="string">"Taobao "</span>);</span><br><span class="line">      names1.add(<span class="string">"Baidu "</span>);</span><br><span class="line">      names1.add(<span class="string">"Sina "</span>);</span><br><span class="line">        </span><br><span class="line">      List&lt;String&gt; names2 = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">      names2.add(<span class="string">"Google "</span>);</span><br><span class="line">      names2.add(<span class="string">"Runoob "</span>);</span><br><span class="line">      names2.add(<span class="string">"Taobao "</span>);</span><br><span class="line">      names2.add(<span class="string">"Baidu "</span>);</span><br><span class="line">      names2.add(<span class="string">"Sina "</span>);</span><br><span class="line">        </span><br><span class="line">      Java8Tester tester = <span class="keyword">new</span> Java8Tester();</span><br><span class="line">      System.out.println(<span class="string">"使用 Java 7 语法: "</span>);</span><br><span class="line">        </span><br><span class="line">      tester.sortUsingJava7(names1);</span><br><span class="line">      System.out.println(names1);</span><br><span class="line">      System.out.println(<span class="string">"使用 Java 8 语法: "</span>);</span><br><span class="line">        </span><br><span class="line">      tester.sortUsingJava8(names2);</span><br><span class="line">      System.out.println(names2);</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// 使用 java 7 排序</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sortUsingJava7</span><span class="params">(List&lt;String&gt; names)</span></span>&#123;   </span><br><span class="line">      Collections.sort(names, <span class="keyword">new</span> Comparator&lt;String&gt;() &#123;</span><br><span class="line">         <span class="meta">@Override</span></span><br><span class="line">         <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(String s1, String s2)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> s1.compareTo(s2);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// 使用 java 8 排序</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sortUsingJava8</span><span class="params">(List&lt;String&gt; names)</span></span>&#123;</span><br><span class="line">      Collections.sort(names, (s1, s2) -&gt; s1.compareTo(s2));</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行以上脚本，输出结果为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ javac Java8Tester.java</span><br><span class="line">$ java Java8Tester</span><br><span class="line">使用 Java <span class="number">7</span> 语法: </span><br><span class="line">[Baidu , Google , Runoob , Sina , Taobao ]</span><br><span class="line">使用 Java <span class="number">8</span> 语法: </span><br><span class="line">[Baidu , Google , Runoob , Sina , Taobao ]</span><br></pre></td></tr></table></figure><p>接下来我们将详细为大家简介 Java 8 的新特性：</p><table><thead><tr><th>序号</th><th>特性</th></tr></thead><tbody><tr><td>1</td><td><a href="https://blog.csdn.net/weixin_43664418/article/details/103091287" target="_blank" rel="noopener">Lambda 表达式</a></td></tr><tr><td>2</td><td><a href="https://blog.csdn.net/weixin_43664418/article/details/103091326" target="_blank" rel="noopener">方法引用</a></td></tr><tr><td>3</td><td><a href="https://blog.csdn.net/weixin_43664418/article/details/103091361" target="_blank" rel="noopener">函数式接口</a></td></tr><tr><td>4</td><td><a href="https://blog.csdn.net/weixin_43664418/article/details/103091418" target="_blank" rel="noopener">默认方法</a></td></tr><tr><td>5</td><td><a href="https://blog.csdn.net/weixin_43664418/article/details/103091453" target="_blank" rel="noopener">Stream</a></td></tr><tr><td>6</td><td><a href="https://blog.csdn.net/weixin_43664418/article/details/103091530" target="_blank" rel="noopener">Optional 类</a></td></tr><tr><td>7</td><td><a href="https://blog.csdn.net/weixin_43664418/article/details/103091552" target="_blank" rel="noopener">Nashorn, JavaScript 引擎</a></td></tr><tr><td>8</td><td><a href="https://blog.csdn.net/weixin_43664418/article/details/103091591" target="_blank" rel="noopener">新的日期时间 API</a></td></tr><tr><td>9</td><td><a href="https://blog.csdn.net/weixin_43664418/article/details/103091633" target="_blank" rel="noopener">Base64</a></td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Java 8 (又称为 jdk 1.8) 是 Java 语言开发的一个主要版本。 Oracle 公司于 2014 年 3 月 18 日发布 Java 8 ，它支持函数式编程，新的 JavaScript 引擎，新的日期 API，新的Stream API 等。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="Java" scheme="ayjcsgm.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>8、Spring Boot笔记整理高级篇-监控</title>
    <link href="ayjcsgm.github.io/2019/11/08/8%E3%80%81Spring-Boot%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86%E9%AB%98%E7%BA%A7%E7%AF%87-%E7%9B%91%E6%8E%A7/"/>
    <id>ayjcsgm.github.io/2019/11/08/8、Spring-Boot笔记整理高级篇-监控/</id>
    <published>2019-11-08T10:39:41.000Z</published>
    <updated>2019-12-14T11:29:22.761Z</updated>
    
    <content type="html"><![CDATA[<h1 id="八、Spring-Boot与监控管理"><a href="#八、Spring-Boot与监控管理" class="headerlink" title="八、Spring Boot与监控管理"></a>八、Spring Boot与监控管理</h1><h2 id="一、监控管理"><a href="#一、监控管理" class="headerlink" title="一、监控管理"></a>一、监控管理</h2><p>通过引入spring-boot-starter-actuator，可以使用Spring Boot为我们提供的准 生产环境下的应用监控和管理功能。我们可以通过HTTP，JMX，SSH协议来进 行操作，自动得到审计、健康及指标信息等</p><a id="more"></a><ul><li>步骤：<br>– 引入spring-boot-starter-actuator<br>– 通过http方式访问监控端点<br> – 可进行shutdown（POST 提交，此端点默认关闭）<ul><li>监控和管理端点<br><img src="https://img-blog.csdnimg.cn/20191108182131681.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzY2NDQxOA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><h2 id="二、定制端点信息"><a href="#二、定制端点信息" class="headerlink" title="二、定制端点信息"></a>二、定制端点信息</h2>– 定制端点一般通过endpoints+端点名+属性名来设置。<br>– 修改端点id（endpoints.beans.id=mybeans）<br>– 开启远程应用关闭功能（endpoints.shutdown.enabled=true）<br>– 关闭端点（endpoints.beans.enabled=false）<br>– 开启所需端点 </li><li>endpoints.enabled=false </li><li>endpoints.beans.enabled=true – 定制端点访问根路径 </li><li>management.context-path=/manage – 关闭http端点 </li><li>management.port=-1</li></ul></li></ul><p>pom.xml</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span>?&gt;</span><br><span class="line">&lt;project xmlns=<span class="string">"http://maven.apache.org/POM/4.0.0"</span> xmlns:xsi=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span><br><span class="line">xsi:schemaLocation=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span><br><span class="line">&lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</span><br><span class="line"></span><br><span class="line">&lt;groupId&gt;com.atguigu&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;springboot-08-actuator&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;</span><br><span class="line">&lt;packaging&gt;jar&lt;/packaging&gt;</span><br><span class="line"></span><br><span class="line">&lt;name&gt;springboot-08-actuator&lt;/name&gt;</span><br><span class="line">&lt;description&gt;Demo project for Spring Boot&lt;/description&gt;</span><br><span class="line"></span><br><span class="line">&lt;parent&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;1.5.12.RELEASE&lt;/version&gt;</span><br><span class="line">&lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;</span><br><span class="line">&lt;/parent&gt;</span><br><span class="line"></span><br><span class="line">&lt;properties&gt;</span><br><span class="line">&lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;</span><br><span class="line">&lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt;</span><br><span class="line">&lt;java.version&gt;1.8&lt;/java.version&gt;</span><br><span class="line">&lt;/properties&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependencies&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;</span><br><span class="line">&lt;scope&gt;runtime&lt;/scope&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;</span><br><span class="line">&lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br><span class="line"></span><br><span class="line">&lt;build&gt;</span><br><span class="line">&lt;plugins&gt;</span><br><span class="line">&lt;plugin&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;</span><br><span class="line">&lt;/plugin&gt;</span><br><span class="line">&lt;/plugins&gt;</span><br><span class="line">&lt;/build&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;/project&gt;</span><br></pre></td></tr></table></figure><p>application.properties</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">management.security.enabled=<span class="keyword">false</span></span><br><span class="line"></span><br><span class="line">spring.redis.host=<span class="number">118.24</span>.44.169</span><br><span class="line"></span><br><span class="line">info.app.id=hello</span><br><span class="line">info.app.version=<span class="number">1.0</span>.0</span><br><span class="line"></span><br><span class="line">#endpoints.metrics.enabled=false</span><br><span class="line">endpoints.shutdown.enabled=<span class="keyword">true</span></span><br><span class="line"></span><br><span class="line">#endpoints.beans.id=mybean</span><br><span class="line">#endpoints.beans.path=/bean</span><br><span class="line">#endpoints.beans.enabled=false</span><br><span class="line">#</span><br><span class="line">#endpoints.dump.path=/du</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># \u5173\u95ED\u6240\u6709\u7AEF\u70B9\u8BBF\u95EE</span><br><span class="line">#endpoints.enabled=false</span><br><span class="line">#endpoints.beans.enabled=true</span><br><span class="line"></span><br><span class="line">management.context-path=/manage</span><br><span class="line"></span><br><span class="line">management.port=<span class="number">8181</span></span><br></pre></td></tr></table></figure><p>git.properties</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git.branch=master</span><br><span class="line">git.commit.id=xjkd33s</span><br><span class="line">git.commit.time=<span class="number">2017</span>-<span class="number">12</span>-<span class="number">12</span> <span class="number">12</span>:<span class="number">12</span>:<span class="number">56</span></span><br></pre></td></tr></table></figure><p>Springboot08ActuatorApplication.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.springboot08actuator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义健康状态指示器</span></span><br><span class="line"><span class="comment"> * 1、编写一个指示器 实现 HealthIndicator 接口</span></span><br><span class="line"><span class="comment"> * 2、指示器的名字 xxxxHealthIndicator</span></span><br><span class="line"><span class="comment"> * 3、加入容器中</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Springboot08ActuatorApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">SpringApplication.run(Springboot08ActuatorApplication.class, args);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>MyAppHealthIndicator.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.springboot08actuator.health;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.actuate.health.Health;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.actuate.health.HealthIndicator;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyAppHealthIndicator</span> <span class="keyword">implements</span> <span class="title">HealthIndicator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Health <span class="title">health</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//自定义的检查方法</span></span><br><span class="line">        <span class="comment">//Health.up().build()代表健康</span></span><br><span class="line">        <span class="keyword">return</span> Health.down().withDetail(<span class="string">"msg"</span>,<span class="string">"服务异常"</span>).build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;八、Spring-Boot与监控管理&quot;&gt;&lt;a href=&quot;#八、Spring-Boot与监控管理&quot; class=&quot;headerlink&quot; title=&quot;八、Spring Boot与监控管理&quot;&gt;&lt;/a&gt;八、Spring Boot与监控管理&lt;/h1&gt;&lt;h2 id=&quot;一、监控管理&quot;&gt;&lt;a href=&quot;#一、监控管理&quot; class=&quot;headerlink&quot; title=&quot;一、监控管理&quot;&gt;&lt;/a&gt;一、监控管理&lt;/h2&gt;&lt;p&gt;通过引入spring-boot-starter-actuator，可以使用Spring Boot为我们提供的准 生产环境下的应用监控和管理功能。我们可以通过HTTP，JMX，SSH协议来进 行操作，自动得到审计、健康及指标信息等&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="Spring Boot" scheme="ayjcsgm.github.io/tags/Spring-Boot/"/>
    
  </entry>
  
  <entry>
    <title>7、Spring Boot笔记整理高级篇-热部署</title>
    <link href="ayjcsgm.github.io/2019/11/08/7%E3%80%81Spring-Boot%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86%E9%AB%98%E7%BA%A7%E7%AF%87-%E7%83%AD%E9%83%A8%E7%BD%B2/"/>
    <id>ayjcsgm.github.io/2019/11/08/7、Spring-Boot笔记整理高级篇-热部署/</id>
    <published>2019-11-08T10:39:24.000Z</published>
    <updated>2019-12-14T11:28:30.722Z</updated>
    
    <content type="html"><![CDATA[<h1 id="七、Spring-Boot与开发热部署"><a href="#七、Spring-Boot与开发热部署" class="headerlink" title="七、Spring Boot与开发热部署"></a>七、Spring Boot与开发热部署</h1><p><strong>热部署</strong></p><h2 id="一、热部署"><a href="#一、热部署" class="headerlink" title="一、热部署"></a>一、热部署</h2><p>在开发中我们修改一个Java文件后想看到效果不得不重启应用，这导致大量时间 花费，我们希望不重启应用的情况下，程序可以自动部署（热部署）。有以下四 种情况，如何能实现热部署。</p><a id="more"></a><ul><li>1、模板引擎<br>– 在Spring Boot中开发情况下禁用模板引擎的cache<br>– 页面模板改变ctrl+F9可以重新编译当前页面并生效</li><li>2、Spring Loaded<br>Spring官方提供的热部署程序，实现修改类文件的热部署<br>– 下载Spring Loaded（项目地址<a href="https://github.com/springprojects/spring-loaded）" target="_blank" rel="noopener">https://github.com/springprojects/spring-loaded）</a><br>– 添加运行时参数；<br>– javaagent:C:/springloaded-1.2.5.RELEASE.jar –noverify</li><li>3、JRebel<br>– 收费的一个热部署软件<br>– 安装插件使用即可</li><li>4、Spring Boot Devtools（推荐）<br>– 引入依赖</li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;  </span><br><span class="line">&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;  </span><br><span class="line">&lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; </span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>– IDEA使用ctrl+F9<br>– 或做一些小调整 Intellij IEDA 和 Eclipse 不同， Eclipse 设置了自动编译之后，修改类它会自动编译 ，而 IDEA 在非 RUN 或 DEBUG 情况下 才会自动编译（前提是你已经设置了 Auto - Compile ）。 </p><ul><li>设置自动编译（settings-compiler-make project automatically） </li><li>ctrl+shift+alt+/（maintenance） </li><li>勾选compiler.automake.allow.when.app.running</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.deploy.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Controller;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/abc"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"hello"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;七、Spring-Boot与开发热部署&quot;&gt;&lt;a href=&quot;#七、Spring-Boot与开发热部署&quot; class=&quot;headerlink&quot; title=&quot;七、Spring Boot与开发热部署&quot;&gt;&lt;/a&gt;七、Spring Boot与开发热部署&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;热部署&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;一、热部署&quot;&gt;&lt;a href=&quot;#一、热部署&quot; class=&quot;headerlink&quot; title=&quot;一、热部署&quot;&gt;&lt;/a&gt;一、热部署&lt;/h2&gt;&lt;p&gt;在开发中我们修改一个Java文件后想看到效果不得不重启应用，这导致大量时间 花费，我们希望不重启应用的情况下，程序可以自动部署（热部署）。有以下四 种情况，如何能实现热部署。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="Spring Boot" scheme="ayjcsgm.github.io/tags/Spring-Boot/"/>
    
  </entry>
  
  <entry>
    <title>6、Spring Boot笔记整理高级篇-分布式</title>
    <link href="ayjcsgm.github.io/2019/11/08/6%E3%80%81Spring-Boot%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86%E9%AB%98%E7%BA%A7%E7%AF%87-%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    <id>ayjcsgm.github.io/2019/11/08/6、Spring-Boot笔记整理高级篇-分布式/</id>
    <published>2019-11-08T10:39:06.000Z</published>
    <updated>2019-12-14T11:29:56.730Z</updated>
    
    <content type="html"><![CDATA[<h1 id="六、Spring-Boot与分布式"><a href="#六、Spring-Boot与分布式" class="headerlink" title="六、Spring Boot与分布式"></a>六、Spring Boot与分布式</h1><p><strong>分步式、Dubbo/Zookeeper、Spring Boot/Cloud</strong></p><h2 id="一、分布式应用"><a href="#一、分布式应用" class="headerlink" title="一、分布式应用"></a>一、分布式应用</h2><p>在分布式系统中，国内常用zookeeper+dubbo组合，而Spring Boot推荐使用 全栈的Spring，Spring Boot+Spring Cloud。</p><p>分布式系统：<a id="more"></a><br><img src="https://img-blog.csdnimg.cn/20191108175505773.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzY2NDQxOA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ul><li><p>单一应用架构 当网站流量很小时，只需一个应用，将所有功能都部署在一起，以减少部署节点和成 本。此时，用于简化增删改查工作量的数据访问框架(ORM)是关键。 </p></li><li><p>垂直应用架构 当访问量逐渐增大，单一应用增加机器带来的加速度越来越小，将应用拆成互不相干 的几个应用，以提升效率。此时，用于加速前端页面开发的Web框架(MVC)是关键。 </p></li><li><p>分布式服务架构 当垂直应用越来越多，应用之间交互不可避免，将核心业务抽取出来，作为独立的服 务，逐渐形成稳定的服务中心，使前端应用能更快速的响应多变的市场需求。此时， 用于提高业务复用及整合的分布式服务框架(RPC)是关键。 </p></li><li><p>流动计算架构 当服务越来越多，容量的评估，小服务资源的浪费等问题逐渐显现，此时需增加一个 调度中心基于访问压力实时管理集群容量，提高集群利用率。此时，用于提高机器利 用率的资源调度和治理中心(SOA)是关键。</p><h2 id="二、Zookeeper和Dubbo"><a href="#二、Zookeeper和Dubbo" class="headerlink" title="二、Zookeeper和Dubbo"></a>二、Zookeeper和Dubbo</h2></li><li><p>ZooKeeper<br>ZooKeeper 是一个分布式的，开放源码的分布式应用程序协调服务。它是 一个为分布式应用提供一致性服务的软件，提供的功能包括：配置维护、 域名服务、分布式同步、组服务等。 </p></li><li><p>Dubbo<br>Dubbo是Alibaba开源的分布式服务框架，它最大的特点是按照分层的方 式来架构，使用这种方式可以使各个层之间解耦合（或者最大限度地松耦 合）。从服务模型的角度来看，Dubbo采用的是一种非常简单的模型，要 么是提供方提供服务，要么是消费方消费服务，所以基于这一点可以抽象 出服务提供方（Provider）和服务消费方（Consumer）两个角色。<br><img src="https://img-blog.csdnimg.cn/20191108175655839.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzY2NDQxOA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ul><li>1、安装zookeeper作为注册中心 </li><li>2、编写服务提供者 </li><li>3、编写服务消费者</li><li>4、整合dubbo </li></ul></li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt; </span><br><span class="line"> &lt;groupId&gt;com.alibaba.spring.boot&lt;/groupId&gt; </span><br><span class="line"> &lt;artifactId&gt;dubbo-spring-boot-starter&lt;/artifactId&gt; </span><br><span class="line"> &lt;version&gt;2.0.0&lt;/version&gt; </span><br><span class="line"> &lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p><strong>application.properties</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dubbo.application.name=consumer-user</span><br><span class="line"></span><br><span class="line">dubbo.registry.address=zookeeper:<span class="comment">//118.24.44.169:2181</span></span><br></pre></td></tr></table></figure><h2 id="三、Spring-Boot和Spring-Cloud"><a href="#三、Spring-Boot和Spring-Cloud" class="headerlink" title="三、Spring Boot和Spring Cloud"></a>三、Spring Boot和Spring Cloud</h2><p><strong>Spring Cloud</strong><br>Spring Cloud是一个分布式的整体解决方案。Spring Cloud 为开发者提供了在<strong>分布式系统（配 置管理，服务发现，熔断，路由，微代理，控制总线，一次性token，全局琐，leader选举，分 布式session，集群状态）中快速构建的工具</strong>，使用Spring Cloud的开发者可以快速的启动服务 或构建应用、同时能够快速和云平台资源进行对接。</p><ul><li>SpringCloud分布式开发五大常用组件 <pre><code>* 服务发现——Netflix Eureka * 客服端负载均衡——Netflix Ribbon * 断路器——Netflix Hystrix* 服务网关——Netflix Zuul * 分布式配置——Spring Cloud Config</code></pre></li></ul><p><strong>微服务</strong><br><img src="https://img-blog.csdnimg.cn/20191108180120914.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzY2NDQxOA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ul><li>Spring Cloud 入门<br>– 1、创建provider </li></ul><p>pom.xml</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span>?&gt;</span><br><span class="line">&lt;project xmlns=<span class="string">"http://maven.apache.org/POM/4.0.0"</span> xmlns:xsi=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span><br><span class="line">xsi:schemaLocation=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span><br><span class="line">&lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</span><br><span class="line"></span><br><span class="line">&lt;groupId&gt;com.atguigu&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;provider-ticket&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;</span><br><span class="line">&lt;packaging&gt;jar&lt;/packaging&gt;</span><br><span class="line"></span><br><span class="line">&lt;name&gt;provider-ticket&lt;/name&gt;</span><br><span class="line">&lt;description&gt;Demo project for Spring Boot&lt;/description&gt;</span><br><span class="line"></span><br><span class="line">&lt;parent&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;1.5.12.RELEASE&lt;/version&gt;</span><br><span class="line">&lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;</span><br><span class="line">&lt;/parent&gt;</span><br><span class="line"></span><br><span class="line">&lt;properties&gt;</span><br><span class="line">&lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;</span><br><span class="line">&lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt;</span><br><span class="line">&lt;java.version&gt;1.8&lt;/java.version&gt;</span><br><span class="line">&lt;spring-cloud.version&gt;Edgware.SR3&lt;/spring-cloud.version&gt;</span><br><span class="line">&lt;/properties&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependencies&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-cloud-starter-eureka&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;</span><br><span class="line">&lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependencyManagement&gt;</span><br><span class="line">&lt;dependencies&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;$&#123;spring-cloud.version&#125;&lt;/version&gt;</span><br><span class="line">&lt;type&gt;pom&lt;/type&gt;</span><br><span class="line">&lt;scope&gt;import&lt;/scope&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br><span class="line">&lt;/dependencyManagement&gt;</span><br><span class="line"></span><br><span class="line">&lt;build&gt;</span><br><span class="line">&lt;plugins&gt;</span><br><span class="line">&lt;plugin&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;</span><br><span class="line">&lt;/plugin&gt;</span><br><span class="line">&lt;/plugins&gt;</span><br><span class="line">&lt;/build&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;/project&gt;</span><br></pre></td></tr></table></figure><p>application.yml</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: <span class="number">8002</span></span><br><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: provider-ticket</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">eureka:</span><br><span class="line">  instance:</span><br><span class="line">    prefer-ip-address: true # 注册服务的时候使用服务的ip地址</span><br><span class="line">  client:</span><br><span class="line">    service-url:</span><br><span class="line">      defaultZone: http:<span class="comment">//localhost:8761/eureka/</span></span><br></pre></td></tr></table></figure><p>service</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.providerticket.service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TicketService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getTicket</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"8002"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"《厉害了，我的国》"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>controller</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.providerticket.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.atguigu.providerticket.service.TicketService;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TicketController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    TicketService ticketService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/ticket"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getTicket</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ticketService.getTicket();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>– 2、创建consumer </p><p>pom.xml</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span>?&gt;</span><br><span class="line">&lt;project xmlns=<span class="string">"http://maven.apache.org/POM/4.0.0"</span> xmlns:xsi=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span><br><span class="line">xsi:schemaLocation=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span><br><span class="line">&lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</span><br><span class="line"></span><br><span class="line">&lt;groupId&gt;com.atguigu&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;consumer-user&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;</span><br><span class="line">&lt;packaging&gt;jar&lt;/packaging&gt;</span><br><span class="line"></span><br><span class="line">&lt;name&gt;consumer-user&lt;/name&gt;</span><br><span class="line">&lt;description&gt;Demo project for Spring Boot&lt;/description&gt;</span><br><span class="line"></span><br><span class="line">&lt;parent&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;1.5.12.RELEASE&lt;/version&gt;</span><br><span class="line">&lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;</span><br><span class="line">&lt;/parent&gt;</span><br><span class="line"></span><br><span class="line">&lt;properties&gt;</span><br><span class="line">&lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;</span><br><span class="line">&lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt;</span><br><span class="line">&lt;java.version&gt;1.8&lt;/java.version&gt;</span><br><span class="line">&lt;spring-cloud.version&gt;Edgware.SR3&lt;/spring-cloud.version&gt;</span><br><span class="line">&lt;/properties&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependencies&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-cloud-starter-eureka&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;</span><br><span class="line">&lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependencyManagement&gt;</span><br><span class="line">&lt;dependencies&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;$&#123;spring-cloud.version&#125;&lt;/version&gt;</span><br><span class="line">&lt;type&gt;pom&lt;/type&gt;</span><br><span class="line">&lt;scope&gt;import&lt;/scope&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br><span class="line">&lt;/dependencyManagement&gt;</span><br><span class="line"></span><br><span class="line">&lt;build&gt;</span><br><span class="line">&lt;plugins&gt;</span><br><span class="line">&lt;plugin&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;</span><br><span class="line">&lt;/plugin&gt;</span><br><span class="line">&lt;/plugins&gt;</span><br><span class="line">&lt;/build&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;/project&gt;</span><br></pre></td></tr></table></figure><p>application.yml</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: consumer-user</span><br><span class="line">server:</span><br><span class="line">  port: <span class="number">8200</span></span><br><span class="line"></span><br><span class="line">eureka:</span><br><span class="line">  instance:</span><br><span class="line">    prefer-ip-address: true # 注册服务的时候使用服务的ip地址</span><br><span class="line">  client:</span><br><span class="line">    service-url:</span><br><span class="line">      defaultZone: http:<span class="comment">//localhost:8761/eureka/</span></span><br></pre></td></tr></table></figure><p>controller</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.consumeruser.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.client.RestTemplate;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    RestTemplate restTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/buy"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">buyTicket</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        String s = restTemplate.getForObject(<span class="string">"http://PROVIDER-TICKET/ticket"</span>, String.class);</span><br><span class="line">        <span class="keyword">return</span> name+<span class="string">"购买了"</span>+s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ConsumerUserApplication.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.consumeruser;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.client.discovery.EnableDiscoveryClient;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.client.loadbalancer.LoadBalanced;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.client.RestTemplate;</span><br><span class="line"></span><br><span class="line"><span class="meta">@EnableDiscoveryClient</span> <span class="comment">//开启发现服务功能</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConsumerUserApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">SpringApplication.run(ConsumerUserApplication.class, args);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@LoadBalanced</span> <span class="comment">//使用负载均衡机制</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> RestTemplate <span class="title">restTemplate</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> RestTemplate();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>– 3、引入Spring Cloud </p><p>pom.xml</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span>?&gt;</span><br><span class="line">&lt;project xmlns=<span class="string">"http://maven.apache.org/POM/4.0.0"</span> xmlns:xsi=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span><br><span class="line">xsi:schemaLocation=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span><br><span class="line">&lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</span><br><span class="line"></span><br><span class="line">&lt;groupId&gt;com.atguigu&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;eureka-server&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;</span><br><span class="line">&lt;packaging&gt;jar&lt;/packaging&gt;</span><br><span class="line"></span><br><span class="line">&lt;name&gt;eureka-server&lt;/name&gt;</span><br><span class="line">&lt;description&gt;Demo project for Spring Boot&lt;/description&gt;</span><br><span class="line"></span><br><span class="line">&lt;parent&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;1.5.12.RELEASE&lt;/version&gt;</span><br><span class="line">&lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;</span><br><span class="line">&lt;/parent&gt;</span><br><span class="line"></span><br><span class="line">&lt;properties&gt;</span><br><span class="line">&lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;</span><br><span class="line">&lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt;</span><br><span class="line">&lt;java.version&gt;1.8&lt;/java.version&gt;</span><br><span class="line">&lt;spring-cloud.version&gt;Edgware.SR3&lt;/spring-cloud.version&gt;</span><br><span class="line">&lt;/properties&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependencies&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-cloud-starter-eureka-server&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;</span><br><span class="line">&lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependencyManagement&gt;</span><br><span class="line">&lt;dependencies&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;$&#123;spring-cloud.version&#125;&lt;/version&gt;</span><br><span class="line">&lt;type&gt;pom&lt;/type&gt;</span><br><span class="line">&lt;scope&gt;import&lt;/scope&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br><span class="line">&lt;/dependencyManagement&gt;</span><br><span class="line"></span><br><span class="line">&lt;build&gt;</span><br><span class="line">&lt;plugins&gt;</span><br><span class="line">&lt;plugin&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;</span><br><span class="line">&lt;/plugin&gt;</span><br><span class="line">&lt;/plugins&gt;</span><br><span class="line">&lt;/build&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;/project&gt;</span><br></pre></td></tr></table></figure><p>– 4、引入Eureka注册中心</p><p>application.yml</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: <span class="number">8761</span></span><br><span class="line">eureka:</span><br><span class="line">  instance:</span><br><span class="line">    hostname: eureka-server  # eureka实例的主机名</span><br><span class="line">  client:</span><br><span class="line">    register-with-eureka: false #不把自己注册到eureka上</span><br><span class="line">    fetch-registry: false #不从eureka上来获取服务的注册信息</span><br><span class="line">    service-url:</span><br><span class="line">      defaultZone: http:<span class="comment">//localhost:8761/eureka/</span></span><br></pre></td></tr></table></figure><p>EurekaServerApplication.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.eurekaserver;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.netflix.eureka.server.EnableEurekaServer;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 注册中心</span></span><br><span class="line"><span class="comment"> * 1、配置Eureka信息</span></span><br><span class="line"><span class="comment"> * 2、<span class="doctag">@EnableEurekaServer</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@EnableEurekaServer</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EurekaServerApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">SpringApplication.run(EurekaServerApplication.class, args);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>– 5、引入Ribbon进行客户端负载均衡</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;六、Spring-Boot与分布式&quot;&gt;&lt;a href=&quot;#六、Spring-Boot与分布式&quot; class=&quot;headerlink&quot; title=&quot;六、Spring Boot与分布式&quot;&gt;&lt;/a&gt;六、Spring Boot与分布式&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;分步式、Dubbo/Zookeeper、Spring Boot/Cloud&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;一、分布式应用&quot;&gt;&lt;a href=&quot;#一、分布式应用&quot; class=&quot;headerlink&quot; title=&quot;一、分布式应用&quot;&gt;&lt;/a&gt;一、分布式应用&lt;/h2&gt;&lt;p&gt;在分布式系统中，国内常用zookeeper+dubbo组合，而Spring Boot推荐使用 全栈的Spring，Spring Boot+Spring Cloud。&lt;/p&gt;
&lt;p&gt;分布式系统：
    
    </summary>
    
    
    
      <category term="Spring Boot" scheme="ayjcsgm.github.io/tags/Spring-Boot/"/>
    
  </entry>
  
  <entry>
    <title>5、Spring Boot笔记整理高级篇-安全</title>
    <link href="ayjcsgm.github.io/2019/11/08/5%E3%80%81Spring-Boot%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86%E9%AB%98%E7%BA%A7%E7%AF%87-%E5%AE%89%E5%85%A8/"/>
    <id>ayjcsgm.github.io/2019/11/08/5、Spring-Boot笔记整理高级篇-安全/</id>
    <published>2019-11-08T10:38:42.000Z</published>
    <updated>2019-12-14T11:30:26.394Z</updated>
    
    <content type="html"><![CDATA[<h1 id="五、Spring-Boot与安全"><a href="#五、Spring-Boot与安全" class="headerlink" title="五、Spring Boot与安全"></a>五、Spring Boot与安全</h1><p><strong>安全、Spring Security</strong></p><h2 id="一、安全"><a href="#一、安全" class="headerlink" title="一、安全"></a>一、安全</h2><p>Spring Security是针对Spring项目的安全框架，也是Spring Boot底层安全模 块默认的技术选型。他可以实现强大的web安全控制。对于安全控制，我们仅 需引入spring-boot-starter-security模块，进行少量的配置，即可实现强大的 安全管理。</p><p>几个类：<a id="more"></a><br> WebSecurityConfigurerAdapter：自定义Security策略 AuthenticationManagerBuilder：自定义认证策略<br> @EnableWebSecurity：开启WebSecurity模式</p><ul><li>应用程序的两个主要区域是“认证”和“授权”（或者访问控制）。 这两个主要区域是Spring Security 的两个目标。</li><li>“认证”（Authentication），是建立一个他声明的主体的过程（一 个“主体”一般是指用户，设备或一些可以在你的应用程序中执行动 作的其他系统）。</li><li>“授权”（Authorization）指确定一个主体是否允许在你的应用程序 执行一个动作的过程。为了抵达需要授权的店，主体的身份已经有认 证过程建立。</li><li>这个概念是通用的而不只在Spring Security中。<h2 id="二、Web-amp-安全"><a href="#二、Web-amp-安全" class="headerlink" title="二、Web&amp;安全"></a>二、Web&amp;安全</h2></li></ul><ol><li>登陆/注销<br>– HttpSecurity配置登陆、注销功能 </li><li>Thymeleaf提供的SpringSecurity标签支持<br>– 需要引入thymeleaf-extras-springsecurity4<br>– sec:authentication=“name”获得当前用户的用户名<br>– sec:authorize=“hasRole(‘ADMIN’)”当前用户必须拥有ADMIN权限时才会显示标签内容 </li><li>remember me<br>– 表单添加remember-me的checkbox<br>– 配置启用remember-me功能 </li><li>CSRF（Cross-site request forgery）跨站请求伪造<br>– HttpSecurity启用csrf功能，会为表单添加_csrf的值，提交携带来预防CSRF；</li></ol><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span>?&gt;</span><br><span class="line">&lt;project xmlns=<span class="string">"http://maven.apache.org/POM/4.0.0"</span> xmlns:xsi=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span><br><span class="line">xsi:schemaLocation=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span><br><span class="line">&lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</span><br><span class="line"></span><br><span class="line">&lt;groupId&gt;com.atguigu&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;springboot-05-security&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;</span><br><span class="line">&lt;packaging&gt;jar&lt;/packaging&gt;</span><br><span class="line"></span><br><span class="line">&lt;name&gt;springboot-05-security&lt;/name&gt;</span><br><span class="line">&lt;description&gt;Demo project for Spring Boot&lt;/description&gt;</span><br><span class="line"></span><br><span class="line">&lt;parent&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;1.5.12.RELEASE&lt;/version&gt;</span><br><span class="line">&lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;</span><br><span class="line">&lt;/parent&gt;</span><br><span class="line"></span><br><span class="line">&lt;properties&gt;</span><br><span class="line">&lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;</span><br><span class="line">&lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt;</span><br><span class="line">&lt;java.version&gt;1.8&lt;/java.version&gt;</span><br><span class="line">&lt;thymeleaf.version&gt;3.0.9.RELEASE&lt;/thymeleaf.version&gt;</span><br><span class="line">&lt;thymeleaf-layout-dialect.version&gt;2.3.0&lt;/thymeleaf-layout-dialect.version&gt;</span><br><span class="line">&lt;thymeleaf-extras-springsecurity4.version&gt;3.0.2.RELEASE&lt;/thymeleaf-extras-springsecurity4.version&gt;</span><br><span class="line">&lt;/properties&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependencies&gt;</span><br><span class="line">&lt;!-- https:<span class="comment">//mvnrepository.com/artifact/org.thymeleaf.extras/thymeleaf-extras-springsecurity4 --&gt;</span></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.thymeleaf.extras&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;thymeleaf-extras-springsecurity4&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;</span><br><span class="line">&lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br><span class="line"></span><br><span class="line">&lt;build&gt;</span><br><span class="line">&lt;plugins&gt;</span><br><span class="line">&lt;plugin&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;</span><br><span class="line">&lt;/plugin&gt;</span><br><span class="line">&lt;/plugins&gt;</span><br><span class="line">&lt;/build&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;/project&gt;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.security;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 1、引入SpringSecurity；</span></span><br><span class="line"><span class="comment"> * 2、编写SpringSecurity的配置类；</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@EnableWebSecurity</span>   extends WebSecurityConfigurerAdapter</span></span><br><span class="line"><span class="comment"> * 3、控制请求的访问权限：</span></span><br><span class="line"><span class="comment"> * configure(HttpSecurity http) &#123;</span></span><br><span class="line"><span class="comment"> *  http.authorizeRequests().antMatchers("/").permitAll()</span></span><br><span class="line"><span class="comment"> *  .antMatchers("/level1/**").hasRole("VIP1")</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> * 4、定义认证规则：</span></span><br><span class="line"><span class="comment"> * configure(AuthenticationManagerBuilder auth)&#123;</span></span><br><span class="line"><span class="comment"> *  auth.inMemoryAuthentication()</span></span><br><span class="line"><span class="comment"> *  .withUser("zhangsan").password("123456").roles("VIP1","VIP2")</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> * 5、开启自动配置的登陆功能：</span></span><br><span class="line"><span class="comment"> * configure(HttpSecurity http)&#123;</span></span><br><span class="line"><span class="comment"> *  http.formLogin();</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> * 6、注销：http.logout();</span></span><br><span class="line"><span class="comment"> * 7、记住我：Remeberme()；</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Springboot05SecurityApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">SpringApplication.run(Springboot05SecurityApplication.class, args);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.security.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Controller;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.PathVariable;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KungfuController</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> String PREFIX = <span class="string">"pages/"</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 欢迎页</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">index</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"welcome"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 登陆页</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/userlogin"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">loginPage</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> PREFIX+<span class="string">"login"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * level1页面映射</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> path</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/level1/&#123;path&#125;"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">level1</span><span class="params">(@PathVariable(<span class="string">"path"</span>)</span>String path) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> PREFIX+<span class="string">"level1/"</span>+path;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * level2页面映射</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> path</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/level2/&#123;path&#125;"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">level2</span><span class="params">(@PathVariable(<span class="string">"path"</span>)</span>String path) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> PREFIX+<span class="string">"level2/"</span>+path;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * level3页面映射</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> path</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/level3/&#123;path&#125;"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">level3</span><span class="params">(@PathVariable(<span class="string">"path"</span>)</span>String path) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> PREFIX+<span class="string">"level3/"</span>+path;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.security.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.config.annotation.web.builders.HttpSecurity;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;</span><br><span class="line"></span><br><span class="line"><span class="meta">@EnableWebSecurity</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MySecurityConfig</span> <span class="keyword">extends</span> <span class="title">WebSecurityConfigurerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//super.configure(http);</span></span><br><span class="line">        <span class="comment">//定制请求的授权规则</span></span><br><span class="line">        http.authorizeRequests().antMatchers(<span class="string">"/"</span>).permitAll()</span><br><span class="line">                .antMatchers(<span class="string">"/level1/**"</span>).hasRole(<span class="string">"VIP1"</span>)</span><br><span class="line">                .antMatchers(<span class="string">"/level2/**"</span>).hasRole(<span class="string">"VIP2"</span>)</span><br><span class="line">                .antMatchers(<span class="string">"/level3/**"</span>).hasRole(<span class="string">"VIP3"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//开启自动配置的登陆功能，效果，如果没有登陆，没有权限就会来到登陆页面</span></span><br><span class="line">        http.formLogin().usernameParameter(<span class="string">"user"</span>).passwordParameter(<span class="string">"pwd"</span>)</span><br><span class="line">                .loginPage(<span class="string">"/userlogin"</span>);</span><br><span class="line">        <span class="comment">//1、/login来到登陆页</span></span><br><span class="line">        <span class="comment">//2、重定向到/login?error表示登陆失败</span></span><br><span class="line">        <span class="comment">//3、更多详细规定</span></span><br><span class="line">        <span class="comment">//4、默认post形式的 /login代表处理登陆</span></span><br><span class="line">        <span class="comment">//5、一但定制loginPage；那么 loginPage的post请求就是登陆</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//开启自动配置的注销功能。</span></span><br><span class="line">        http.logout().logoutSuccessUrl(<span class="string">"/"</span>);<span class="comment">//注销成功以后来到首页</span></span><br><span class="line">        <span class="comment">//1、访问 /logout 表示用户注销，清空session</span></span><br><span class="line">        <span class="comment">//2、注销成功会返回 /login?logout 页面；</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//开启记住我功能</span></span><br><span class="line">        http.rememberMe().rememberMeParameter(<span class="string">"remeber"</span>);</span><br><span class="line">        <span class="comment">//登陆成功以后，将cookie发给浏览器保存，以后访问页面带上这个cookie，只要通过检查就可以免登录</span></span><br><span class="line">        <span class="comment">//点击注销会删除cookie</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义认证规则</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(AuthenticationManagerBuilder auth)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//super.configure(auth);</span></span><br><span class="line">        auth.inMemoryAuthentication()</span><br><span class="line">                .withUser(<span class="string">"zhangsan"</span>).password(<span class="string">"123456"</span>).roles(<span class="string">"VIP1"</span>,<span class="string">"VIP2"</span>)</span><br><span class="line">                .and()</span><br><span class="line">                .withUser(<span class="string">"lisi"</span>).password(<span class="string">"123456"</span>).roles(<span class="string">"VIP2"</span>,<span class="string">"VIP3"</span>)</span><br><span class="line">                .and()</span><br><span class="line">                .withUser(<span class="string">"wangwu"</span>).password(<span class="string">"123456"</span>).roles(<span class="string">"VIP1"</span>,<span class="string">"VIP3"</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>HTML</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html xmlns:th=<span class="string">"http://www.thymeleaf.org"</span></span><br><span class="line">  xmlns:sec=<span class="string">"http://www.thymeleaf.org/thymeleaf-extras-springsecurity4"</span>&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta http-equiv=<span class="string">"Content-Type"</span> content=<span class="string">"text/html; charset=UTF-8"</span>&gt;</span><br><span class="line">&lt;title&gt;Insert title here&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;h1 align="center"&gt;欢迎光临武林秘籍管理系统&lt;/h1&gt;</span><br><span class="line">&lt;div sec:authorize=<span class="string">"!isAuthenticated()"</span>&gt;</span><br><span class="line">&lt;h2 align="center"&gt;游客您好，如果想查看武林秘籍 &lt;a th:href="@&#123;/userlogin&#125;"&gt;请登录&lt;/a&gt;&lt;/h2&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;div sec:authorize=<span class="string">"isAuthenticated()"</span>&gt;</span><br><span class="line">&lt;h2&gt;&lt;span sec:authentication="name"&gt;&lt;/span&gt;，您好,您的角色有：</span><br><span class="line">&lt;span sec:authentication="principal.authorities"&gt;&lt;/span&gt;&lt;/h2&gt;</span><br><span class="line">&lt;form th:action=<span class="string">"@&#123;/logout&#125;"</span> method=<span class="string">"post"</span>&gt;</span><br><span class="line">&lt;input type=<span class="string">"submit"</span> value=<span class="string">"注销"</span>/&gt;</span><br><span class="line">&lt;/form&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;hr&gt;</span><br><span class="line"></span><br><span class="line">&lt;div sec:authorize=<span class="string">"hasRole('VIP1')"</span>&gt;</span><br><span class="line">&lt;h3&gt;普通武功秘籍&lt;/h3&gt;</span><br><span class="line">&lt;ul&gt;</span><br><span class="line">&lt;li&gt;&lt;a th:href="@&#123;/level1/1&#125;"&gt;罗汉拳&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">&lt;li&gt;&lt;a th:href="@&#123;/level1/2&#125;"&gt;武当长拳&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">&lt;li&gt;&lt;a th:href="@&#123;/level1/3&#125;"&gt;全真剑法&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line"></span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;div sec:authorize=<span class="string">"hasRole('VIP2')"</span>&gt;</span><br><span class="line">&lt;h3&gt;高级武功秘籍&lt;/h3&gt;</span><br><span class="line">&lt;ul&gt;</span><br><span class="line">&lt;li&gt;&lt;a th:href="@&#123;/level2/1&#125;"&gt;太极拳&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">&lt;li&gt;&lt;a th:href="@&#123;/level2/2&#125;"&gt;七伤拳&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">&lt;li&gt;&lt;a th:href="@&#123;/level2/3&#125;"&gt;梯云纵&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line"></span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;div sec:authorize=<span class="string">"hasRole('VIP3')"</span>&gt;</span><br><span class="line">&lt;h3&gt;绝世武功秘籍&lt;/h3&gt;</span><br><span class="line">&lt;ul&gt;</span><br><span class="line">&lt;li&gt;&lt;a th:href="@&#123;/level3/1&#125;"&gt;葵花宝典&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">&lt;li&gt;&lt;a th:href="@&#123;/level3/2&#125;"&gt;龟派气功&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">&lt;li&gt;&lt;a th:href="@&#123;/level3/3&#125;"&gt;独孤九剑&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html xmlns:th=<span class="string">"http://www.thymeleaf.org"</span></span><br><span class="line">  xmlns:sec=<span class="string">"http://www.thymeleaf.org/thymeleaf-extras-springsecurity4"</span>&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta http-equiv=<span class="string">"Content-Type"</span> content=<span class="string">"text/html; charset=UTF-8"</span>&gt;</span><br><span class="line">&lt;title&gt;Insert title here&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;h1 align="center"&gt;欢迎光临武林秘籍管理系统&lt;/h1&gt;</span><br><span class="line">&lt;div sec:authorize=<span class="string">"!isAuthenticated()"</span>&gt;</span><br><span class="line">&lt;h2 align="center"&gt;游客您好，如果想查看武林秘籍 &lt;a th:href="@&#123;/userlogin&#125;"&gt;请登录&lt;/a&gt;&lt;/h2&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;div sec:authorize=<span class="string">"isAuthenticated()"</span>&gt;</span><br><span class="line">&lt;h2&gt;&lt;span sec:authentication="name"&gt;&lt;/span&gt;，您好,您的角色有：</span><br><span class="line">&lt;span sec:authentication="principal.authorities"&gt;&lt;/span&gt;&lt;/h2&gt;</span><br><span class="line">&lt;form th:action=<span class="string">"@&#123;/logout&#125;"</span> method=<span class="string">"post"</span>&gt;</span><br><span class="line">&lt;input type=<span class="string">"submit"</span> value=<span class="string">"注销"</span>/&gt;</span><br><span class="line">&lt;/form&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;hr&gt;</span><br><span class="line"></span><br><span class="line">&lt;div sec:authorize=<span class="string">"hasRole('VIP1')"</span>&gt;</span><br><span class="line">&lt;h3&gt;普通武功秘籍&lt;/h3&gt;</span><br><span class="line">&lt;ul&gt;</span><br><span class="line">&lt;li&gt;&lt;a th:href="@&#123;/level1/1&#125;"&gt;罗汉拳&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">&lt;li&gt;&lt;a th:href="@&#123;/level1/2&#125;"&gt;武当长拳&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">&lt;li&gt;&lt;a th:href="@&#123;/level1/3&#125;"&gt;全真剑法&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line"></span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;div sec:authorize=<span class="string">"hasRole('VIP2')"</span>&gt;</span><br><span class="line">&lt;h3&gt;高级武功秘籍&lt;/h3&gt;</span><br><span class="line">&lt;ul&gt;</span><br><span class="line">&lt;li&gt;&lt;a th:href="@&#123;/level2/1&#125;"&gt;太极拳&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">&lt;li&gt;&lt;a th:href="@&#123;/level2/2&#125;"&gt;七伤拳&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">&lt;li&gt;&lt;a th:href="@&#123;/level2/3&#125;"&gt;梯云纵&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line"></span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;div sec:authorize=<span class="string">"hasRole('VIP3')"</span>&gt;</span><br><span class="line">&lt;h3&gt;绝世武功秘籍&lt;/h3&gt;</span><br><span class="line">&lt;ul&gt;</span><br><span class="line">&lt;li&gt;&lt;a th:href="@&#123;/level3/1&#125;"&gt;葵花宝典&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">&lt;li&gt;&lt;a th:href="@&#123;/level3/2&#125;"&gt;龟派气功&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">&lt;li&gt;&lt;a th:href="@&#123;/level3/3&#125;"&gt;独孤九剑&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html xmlns:th=<span class="string">"http://www.thymeleaf.org"</span>&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta http-equiv=<span class="string">"Content-Type"</span> content=<span class="string">"text/html; charset=UTF-8"</span>&gt;</span><br><span class="line">&lt;title&gt;Insert title here&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;a th:href="@&#123;/&#125;"&gt;返回&lt;/a&gt;</span><br><span class="line">&lt;h1&gt;罗汉拳&lt;/h1&gt;</span><br><span class="line">&lt;p&gt;罗汉拳站当央,打起来不要慌&lt;/p&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html xmlns:th=<span class="string">"http://www.thymeleaf.org"</span>&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta http-equiv=<span class="string">"Content-Type"</span> content=<span class="string">"text/html; charset=UTF-8"</span>&gt;</span><br><span class="line">&lt;title&gt;Insert title here&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;a th:href="@&#123;/&#125;"&gt;返回&lt;/a&gt;</span><br><span class="line">&lt;h1&gt;太极拳&lt;/h1&gt;</span><br><span class="line">&lt;p&gt;</span><br><span class="line">       一个西瓜圆又圆 劈它一刀成两半 你一半来 给你你不要 给他他不收 那就不给 把两人撵走 他们不走你走 走啦，一挥手，伤自尊</span><br><span class="line">                  不买西瓜别缠我，缓慢纠缠様 两人缠我赖皮，手慢动作左右挥动 看我厉害，转头缓步拍苍蝇状 拍死了，手抱西瓜状+奥特曼十字手+广播操准备运动的站立</span><br><span class="line">    &lt;/p&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html xmlns:th=<span class="string">"http://www.thymeleaf.org"</span>&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta http-equiv=<span class="string">"Content-Type"</span> content=<span class="string">"text/html; charset=UTF-8"</span>&gt;</span><br><span class="line">&lt;title&gt;Insert title here&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;a th:href="@&#123;/&#125;"&gt;返回&lt;/a&gt;</span><br><span class="line">&lt;h1&gt;葵花宝典&lt;/h1&gt;</span><br><span class="line">&lt;p&gt;欲练神功，挥刀自宫&lt;/p&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;五、Spring-Boot与安全&quot;&gt;&lt;a href=&quot;#五、Spring-Boot与安全&quot; class=&quot;headerlink&quot; title=&quot;五、Spring Boot与安全&quot;&gt;&lt;/a&gt;五、Spring Boot与安全&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;安全、Spring Security&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;一、安全&quot;&gt;&lt;a href=&quot;#一、安全&quot; class=&quot;headerlink&quot; title=&quot;一、安全&quot;&gt;&lt;/a&gt;一、安全&lt;/h2&gt;&lt;p&gt;Spring Security是针对Spring项目的安全框架，也是Spring Boot底层安全模 块默认的技术选型。他可以实现强大的web安全控制。对于安全控制，我们仅 需引入spring-boot-starter-security模块，进行少量的配置，即可实现强大的 安全管理。&lt;/p&gt;
&lt;p&gt;几个类：
    
    </summary>
    
    
    
      <category term="Spring Boot" scheme="ayjcsgm.github.io/tags/Spring-Boot/"/>
    
  </entry>
  
  <entry>
    <title>4、Spring Boot笔记整理高级篇-任务</title>
    <link href="ayjcsgm.github.io/2019/11/08/4%E3%80%81Spring-Boot%E5%B0%9A%E7%A1%85%E8%B0%B7%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86%E9%AB%98%E7%BA%A7%E7%AF%87-%E4%BB%BB%E5%8A%A1/"/>
    <id>ayjcsgm.github.io/2019/11/08/4、Spring-Boot尚硅谷笔记整理高级篇-任务/</id>
    <published>2019-11-08T10:37:53.000Z</published>
    <updated>2019-12-14T11:31:05.930Z</updated>
    
    <content type="html"><![CDATA[<h1 id="四、Spring-Boot与任务"><a href="#四、Spring-Boot与任务" class="headerlink" title="四、Spring Boot与任务"></a>四、Spring Boot与任务</h1><p><strong>异步任务、定时任务、邮件任务</strong></p><h2 id="一、异步任务"><a href="#一、异步任务" class="headerlink" title="一、异步任务"></a>一、异步任务</h2><p>在Java应用中，绝大多数情况下都是通过同步的方式来实现交互处理的；但是在 处理与第三方系统交互的时候，容易造成响应迟缓的情况，之前大部分都是使用 多线程来完成此类任务，其实，在Spring 3.x之后，就已经内置了@Async来完 美解决这个问题。</p><p>两个注解：<br>@EnableAysnc、@Aysnc</p><a id="more"></a><h2 id="二、定时任务"><a href="#二、定时任务" class="headerlink" title="二、定时任务"></a>二、定时任务</h2><p>项目开发中经常需要执行一些定时任务，比如需要在每天凌晨时候，分析一次前 一天的日志信息。Spring为我们提供了异步执行任务调度的方式，提供 TaskExecutor 、TaskScheduler 接口。</p><p>两个注解：<br>@EnableScheduling、@Scheduled</p><p><img src="https://img-blog.csdnimg.cn/20191108173833856.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20191108173858502.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzY2NDQxOA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="三、邮件任务"><a href="#三、邮件任务" class="headerlink" title="三、邮件任务"></a>三、邮件任务</h2><ul><li>邮件发送需要引入spring-boot-starter-mail </li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-boot-starter-mail&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><ul><li>Spring Boot 自动配置MailSenderAutoConfiguration </li><li>定义MailProperties内容，配置在application.yml中 </li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">spring.mail.username=<span class="number">534096094</span><span class="meta">@qq</span>.com</span><br><span class="line">spring.mail.password=gtstkoszjelabijb</span><br><span class="line">spring.mail.host=smtp.qq.com</span><br><span class="line">spring.mail.properties.mail.smtp.ssl.enable=<span class="keyword">true</span></span><br></pre></td></tr></table></figure><ul><li>自动装配JavaMailSender • 测试邮件发送<br><img src="https://img-blog.csdnimg.cn/20191108174001575.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzY2NDQxOA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li></ul><p>异步service</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.task.service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.scheduling.annotation.Async;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AsyncService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//告诉Spring这是一个异步方法</span></span><br><span class="line">    <span class="meta">@Async</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"处理数据中..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>异步controller</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.task.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.atguigu.task.service.AsyncService;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AsyncController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    AsyncService asyncService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/hello"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">()</span></span>&#123;</span><br><span class="line">        asyncService.hello();</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"success"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定时service</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.task.service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.scheduling.annotation.Scheduled;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ScheduledService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * second(秒), minute（分）, hour（时）, day of month（日）, month（月）, day of week（周几）.</span></span><br><span class="line"><span class="comment">     * 0 * * * * MON-FRI</span></span><br><span class="line"><span class="comment">     *  【0 0/5 14,18 * * ?】 每天14点整，和18点整，每隔5分钟执行一次</span></span><br><span class="line"><span class="comment">     *  【0 15 10 ? * 1-6】 每个月的周一至周六10:15分执行一次</span></span><br><span class="line"><span class="comment">     *  【0 0 2 ? * 6L】每个月的最后一个周六凌晨2点执行一次</span></span><br><span class="line"><span class="comment">     *  【0 0 2 LW * ?】每个月的最后一个工作日凌晨2点执行一次</span></span><br><span class="line"><span class="comment">     *  【0 0 2-4 ? * 1#1】每个月的第一个周一凌晨2点到4点期间，每个整点都执行一次；</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">   <span class="comment">// @Scheduled(cron = "0 * * * * MON-SAT")</span></span><br><span class="line">    <span class="comment">//@Scheduled(cron = "0,1,2,3,4 * * * * MON-SAT")</span></span><br><span class="line">   <span class="comment">// @Scheduled(cron = "0-4 * * * * MON-SAT")</span></span><br><span class="line">    <span class="meta">@Scheduled</span>(cron = <span class="string">"0/4 * * * * MON-SAT"</span>)  <span class="comment">//每4秒执行一次</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"hello ... "</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>邮件测试类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.task;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> org.junit.runner.RunWith;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.context.SpringBootTest;</span><br><span class="line"><span class="keyword">import</span> org.springframework.mail.SimpleMailMessage;</span><br><span class="line"><span class="keyword">import</span> org.springframework.mail.javamail.JavaMailSenderImpl;</span><br><span class="line"><span class="keyword">import</span> org.springframework.mail.javamail.MimeMessageHelper;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.context.junit4.SpringRunner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.mail.internet.MimeMessage;</span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RunWith</span>(SpringRunner.class)</span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Springboot04TaskApplicationTests</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">JavaMailSenderImpl mailSender;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextLoads</span><span class="params">()</span> </span>&#123;</span><br><span class="line">SimpleMailMessage message = <span class="keyword">new</span> SimpleMailMessage();</span><br><span class="line"><span class="comment">//邮件设置</span></span><br><span class="line">message.setSubject(<span class="string">"通知-今晚开会"</span>);</span><br><span class="line">message.setText(<span class="string">"今晚7:30开会"</span>);</span><br><span class="line"></span><br><span class="line">message.setTo(<span class="string">"17512080612@163.com"</span>);</span><br><span class="line">message.setFrom(<span class="string">"534096094@qq.com"</span>);</span><br><span class="line"></span><br><span class="line">mailSender.send(message);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span> <span class="keyword">throws</span>  Exception</span>&#123;</span><br><span class="line"><span class="comment">//1、创建一个复杂的消息邮件</span></span><br><span class="line">MimeMessage mimeMessage = mailSender.createMimeMessage();</span><br><span class="line">MimeMessageHelper helper = <span class="keyword">new</span> MimeMessageHelper(mimeMessage, <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//邮件设置</span></span><br><span class="line">helper.setSubject(<span class="string">"通知-今晚开会"</span>);</span><br><span class="line">helper.setText(<span class="string">"&lt;b style='color:red'&gt;今天 7:30 开会&lt;/b&gt;"</span>,<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">helper.setTo(<span class="string">"17512080612@163.com"</span>);</span><br><span class="line">helper.setFrom(<span class="string">"534096094@qq.com"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//上传文件</span></span><br><span class="line">helper.addAttachment(<span class="string">"1.jpg"</span>,<span class="keyword">new</span> File(<span class="string">"C:\\Users\\lfy\\Pictures\\Saved Pictures\\1.jpg"</span>));</span><br><span class="line">helper.addAttachment(<span class="string">"2.jpg"</span>,<span class="keyword">new</span> File(<span class="string">"C:\\Users\\lfy\\Pictures\\Saved Pictures\\2.jpg"</span>));</span><br><span class="line"></span><br><span class="line">mailSender.send(mimeMessage);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;四、Spring-Boot与任务&quot;&gt;&lt;a href=&quot;#四、Spring-Boot与任务&quot; class=&quot;headerlink&quot; title=&quot;四、Spring Boot与任务&quot;&gt;&lt;/a&gt;四、Spring Boot与任务&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;异步任务、定时任务、邮件任务&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;一、异步任务&quot;&gt;&lt;a href=&quot;#一、异步任务&quot; class=&quot;headerlink&quot; title=&quot;一、异步任务&quot;&gt;&lt;/a&gt;一、异步任务&lt;/h2&gt;&lt;p&gt;在Java应用中，绝大多数情况下都是通过同步的方式来实现交互处理的；但是在 处理与第三方系统交互的时候，容易造成响应迟缓的情况，之前大部分都是使用 多线程来完成此类任务，其实，在Spring 3.x之后，就已经内置了@Async来完 美解决这个问题。&lt;/p&gt;
&lt;p&gt;两个注解：&lt;br&gt;@EnableAysnc、@Aysnc&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="Spring Boot" scheme="ayjcsgm.github.io/tags/Spring-Boot/"/>
    
  </entry>
  
  <entry>
    <title>3、Spring Boot笔记整理高级篇-检索</title>
    <link href="ayjcsgm.github.io/2019/11/08/3%E3%80%81Spring-Boot%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86%E9%AB%98%E7%BA%A7%E7%AF%87-%E6%A3%80%E7%B4%A2/"/>
    <id>ayjcsgm.github.io/2019/11/08/3、Spring-Boot笔记整理高级篇-检索/</id>
    <published>2019-11-08T10:37:31.000Z</published>
    <updated>2019-12-14T11:30:13.907Z</updated>
    
    <content type="html"><![CDATA[<h1 id="三、Spring-Boot与检索"><a href="#三、Spring-Boot与检索" class="headerlink" title="三、Spring Boot与检索"></a>三、Spring Boot与检索</h1><p><strong>ElasticSearch</strong></p><h2 id="一、检索"><a href="#一、检索" class="headerlink" title="一、检索"></a>一、检索</h2><p>我们的应用经常需要添加检索功能，开源的 ElasticSearch 是目前全文搜索引擎的 首选。他可以快速的存储、搜索和分析海量数据。Spring Boot通过整合Spring Data ElasticSearch为我们提供了非常便捷的检索功能支持；<br>Elasticsearch是一个分布式搜索服务，提供Restful API，底层基于Lucene，采用 多shard（分片）的方式保证数据安全，并且提供自动resharding的功能，github 等大型的站点也是采用了ElasticSearch作为其搜索服务，<a id="more"></a></p><h2 id="二、概念"><a href="#二、概念" class="headerlink" title="二、概念"></a>二、概念</h2><ul><li>以员工文档 的形式存储为例：一个文档代表一个员工数据。存储数据到 ElasticSearch 的行为叫做 索引 ，但在索引一个文档之前，需要确定将文档存 储在哪里。 </li><li>一个 ElasticSearch 集群可以 包含多个 索引 ，相应的每个索引可以包含多 个 类型 。 这些不同的类型存储着多个 文档 ，每个文档又有 多个 属性 。 </li><li>类似关系：<br>– 索引-数据库<br>– 类型-表<br>– 文档-表中的记录<br>– 属性-列<br><img src="https://img-blog.csdnimg.cn/20191108172917980.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzY2NDQxOA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><h2 id="三、整合ElasticSearch测试"><a href="#三、整合ElasticSearch测试" class="headerlink" title="三、整合ElasticSearch测试"></a>三、整合ElasticSearch测试</h2></li><li>引入spring-boot-starter-data-elasticsearch </li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-boot-starter-data-elasticsearch&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><ul><li>安装Spring Data 对应版本的ElasticSearch </li><li>application.yml配置 </li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">spring.elasticsearch.jest.uris=http:<span class="comment">//118.24.44.169:9200</span></span><br><span class="line"></span><br><span class="line">spring.data.elasticsearch.cluster-name=elasticsearch</span><br><span class="line">spring.data.elasticsearch.cluster-nodes=<span class="number">118.24</span>.44.169:<span class="number">9301</span></span><br></pre></td></tr></table></figure><ul><li>Spring Boot自动配置的 ElasticsearchRepository、ElasticsearchTemplate、Jest </li><li>测试ElasticSearch</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.elastic;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.atguigu.elastic.bean.Article;</span><br><span class="line"><span class="keyword">import</span> com.atguigu.elastic.bean.Book;</span><br><span class="line"><span class="keyword">import</span> com.atguigu.elastic.repository.BookRepository;</span><br><span class="line"><span class="keyword">import</span> io.searchbox.client.JestClient;</span><br><span class="line"><span class="keyword">import</span> io.searchbox.core.Index;</span><br><span class="line"><span class="keyword">import</span> io.searchbox.core.Search;</span><br><span class="line"><span class="keyword">import</span> io.searchbox.core.SearchResult;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> org.junit.runner.RunWith;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.context.SpringBootTest;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.context.junit4.SpringRunner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RunWith</span>(SpringRunner.class)</span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Springboot03ElasticApplicationTests</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">JestClient jestClient;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">BookRepository bookRepository;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//Book book = new Book();</span></span><br><span class="line"><span class="comment">//book.setId(1);</span></span><br><span class="line"><span class="comment">//book.setBookName("西游记");</span></span><br><span class="line"><span class="comment">//book.setAuthor("吴承恩");</span></span><br><span class="line"><span class="comment">//bookRepository.index(book);</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (Book book : bookRepository.findByBookNameLike(<span class="string">"游"</span>)) &#123;</span><br><span class="line">System.out.println(book);</span><br><span class="line">&#125;</span><br><span class="line">;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextLoads</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//1、给Es中索引（保存）一个文档；</span></span><br><span class="line">Article article = <span class="keyword">new</span> Article();</span><br><span class="line">article.setId(<span class="number">1</span>);</span><br><span class="line">article.setTitle(<span class="string">"好消息"</span>);</span><br><span class="line">article.setAuthor(<span class="string">"zhangsan"</span>);</span><br><span class="line">article.setContent(<span class="string">"Hello World"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//构建一个索引功能</span></span><br><span class="line">Index index = <span class="keyword">new</span> Index.Builder(article).index(<span class="string">"atguigu"</span>).type(<span class="string">"news"</span>).build();</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//执行</span></span><br><span class="line">jestClient.execute(index);</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试搜索</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">search</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//查询表达式</span></span><br><span class="line">String json =<span class="string">"&#123;\n"</span> +</span><br><span class="line"><span class="string">"    \"query\" : &#123;\n"</span> +</span><br><span class="line"><span class="string">"        \"match\" : &#123;\n"</span> +</span><br><span class="line"><span class="string">"            \"content\" : \"hello\"\n"</span> +</span><br><span class="line"><span class="string">"        &#125;\n"</span> +</span><br><span class="line"><span class="string">"    &#125;\n"</span> +</span><br><span class="line"><span class="string">"&#125;"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//更多操作：https://github.com/searchbox-io/Jest/tree/master/jest</span></span><br><span class="line"><span class="comment">//构建搜索功能</span></span><br><span class="line">Search search = <span class="keyword">new</span> Search.Builder(json).addIndex(<span class="string">"atguigu"</span>).addType(<span class="string">"news"</span>).build();</span><br><span class="line"></span><br><span class="line"><span class="comment">//执行</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">SearchResult result = jestClient.execute(search);</span><br><span class="line">System.out.println(result.getJsonString());</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.elastic.repository;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.atguigu.elastic.bean.Book;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.elasticsearch.repository.ElasticsearchRepository;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BookRepository</span> <span class="keyword">extends</span> <span class="title">ElasticsearchRepository</span>&lt;<span class="title">Book</span>,<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//参照</span></span><br><span class="line">    <span class="comment">// https://docs.spring.io/spring-data/elasticsearch/docs/3.0.6.RELEASE/reference/html/</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> List&lt;Book&gt; <span class="title">findByBookNameLike</span><span class="params">(String bookName)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.elastic.bean;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.data.elasticsearch.annotations.Document;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Document</span>(indexName = <span class="string">"atguigu"</span>,type = <span class="string">"book"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Book</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String bookName;</span><br><span class="line">    <span class="keyword">private</span> String author;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(Integer id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getBookName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> bookName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBookName</span><span class="params">(String bookName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.bookName = bookName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getAuthor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> author;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAuthor</span><span class="params">(String author)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.author = author;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Book&#123;"</span> +</span><br><span class="line">                <span class="string">"id="</span> + id +</span><br><span class="line">                <span class="string">", bookName='"</span> + bookName + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", author='"</span> + author + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.elastic.bean;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.searchbox.annotations.JestId;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Article</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@JestId</span></span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String author;</span><br><span class="line">    <span class="keyword">private</span> String title;</span><br><span class="line">    <span class="keyword">private</span> String content;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(Integer id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getAuthor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> author;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAuthor</span><span class="params">(String author)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.author = author;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getTitle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> title;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTitle</span><span class="params">(String title)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.title = title;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getContent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> content;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setContent</span><span class="params">(String content)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.content = content;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;三、Spring-Boot与检索&quot;&gt;&lt;a href=&quot;#三、Spring-Boot与检索&quot; class=&quot;headerlink&quot; title=&quot;三、Spring Boot与检索&quot;&gt;&lt;/a&gt;三、Spring Boot与检索&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;ElasticSearch&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;一、检索&quot;&gt;&lt;a href=&quot;#一、检索&quot; class=&quot;headerlink&quot; title=&quot;一、检索&quot;&gt;&lt;/a&gt;一、检索&lt;/h2&gt;&lt;p&gt;我们的应用经常需要添加检索功能，开源的 ElasticSearch 是目前全文搜索引擎的 首选。他可以快速的存储、搜索和分析海量数据。Spring Boot通过整合Spring Data ElasticSearch为我们提供了非常便捷的检索功能支持；&lt;br&gt;Elasticsearch是一个分布式搜索服务，提供Restful API，底层基于Lucene，采用 多shard（分片）的方式保证数据安全，并且提供自动resharding的功能，github 等大型的站点也是采用了ElasticSearch作为其搜索服务，
    
    </summary>
    
    
    
      <category term="Spring Boot" scheme="ayjcsgm.github.io/tags/Spring-Boot/"/>
    
  </entry>
  
  <entry>
    <title>2、Spring Boot笔记整理高级篇-消息</title>
    <link href="ayjcsgm.github.io/2019/11/06/2%E3%80%81Spring-Boot%E5%B0%9A%E7%A1%85%E8%B0%B7%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86%E9%AB%98%E7%BA%A7%E7%AF%87-%E6%B6%88%E6%81%AF/"/>
    <id>ayjcsgm.github.io/2019/11/06/2、Spring-Boot尚硅谷笔记整理高级篇-消息/</id>
    <published>2019-11-06T09:26:15.000Z</published>
    <updated>2019-12-14T11:28:57.399Z</updated>
    
    <content type="html"><![CDATA[<h1 id="二、Spring-Boot与消息"><a href="#二、Spring-Boot与消息" class="headerlink" title="二、Spring Boot与消息"></a>二、Spring Boot与消息</h1><p><strong>JMS、AMQP、RabbitMQ</strong></p><h2 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h2><ol><li>大多应用中，可通过消息服务中间件来提升系统异步通信、扩展解耦能力 </li><li>消息服务中两个重要概念： 消息代理（message broker）和目的地（destination） 当消息发送者发送消息以后，将由消息代理接管，消息代理保证消息传递到指定目 的地。<a id="more"></a> </li><li>消息队列主要有两种形式的目的地<ol><li>队列（queue）：点对点消息通信（point-to-point） </li><li>主题（topic）：发布（publish）/订阅（subscribe）消息通信<br><img src="https://img-blog.csdnimg.cn/20191106170731577.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20191106170742253.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzY2NDQxOA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20191106170806686.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20191106170815959.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzY2NDQxOA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20191106170824262.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20191106170829599.png" alt="在这里插入图片描述"></li></ol></li><li>点对点式： – 消息发送者发送消息，消息代理将其放入一个队列中，消息接收者从队列中获取消息内容， 消息读取后被移出队列 – 消息只有唯一的发送者和接受者，但并不是说只能有一个接收者</li><li>发布订阅式： – 发送者（发布者）发送消息到主题，多个接收者（订阅者）监听（订阅）这个主题，那么 就会在消息到达时同时收到消息</li><li>JMS（Java Message Service）JAVA消息服务：<br>– 基于JVM消息代理的规范。ActiveMQ、HornetMQ是JMS实现</li><li>AMQP（Advanced Message Queuing Protocol）<br>– 高级消息队列协议，也是一个消息代理的规范，兼容JMS<br>– RabbitMQ是AMQP的实现<br><img src="https://img-blog.csdnimg.cn/20191106170951319.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzY2NDQxOA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li><li>Spring支持<br>– spring-jms提供了对JMS的支持<br>– spring-rabbit提供了对AMQP的支持<br>– 需要ConnectionFactory的实现来连接消息代理<br>– 提供JmsTemplate、RabbitTemplate来发送消息<br>– @JmsListener（JMS）、@RabbitListener（AMQP）注解在方法上监听消息代理发 布的消息<br>– @EnableJms、@EnableRabbit开启支持</li><li>Spring Boot自动配置<br>– JmsAutoConfiguration<br>– RabbitAutoConfiguration<h2 id="二、RabbitMQ简介"><a href="#二、RabbitMQ简介" class="headerlink" title="二、RabbitMQ简介"></a>二、RabbitMQ简介</h2>RabbitMQ简介：<br>RabbitMQ是一个由erlang开发的AMQP(Advanved Message Queue Protocol)的开源实现。</li></ol><p><strong>核心概念</strong><br> Message<br>     消息，消息是不具名的，它由消息头和消息体组成。消息体是不透明的，而消息头则由一系列的可选属性组 成，这些属性包括routing-key（路由键）、priority（相对于其他消息的优先权）、delivery-mode（指出 该消息可能需要持久性存储）等。</p><p>Publisher<br>    消息的生产者，也是一个向交换器发布消息的客户端应用程序。</p><p>Exchange<br>    交换器，用来接收生产者发送的消息并将这些消息路由给服务器中的队列。 Exchange有4种类型：direct(默认)，fanout, topic, 和headers，不同类型的Exchange转发消息的策略有 所区别 </p><p>Queue<br>    消息队列，用来保存消息直到发送给消费者。它是消息的容器，也是消息的终点。一个消息 可投入一个或多个队列。消息一直在队列里面，等待消费者连接到这个队列将其取走。</p><p>Binding<br>    绑定，用于消息队列和交换器之间的关联。一个绑定就是基于路由键将交换器和消息队列连 接起来的路由规则，所以可以将交换器理解成一个由绑定构成的路由表。 Exchange 和Queue的绑定可以是多对多的关系。</p><p>Connection<br>    网络连接，比如一个TCP连接。</p><p>Channel<br>    信道，多路复用连接中的一条独立的双向数据流通道。信道是建立在真实的TCP连接内的虚 拟连接，AMQP 命令都是通过信道发出去的，不管是发布消息、订阅队列还是接收消息，这 些动作都是通过信道完成。因为对于操作系统来说建立和销毁 TCP 都是非常昂贵的开销，所 以引入了信道的概念，以复用一条 TCP 连接。</p><p>Consumer<br>消息的消费者，表示一个从消息队列中取得消息的客户端应用程序。</p><p>Virtual Host<br>虚拟主机，表示一批交换器、消息队列和相关对象。虚拟主机是共享相同的身份认证和加 密环境的独立服务器域。每个 vhost 本质上就是一个 mini 版的 RabbitMQ 服务器，拥有 自己的队列、交换器、绑定和权限机制。vhost 是 AMQP 概念的基础，必须在连接时指定， RabbitMQ 默认的 vhost 是 / 。 </p><p>Broker<br>表示消息队列服务器实体<br><img src="https://img-blog.csdnimg.cn/20191106171555594.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzY2NDQxOA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="三、RabbitMQ运行机制"><a href="#三、RabbitMQ运行机制" class="headerlink" title="三、RabbitMQ运行机制"></a>三、RabbitMQ运行机制</h2><p>AMQP 中的消息路由<br>• AMQP 中消息的路由过程和 Java 开发者熟悉的 JMS 存在一些差别，AMQP 中增加了 <strong>Exchange 和 Binding</strong> 的角色。生产者把消息发布到 Exchange 上，消息最终到达队列并被 消费者接收，而 Binding 决定交换器的消息应该发送到那个队列。<br><img src="https://img-blog.csdnimg.cn/20191106171646502.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzY2NDQxOA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>Exchange 类型<br>• Exchange分发消息时根据类型的不同分发策略有区别，目前共四种类型： direct、fanout、topic、headers 。headers 匹配 AMQP 消息的 header 而不是路由键， headers 交换器和 direct 交换器完全一致，但性能差很多， 目前几乎用不到了，所以直接看另外三种类型：</p><p>消息中的路由键（routing key）如果和 Binding 中的 binding key 一致， 交换器就将消息发到对应的队列中。路由键与队 列名完全匹配，如果一个队列绑定到交换机要求路由键为 “dog”，则只转发 routing key 标记为“dog”的消息，不会转 发“dog.puppy”，也不会转发“dog.guard”等等。它是完全 匹配、单播的模式。<br><img src="https://img-blog.csdnimg.cn/20191106171722181.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzY2NDQxOA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><hr><p>每个发到 fanout 类型交换器的消息都会分到所 有绑定的队列上去。fanout 交换器不处理路由键， 只是简单的将队列绑定到交换器上，每个发送 到交换器的消息都会被转发到与该交换器绑定 的所有队列上。很像子网广播，每台子网内的 主机都获得了一份复制的消息。fanout 类型转发 消息是最快的。<br><img src="https://img-blog.csdnimg.cn/20191106171826452.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzY2NDQxOA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><hr>topic 交换器通过模式匹配分配消息的路由键属 性，将路由键和某个模式进行匹配，此时队列 需要绑定到一个模式上。它将路由键和绑定键 的字符串切分成单词，这些单词之间用点隔开。 它同样也会识别两个通配符：符号“#”和符号 “* ” 。 # 匹配 0 个或多个单词 ， *匹配一个单词。<p><img src="https://img-blog.csdnimg.cn/20191106171847634.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzY2NDQxOA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="四、RabbitMQ整合"><a href="#四、RabbitMQ整合" class="headerlink" title="四、RabbitMQ整合"></a>四、RabbitMQ整合</h2><ol><li>引入 spring-boot-starter-amqp </li><li>application.yml配置 </li><li>测试RabbitMQ <ol><li>AmqpAdmin：管理组件 </li><li>RabbitTemplate：消息发送处理组件<br><img src="https://img-blog.csdnimg.cn/20191106172126261.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzY2NDQxOA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li></ol></li></ol><p><strong>application.properties</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">spring.rabbitmq.host=<span class="number">192.168</span>.169.131</span><br><span class="line">spring.rabbitmq.username=guest</span><br><span class="line">spring.rabbitmq.password=guest</span><br></pre></td></tr></table></figure><p><strong>RabbitmqApplication</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.rabbitmq;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.annotation.EnableRabbit;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自动配置</span></span><br><span class="line"><span class="comment"> *  1、RabbitAutoConfiguration</span></span><br><span class="line"><span class="comment"> *  2、有自动配置了连接工厂ConnectionFactory；</span></span><br><span class="line"><span class="comment"> *  3、RabbitProperties 封装了 RabbitMQ的配置</span></span><br><span class="line"><span class="comment"> *  4、 RabbitTemplate ：给RabbitMQ发送和接受消息；</span></span><br><span class="line"><span class="comment"> *  5、 AmqpAdmin ： RabbitMQ系统管理功能组件;</span></span><br><span class="line"><span class="comment"> *  AmqpAdmin：创建和删除 Queue，Exchange，Binding</span></span><br><span class="line"><span class="comment"> *  6、<span class="doctag">@EnableRabbit</span> +  <span class="doctag">@RabbitListener</span> 监听消息队列的内容</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@EnableRabbit</span>  <span class="comment">//开启基于注解的RabbitMQ模式</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RabbitmqApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(RabbitmqApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>RabbitmqApplicationTests</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.rabbitmq;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.example.rabbitmq.bean.Book;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.Test;</span><br><span class="line"><span class="keyword">import</span> org.junit.runner.RunWith;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.AmqpAdmin;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.core.RabbitTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.context.SpringBootTest;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.context.junit4.SpringRunner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RunWith</span>(SpringRunner.class)</span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RabbitmqApplicationTests</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    RabbitTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    AmqpAdmin amqpAdmin;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createExchange</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//amqpAdmin.declareExchange(new DirectExchange("amqpadmin.exchange"));</span></span><br><span class="line"><span class="comment">//System.out.println("创建完成");</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//amqpAdmin.declareQueue(new Queue("amqpadmin.queue",true));</span></span><br><span class="line">        <span class="comment">//创建绑定规则</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//amqpAdmin.declareBinding(new Binding("amqpadmin.queue", Binding.DestinationType.QUEUE,"amqpadmin.exchange","amqp.haha",null));</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//amqpAdmin.de</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//单播（点对点）</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">contextLoads</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//Message需要自己构造一个；定义消息体内容和消息头</span></span><br><span class="line">        <span class="comment">//rabbitTemplate.send(exchage,routeKey,message);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//object默认当成消息体，只需要传入要发送的对象，自动序列化发送给rabbitmq</span></span><br><span class="line">        <span class="comment">//rabbitTemplate.convertAndSend(exchage,routKey,object);</span></span><br><span class="line">        Map&lt;String,String&gt; map=<span class="keyword">new</span> HashMap();</span><br><span class="line">        map.put(<span class="string">"a"</span>,<span class="string">"zs"</span>);</span><br><span class="line">        map.put(<span class="string">"b"</span>,<span class="string">"ls"</span>);</span><br><span class="line">        <span class="comment">//对象被默认序列化以后发送出去</span></span><br><span class="line">        rabbitTemplate.convertAndSend(<span class="string">"amq.direct"</span>,<span class="string">"rabbitmq"</span>,<span class="keyword">new</span> Book(<span class="string">"西游记"</span>,<span class="string">"吴承恩"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//接收数据</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receive</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        Object o = rabbitTemplate.receiveAndConvert(<span class="string">"rabbitmq"</span>);</span><br><span class="line"><span class="comment">//        class java.util.HashMap</span></span><br><span class="line"><span class="comment">//        &#123;a=zs, b=ls&#125;</span></span><br><span class="line">        System.out.println(o.getClass());</span><br><span class="line">        System.out.println(o);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//广播</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendMsg</span><span class="params">()</span></span>&#123;</span><br><span class="line">        rabbitTemplate.convertAndSend(<span class="string">"amq.fanout"</span>,<span class="string">""</span>,<span class="keyword">new</span> Book(<span class="string">"mnmn"</span>,<span class="string">"kjkj"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;二、Spring-Boot与消息&quot;&gt;&lt;a href=&quot;#二、Spring-Boot与消息&quot; class=&quot;headerlink&quot; title=&quot;二、Spring Boot与消息&quot;&gt;&lt;/a&gt;二、Spring Boot与消息&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;JMS、AMQP、RabbitMQ&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;一、概述&quot;&gt;&lt;a href=&quot;#一、概述&quot; class=&quot;headerlink&quot; title=&quot;一、概述&quot;&gt;&lt;/a&gt;一、概述&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;大多应用中，可通过消息服务中间件来提升系统异步通信、扩展解耦能力 &lt;/li&gt;
&lt;li&gt;消息服务中两个重要概念： 消息代理（message broker）和目的地（destination） 当消息发送者发送消息以后，将由消息代理接管，消息代理保证消息传递到指定目 的地。
    
    </summary>
    
    
    
      <category term="Spring Boot" scheme="ayjcsgm.github.io/tags/Spring-Boot/"/>
    
  </entry>
  
  <entry>
    <title>1、Spring Boot笔记整理高级篇-缓存</title>
    <link href="ayjcsgm.github.io/2019/11/05/1%E3%80%81Spring-Boot%E5%B0%9A%E7%A1%85%E8%B0%B7%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86%E9%AB%98%E7%BA%A7%E7%AF%87-%E7%BC%93%E5%AD%98/"/>
    <id>ayjcsgm.github.io/2019/11/05/1、Spring-Boot尚硅谷笔记整理高级篇-缓存/</id>
    <published>2019-11-05T14:01:48.000Z</published>
    <updated>2019-12-14T11:27:37.783Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1、Spring-Boot与缓存"><a href="#1、Spring-Boot与缓存" class="headerlink" title="1、Spring Boot与缓存"></a>1、Spring Boot与缓存</h1><pre><code>**JSR-107、Spring缓存抽象、整合Redis**</code></pre><h2 id="一、JSR107"><a href="#一、JSR107" class="headerlink" title="一、JSR107"></a>一、JSR107</h2><p>Java Caching定义了5个核心接口，分别是CachingProvider, CacheManager, Cache, Entry 和 Expiry。 <a id="more"></a></p><ul><li><p>CachingProvider定义了创建、配置、获取、管理和控制多个CacheManager。一个应用可 以在运行期访问多个CachingProvider。</p></li><li><p>CacheManager定义了创建、配置、获取、管理和控制多个唯一命名的Cache，这些Cache 存在于CacheManager的上下文中。一个CacheManager仅被一个CachingProvider所拥有。 </p></li><li><p>Cache是一个类似Map的数据结构并临时存储以Key为索引的值。一个Cache仅被一个 CacheManager所拥有。 </p></li><li><p>Entry是一个存储在Cache中的key-value对。 </p></li><li><p>Expiry 每一个存储在Cache中的条目有一个定义的有效期。一旦超过这个时间，条目为过期 的状态。一旦过期，条目将不可访问、更新和删除。缓存有效期可以通过ExpiryPolicy设置。<br><img src="https://img-blog.csdnimg.cn/20191105213706919.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzY2NDQxOA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="二、Spring缓存抽象"><a href="#二、Spring缓存抽象" class="headerlink" title="二、Spring缓存抽象"></a>二、Spring缓存抽象</h2><p>Spring从3.1开始定义了org.springframework.cache.Cache 和org.springframework.cache.CacheManager接口来统一不同的缓存技术； 并支持使用JCache（JSR-107）注解简化我们开发；</p></li><li><p>Cache接口为缓存的组件规范定义，包含缓存的各种操作集合； </p></li><li><p>Cache接口下Spring提供了各种xxxCache的实现；如RedisCache，EhCacheCache , ConcurrentMapCache等；</p></li><li><p>每次调用需要缓存功能的方法时，Spring会检查检查指定参数的指定的目标方法是否 已经被调用过；如果有就直接从缓存中获取方法调用后的结果，如果没有就调用方法 并缓存结果后返回给用户。下次调用直接从缓存中获取。 </p></li><li><p>使用Spring缓存抽象时我们需要关注以下两点；<br>1、确定方法需要被缓存以及他们的缓存策略<br>2、从缓存中读取之前缓存存储的数据<br><img src="https://img-blog.csdnimg.cn/20191105213937117.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzY2NDQxOA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="三、几个重要概念-amp-缓存注解"><a href="#三、几个重要概念-amp-缓存注解" class="headerlink" title="三、几个重要概念&amp;缓存注解"></a>三、几个重要概念&amp;缓存注解</h2><p><img src="https://img-blog.csdnimg.cn/20191105214022956.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzY2NDQxOA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20191105214042524.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzY2NDQxOA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20191105214221121.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzY2NDQxOA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="四、缓存使用"><a href="#四、缓存使用" class="headerlink" title="四、缓存使用"></a>四、缓存使用</h2></li><li><p>1、引入spring-boot-starter-cache模块 </p></li><li><p>2、@EnableCaching开启缓存 </p></li><li><p>3、使用缓存注解 </p></li><li><p>4、切换为其他缓存</p><h2 id="五、整合redis实现缓存"><a href="#五、整合redis实现缓存" class="headerlink" title="五、整合redis实现缓存"></a>五、整合redis实现缓存</h2></li></ul><ol><li>引入spring-boot-starter-data-redis </li><li>application.yml配置redis连接地址 </li><li>使用RestTemplate操作redis <ol><li>redisTemplate.opsForValue();//操作字符串 </li><li>redisTemplate.opsForHash();//操作hash </li><li>redisTemplate.opsForList();//操作list </li><li>redisTemplate.opsForSet();//操作set </li><li>redisTemplate.opsForZSet();//操作有序set <ol start="4"><li>配置缓存、CacheManagerCustomizers</li><li>测试使用缓存、切换缓存、 CompositeCacheManager</li></ol><strong>Redis配置类</strong></li></ol></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> hqp</span></span><br><span class="line"><span class="comment"> * redis配置类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableCaching</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CacheConfig</span> <span class="keyword">extends</span> <span class="title">CachingConfigurerSupport</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"rawtypes"</span>)</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CacheManager <span class="title">cacheManager</span><span class="params">(RedisTemplate redisTemplate)</span> </span>&#123;</span><br><span class="line">        RedisCacheManager rcm = <span class="keyword">new</span> RedisCacheManager(redisTemplate);</span><br><span class="line">        <span class="comment">// 多个缓存的名称,目前只定义了一个</span></span><br><span class="line">        rcm.setCacheNames(Arrays.asList(<span class="string">"thisredis"</span>));</span><br><span class="line">        <span class="comment">//设置缓存过期时间(秒)</span></span><br><span class="line">        rcm.setDefaultExpiration(<span class="number">600</span>);</span><br><span class="line">        <span class="keyword">return</span> rcm;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RedisTemplate&lt;String, String&gt; <span class="title">redisTemplate</span><span class="params">(RedisConnectionFactory factory)</span> </span>&#123;</span><br><span class="line">        StringRedisTemplate template = <span class="keyword">new</span> StringRedisTemplate(factory);</span><br><span class="line">        Jackson2JsonRedisSerializer jackson2JsonRedisSerializer = <span class="keyword">new</span> Jackson2JsonRedisSerializer(Object.class);</span><br><span class="line">        ObjectMapper om = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line">        om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);</span><br><span class="line">        om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);</span><br><span class="line">        jackson2JsonRedisSerializer.setObjectMapper(om);</span><br><span class="line">        template.setValueSerializer(jackson2JsonRedisSerializer);</span><br><span class="line">        template.afterPropertiesSet();</span><br><span class="line">        <span class="keyword">return</span> template;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出，我们这里主要配置了两个东西，<strong>cacheManager</strong>方法配置了一个缓存名称,它的名字叫做<strong>thisredis</strong>，当我们要在方法注解里面使用到它的时候,就要根据名称进行区分不同缓存。同时设置了缓<br>存的过期时间。<strong>redisTemplate</strong>则是比较常见的，我们设置了<strong>RedisTemplate</strong>,因此在代码里面,我们也可以通过<strong>@Autowired</strong>注入 <strong>RedisTemplate</strong>来操作redis.<br>使用</p><p>接下来就是如何使用注解啦,这一步反而是最简单的。其实只用到了两个注解,<strong>@Cacheable和@CacheEvict</strong>。第一个注解代表从缓存中查询指定的key，如果有，从缓存中取，不再执行方法。如果没有则执<br>行方法，并且将方法的返回值和指定的key关联起来，放入到缓存中。而<strong>@CacheEvict</strong>则是从缓存中清除指定的key对应的数据。使用的代码如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Cacheable</span>(value=<span class="string">"thisredis"</span>, key=<span class="string">"'users_'+#id"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">findUser</span><span class="params">(Integer id)</span> </span>&#123;</span><br><span class="line">        User user = <span class="keyword">new</span> User();</span><br><span class="line">        user.setUsername(<span class="string">"hlhdidi"</span>);</span><br><span class="line">        user.setPassword(<span class="string">"123"</span>);</span><br><span class="line">        user.setUid(id.longValue());</span><br><span class="line">        System.out.println(<span class="string">"log4j2坏啦?"</span>);</span><br><span class="line">        logger.info(<span class="string">"输入user,用户名:&#123;&#125;,密码:&#123;&#125;"</span>,user.getUsername(),user.getPassword());</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@CacheEvict</span>(value=<span class="string">"thisredis"</span>, key=<span class="string">"'users_'+#id"</span>,condition=<span class="string">"#id!=1"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delUser</span><span class="params">(Integer id)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 删除user</span></span><br><span class="line">        System.out.println(<span class="string">"user删除"</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>可以看出，我们用@Cacheable的value属性指定具体缓存，并通过key将其放入缓存中。这里key非常灵活，支持spring的el表达式，可以通过方法参数产生可变的key(见findUser方法)，也可以通过其指定在<br>什么情况下，使用/不使用缓存(见delUser方法)。<br><strong>其实就是一个写了一个注解，然后解析注解再把相应的数据存到redis。集群一样的原理只是生成redis模板时使用集群方式。</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;1、Spring-Boot与缓存&quot;&gt;&lt;a href=&quot;#1、Spring-Boot与缓存&quot; class=&quot;headerlink&quot; title=&quot;1、Spring Boot与缓存&quot;&gt;&lt;/a&gt;1、Spring Boot与缓存&lt;/h1&gt;&lt;pre&gt;&lt;code&gt;**JSR-107、Spring缓存抽象、整合Redis**&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;一、JSR107&quot;&gt;&lt;a href=&quot;#一、JSR107&quot; class=&quot;headerlink&quot; title=&quot;一、JSR107&quot;&gt;&lt;/a&gt;一、JSR107&lt;/h2&gt;&lt;p&gt;Java Caching定义了5个核心接口，分别是CachingProvider, CacheManager, Cache, Entry 和 Expiry。
    
    </summary>
    
    
    
      <category term="Spring Boot" scheme="ayjcsgm.github.io/tags/Spring-Boot/"/>
    
  </entry>
  
  <entry>
    <title>7、Spring Boot笔记整理-自定义starter</title>
    <link href="ayjcsgm.github.io/2019/11/02/7%E3%80%81Spring-Boot%E5%B0%9A%E7%A1%85%E8%B0%B7%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86-%E8%87%AA%E5%AE%9A%E4%B9%89starter/"/>
    <id>ayjcsgm.github.io/2019/11/02/7、Spring-Boot尚硅谷笔记整理-自定义starter/</id>
    <published>2019-11-02T11:32:06.000Z</published>
    <updated>2019-12-14T11:28:09.052Z</updated>
    
    <content type="html"><![CDATA[<h1 id="七、自定义starter"><a href="#七、自定义starter" class="headerlink" title="七、自定义starter"></a>七、自定义starter</h1><p>starter：</p><p>​    1、这个场景需要使用到的依赖是什么？</p><p>​    2、如何编写自动配置</p><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span>  <span class="comment">//指定这个类是一个配置类</span></span><br><span class="line"><span class="meta">@ConditionalOnXXX</span>  <span class="comment">//在指定条件成立的情况下自动配置类生效</span></span><br><span class="line"><span class="meta">@AutoConfigureAfter</span>  <span class="comment">//指定自动配置类的顺序</span></span><br><span class="line"><span class="meta">@Bean</span>  <span class="comment">//给容器中添加组件</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@ConfigurationPropertie</span>结合相关xxxProperties类来绑定相关的配置</span><br><span class="line"><span class="meta">@EnableConfigurationProperties</span> <span class="comment">//让xxxProperties生效加入到容器中</span></span><br><span class="line"></span><br><span class="line">自动配置类要能加载</span><br><span class="line">将需要启动就加载的自动配置类，配置在META-INF/spring.factories</span><br><span class="line">org.springframework.boot.autoconfigure.EnableAutoConfiguration=\</span><br><span class="line">org.springframework.boot.autoconfigure.admin.SpringApplicationAdminJmxAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.aop.AopAutoConfiguration,\</span><br></pre></td></tr></table></figure><p>​    3、模式：</p><p>启动器只用来做依赖导入；</p><p>专门来写一个自动配置模块；</p><p>启动器依赖自动配置；别人只需要引入启动器（starter）</p><p>mybatis-spring-boot-starter；自定义启动器名-spring-boot-starter</p><p>步骤：</p><p>1）、启动器模块</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.atguigu.starter<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>atguigu-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--启动器--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!--引入自动配置模块--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.atguigu.starter<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>atguigu-spring-boot-starter-autoconfigurer<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><p>2）、自动配置模块</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">   <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.atguigu.starter<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>atguigu-spring-boot-starter-autoconfigurer<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="tag">&lt;<span class="name">name</span>&gt;</span>atguigu-spring-boot-starter-autoconfigurer<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">description</span>&gt;</span>Demo project for Spring Boot<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.5.10.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span> <span class="comment">&lt;!-- lookup parent from repository --&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">project.reporting.outputEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.reporting.outputEncoding</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">&lt;!--引入spring-boot-starter；所有starter的基本配置--&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.starter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.context.properties.ConfigurationProperties;</span><br><span class="line"></span><br><span class="line"><span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"atguigu.hello"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloProperties</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String prefix;</span><br><span class="line">    <span class="keyword">private</span> String suffix;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getPrefix</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> prefix;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPrefix</span><span class="params">(String prefix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.prefix = prefix;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getSuffix</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> suffix;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSuffix</span><span class="params">(String suffix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.suffix = suffix;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.starter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    HelloProperties helloProperties;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> HelloProperties <span class="title">getHelloProperties</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> helloProperties;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setHelloProperties</span><span class="params">(HelloProperties helloProperties)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.helloProperties = helloProperties;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">sayHellAtguigu</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> helloProperties.getPrefix()+<span class="string">"-"</span> +name + helloProperties.getSuffix();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.starter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.condition.ConditionalOnWebApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.context.properties.EnableConfigurationProperties;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ConditionalOnWebApplication</span> <span class="comment">//web应用才生效</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties</span>(HelloProperties.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloServiceAutoConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    HelloProperties helloProperties;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> HelloService <span class="title">helloService</span><span class="params">()</span></span>&#123;</span><br><span class="line">        HelloService service = <span class="keyword">new</span> HelloService();</span><br><span class="line">        service.setHelloProperties(helloProperties);</span><br><span class="line">        <span class="keyword">return</span> service;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="更多SpringBoot整合示例"><a href="#更多SpringBoot整合示例" class="headerlink" title="更多SpringBoot整合示例"></a>更多SpringBoot整合示例</h1><p><a href="https://github.com/spring-projects/spring-boot/tree/master/spring-boot-samples" target="_blank" rel="noopener">https://github.com/spring-projects/spring-boot/tree/master/spring-boot-samples</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;七、自定义starter&quot;&gt;&lt;a href=&quot;#七、自定义starter&quot; class=&quot;headerlink&quot; title=&quot;七、自定义starter&quot;&gt;&lt;/a&gt;七、自定义starter&lt;/h1&gt;&lt;p&gt;starter：&lt;/p&gt;
&lt;p&gt;​    1、这个场景需要使用到的依赖是什么？&lt;/p&gt;
&lt;p&gt;​    2、如何编写自动配置&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="Spring Boot" scheme="ayjcsgm.github.io/tags/Spring-Boot/"/>
    
  </entry>
  
</feed>
